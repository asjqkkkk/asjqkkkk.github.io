<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>国庆-2019</title>
      <link href="undefined2019/10/07/%E5%9B%BD%E5%BA%86-2019/"/>
      <url>2019/10/07/%E5%9B%BD%E5%BA%86-2019/</url>
      
        <content type="html"><![CDATA[<p>去年国庆，没有回家，宅在出租屋里，每天打游戏，过的浑浑噩噩。</p><p>今年国庆，终于是决定回家了。回家确实满怀期待，毕竟和家人在一起还是蛮轻松的。</p><p>下面就简单的介绍这七天是如何过的吧</p><h2 id="10月1号"><a href="#10月1号" class="headerlink" title="10月1号"></a>10月1号</h2><p>节假日的火车票似乎都特别难抢，而我抢到的火车票是 <strong>10月2号</strong> 发车的，所以这一天我还待在广州。</p><p>由于前几日新换了住处，宽带的事情尚未办妥，并且旧住处的宽带套餐还未取消，于是一大早就坐公交去了营业厅准备取消业务，等到10点营业厅才正式营业。</p><p>因为是国庆当天，貌似各个地方都在播放北京天安门举行的“中国成立70周年庆典”，举国上下一片欢快景象，在营业厅看了一会儿庆典后终于解决了旧宽带的问题。接下来坐公交车回去，剪了头发，在没有网络的情况下煎熬着无所事事过完了这一天。</p><p><img src="https://oldchen-blog-1256696029.cos.ap-guangzhou.myqcloud.com/guoqing_2019/001.png" alt="image"></p><h2 id="10月2号"><a href="#10月2号" class="headerlink" title="10月2号"></a>10月2号</h2><p>早上5点30就匆匆忙忙起来，洗漱、<strong>如厕</strong>完毕后过了6点，就开始去赶公交车，为了能提前赶上8点多开动的火车。</p><p>车票是卧铺下铺，在火车上百无聊赖的度过10个小时后，终于到了岳阳，然后看着我爸在出口处接我。开车一个半小时左右到了荆州，一群长辈等着吃饭，勉为其难的还要去敬酒，我太讨厌酒的味道了，不过菜吃的还是很多的。</p><video src="https://oldchen-blog-1256696029.cos.ap-guangzhou.myqcloud.com/guoqing_2019/002.mp4" controls="controls" width="500"></video> <video src="https://oldchen-blog-1256696029.cos.ap-guangzhou.myqcloud.com/guoqing_2019/003.mp4" controls="controls" width="500"></video> <h2 id="10月3号"><a href="#10月3号" class="headerlink" title="10月3号"></a>10月3号</h2><p><strong>回老家</strong></p><p>因为爷爷是去年过世的，老家就奶奶独自一人待着，正好过节有时间回来一趟就去看一下她老人家，顺便带一点吃的喝的。</p><p>八点多吃完炒拉面后就动身了，十点左右到了老家，在一旁听我爸与奶奶交谈，之后顺便帮忙锄了锄地，到了接近12点就回去了。</p><p>这期间听说我爸在老家的一个医生朋友，因为打牌被抓了，我深感诧异，后来听说也是<strong>国庆节指标</strong>的缘故。</p><p>中午在家吃了些非常简单的菜，基本是素菜，味道非常平淡，只吃了一碗饭。</p><p>上一晚是我的一位亲戚请客吃饭，这天晚上是我们家请客，虽然人和昨天的一样，但是今天我没去敬酒了，照样是大吃了一顿。</p><p><img src="https://oldchen-blog-1256696029.cos.ap-guangzhou.myqcloud.com/guoqing_2019/004.png" alt="image"></p><video src="https://oldchen-blog-1256696029.cos.ap-guangzhou.myqcloud.com/guoqing_2019/005.mp4" controls="controls" width="500"></video> <h2 id="10月4号"><a href="#10月4号" class="headerlink" title="10月4号"></a>10月4号</h2><p>既然是国庆，总是想着要出去玩一下的，毕竟是个假期，总觉得不出去玩就可惜了。</p><p>于是今天一大早便跑去岳阳看了看<strong>岳阳楼</strong>，大人门票价70一位，小孩不要钱。</p><p>进去后花了差不多一个小时左右的时间就将岳阳楼看完了，由于游客稍多，所以也没有排队上景区中的“岳阳楼”。看完后觉得大失所望，一是因为游客较多显得景点过小，二是可看的东西确实不多，感觉这个景点就是一篇“岳阳楼记”的衍生周边产物，还不如旁边的<strong>洞庭湖</strong>来的壮阔</p><p>然后在景点附近吃完一顿二百左右的午饭后就回去了</p><p>晚饭本来打算在家里吃，突然得知原定10月5号一起玩的小伙伴今天晚上就得开车回上海了。于是晚饭就跑出去和小伙伴一起吃，小伙伴请客。</p><p><img src="https://oldchen-blog-1256696029.cos.ap-guangzhou.myqcloud.com/guoqing_2019/006.png" alt="image"></p><p><img src="https://oldchen-blog-1256696029.cos.ap-guangzhou.myqcloud.com/guoqing_2019/007.png" alt="image"></p><p><img src="https://oldchen-blog-1256696029.cos.ap-guangzhou.myqcloud.com/guoqing_2019/008.png" alt="image"></p><h2 id="10月5号"><a href="#10月5号" class="headerlink" title="10月5号"></a>10月5号</h2><p>这天没有什么多余的想法，就想宅在家里打游戏。</p><p>不过早上还是陪同老爸一起去养老院看了一下，也是为了奶奶后面的生活考虑。</p><p>今天的天气气温骤降，和昨天顶着太阳外出的情况截然相反，在养老院穿梭的时候，还下起了蒙蒙细雨。院中的老人有的三五成群围在一起打牌，有的形单影只在轮椅上静坐。</p><p>最后询问了工作人员，养老院的名额目前已经满了，只能等后面看看会不会空出一些位置。于是拿了养老院的宣传单便回家了。</p><p>因为懒得出去，中午我就一个人在外面解决了伙食问题，吃的7元的炒面，加了鸡蛋和火腿。开始觉得挺好吃的，吃着吃着就没了胃口，然后放下筷子和还剩一小半的炒面就走了。</p><p>到了晚上，老爸的朋友请客，于是我也过去吃了顿好的，坐席中还发现了老爸之前谈到过的因为国庆节打牌被抓了去的朋友，由于在座的都是老爸年轻时玩到现在的朋友，相较于之前陪同其他亲戚长辈们一起吃饭，基本上没有什么压力。</p><h2 id="10月6号"><a href="#10月6号" class="headerlink" title="10月6号"></a>10月6号</h2><p>早上7点半起床，准备到岳阳搭乘返回广州的火车。</p><p>这次依旧是卧铺，不过这次变成了中铺，并且火车的环境相较于来时的要脏乱一些。</p><p>在火车上狭窄的中铺内煎熬到了广州，下车时已是晚上9点。坐了公交车抵达住处，洗完睡觉。这一天算是过去了。</p><h2 id="10月7号"><a href="#10月7号" class="headerlink" title="10月7号"></a>10月7号</h2><p>起床后称了称体重，重了六斤多，看着体重秤的数字，我不禁陷入沉思。好在后来再次确认时发现是自己算错了，只重了两斤多。我应该高兴吗？</p><p>早上去了营业厅，办理了百兆宽带的业务。终于不用忍受没有网络的环境了。</p><p>下午宽带就可以正常使用了，又是玩了一下午的游戏，只想做个无忧无虑的sb。之后还是一如既往的进行锻炼、洗澡、睡觉。</p><p>我的2019年的国庆节就这样过去了。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>国庆期间，看着朋友圈里面的美景展览大赛，不禁心痒难耐，想着要去一个好看好玩的地方，结果岳阳的岳阳楼打破的我的幻想。但是能出去玩，我依旧蛮开心的，虽然游玩并不是一件看起来很轻松的事情。</p><p>期待下次和家人出去玩的地点是黄鹤楼，或者张家界吧。</p><p>在此之前，我一直都是一个宅在家里讨厌出门的死宅，但是现在对于旅游没有了抗拒的情绪。想来还得感谢那帮经常约我出去玩的朋友，我不仅变得愿意去旅游，我还变得更黑了。</p><p>也希望自己能一直处于轻松的状态，一边感受生活，一边在生活中自得其乐。</p><p>那么，今年的国庆播客就到此结束啦！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>长鹿游</title>
      <link href="undefined2019/09/22/%E9%95%BF%E9%B9%BF%E6%B8%B8/"/>
      <url>2019/09/22/%E9%95%BF%E9%B9%BF%E6%B8%B8/</url>
      
        <content type="html"><![CDATA[<p>话不多说，看视频吧</p><video src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/wx_camera_1569042496250.mp4" controls="controls" width="800"></video> <video src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_184216.mp4" controls="controls" width="500"></video> <video src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_161147.mp4" controls="controls" width="500"></video> <video src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_161001.mp4" controls="controls" width="500"></video> <video src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_160411.mp4" controls="controls" width="500"></video> <video src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_160315.mp4" controls="controls" width="500"></video> <video src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_155908.mp4" controls="controls" width="500"></video> <video src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_155542.mp4" controls="controls" width="500"></video> <video src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_155338.mp4" controls="controls" width="500"></video> <video src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_154611.mp4" controls="controls" width="500"></video> <video src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_153858.mp4" controls="controls" width="500"></video> <video src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_153533.mp4" controls="controls" width="500"></video> <video src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_152751.mp4" controls="controls" width="500"></video> <video src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_152520.mp4" controls="controls" width="500"></video> <video src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_152457.mp4" controls="controls" width="500"></video> <video src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_152215.mp4" controls="controls" width="500"></video> <video src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_152057.mp4" controls="controls" width="500"></video> <video src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_152044.mp4" controls="controls" width="500"></video> <video src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_151943.mp4" controls="controls" width="500"></video> <video src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_151651.mp4" controls="controls" width="500"></video> <video src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_151521.mp4" controls="controls" width="500"></video> <video src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/VID_20190921_151202.mp4" controls="controls" width="500"></video> <video src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/1569145952431.mp4" controls="controls" width="500"></video> <video src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/1569145947107.mp4" controls="controls" width="500"></video> <video src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/1569145943919.mp4" controls="controls" width="500"></video> <video src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/1569145940209.mp4" controls="controls" width="500"></video> <video src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/changlu_tour/1569145936738.mp4" controls="controls" width="500"></video> ]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>奇思妙想</title>
      <link href="undefined2019/09/08/%E5%A5%87%E6%80%9D%E5%A6%99%E6%83%B3/"/>
      <url>2019/09/08/%E5%A5%87%E6%80%9D%E5%A6%99%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="一闪而过的念头"><a href="#一闪而过的念头" class="headerlink" title="一闪而过的念头"></a>一闪而过的念头</h1><p>由于人类无法控制自己的思想，所以在日常生活里，我的脑袋中经常会冒出一些惊为天人(夸张手法)、莫名其妙、难以琢磨的想法。有的时候，想法的出现是由原因的，比如下雨天忘记带伞我就会想——“如果有传送工具直接避开户外行走就好了”；而有的时候，想法的出现可能是突如其来的，比如说突然想找女朋友然后谈一场说来就来的恋爱???</p><p>现在，无论是什么想法，只要是我觉得有意思的，我都会将它们记录于此。并且保持长期更新。</p><h1 id="脑洞脑洞脑洞"><a href="#脑洞脑洞脑洞" class="headerlink" title="脑洞脑洞脑洞"></a>脑洞脑洞脑洞</h1><p>让这些想法公之于众吧</p><h2 id="马赛克去除工具"><a href="#马赛克去除工具" class="headerlink" title="马赛克去除工具"></a>马赛克去除工具</h2><p>由于常年关注社会新闻的缘故。经常能看到案发视频中，被打上马赛克的“坏人”，而在我的三观中，我是不希望这样的人被打码可，所以去码工具还是有必要的（当然不是用于某些两三个人就演完的电影，想错的小伙伴请自动面壁）</p><h2 id="气味记录与气味释放"><a href="#气味记录与气味释放" class="headerlink" title="气味记录与气味释放"></a>气味记录与气味释放</h2><p>因为经常观看美食视频，所以我对美食有着强烈的执念，但是基本上除了卖相以外，我完全无法感受到食物的气味，如果在录视频的时候可以记录气味，在观看视频的时候顺便可以“播放”气味，那样“色香味”的前两者才能被真实感受到吧。</p><h2 id="关于5G的猜想"><a href="#关于5G的猜想" class="headerlink" title="关于5G的猜想"></a>关于5G的猜想</h2><p>我希望5G带来的速度，可以让我等游戏玩家非常便捷的玩到游戏。也就是说，云游戏是很有必要的，也许以前玩一款3A大作需要配置高端且笨重的游戏本，那么5G环境下也许只需要一个大屏的平板+蓝牙手柄就可以了。</p><p>期待吧！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 奇思妙想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>早睡早起身体好</title>
      <link href="undefined2019/09/03/%E6%97%A9%E7%9D%A1%E6%97%A9%E8%B5%B7%E8%BA%AB%E4%BD%93%E5%A5%BD/"/>
      <url>2019/09/03/%E6%97%A9%E7%9D%A1%E6%97%A9%E8%B5%B7%E8%BA%AB%E4%BD%93%E5%A5%BD/</url>
      
        <content type="html"><![CDATA[<p>今天早晨，上完厕所后称体重，刚好70KG整。</p><p>想想，我已经持续每周锻炼三次有快一年了吧。之前65KG左右的时候是看得到腹肌的，现在已经练的九九归一了。按照我对自己的期待值，我觉得我目前的体重已经不需要再增加了，接下来应该要减脂了。所以我决定把自己的生活习惯更改一下。</p><p>之后的日子里，我要强制自己晚上11:00之前开始躺在床上睡觉，这表示我要结束我五年多每天12:00以后才睡觉的习惯，所以其中艰辛是可以预料到的。但是说到这里，我想我的强迫症会在一定程度上帮助我完成这个任务，当然不是说要11:00就要睡着，这是不可能的，躺着去睡觉就行了。</p><p>由于今天锻炼的原因，所以现在写这篇博客的时候已经快要11点了，计划从今天开始，所以原本每天学习英语的计划就无法执行了(还有点小开心呢!)，这也是在所难免的,谁让我“说到做到”呢！</p><p>接下来的目标，就是体重往65KG靠拢，让我的腹肌不再被脂肪掩盖，当我到时候能明显看到轮廓的时候，就可以开始新的增肌计划了。</p><p>不多说了，准备睡觉吧！好梦…</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开始新的一天吧</title>
      <link href="undefined2019/09/01/%E5%BC%80%E5%A7%8B%E6%96%B0%E7%9A%84%E4%B8%80%E5%A4%A9%E5%90%A7/"/>
      <url>2019/09/01/%E5%BC%80%E5%A7%8B%E6%96%B0%E7%9A%84%E4%B8%80%E5%A4%A9%E5%90%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="好久不见"><a href="#好久不见" class="headerlink" title="好久不见"></a>好久不见</h1><p>几个月没有写个人博客了，这次和之前有许多的不同。</p><p>博客的主题被我从 <code><strong>nexT</strong></code> 换成了  <code><strong>Material-T</strong></code> ,并不是因为 <code><strong>nexT</strong></code> 不够好看，恰恰是因为它太简洁出色，用的人实在太多了，所以为了保证一定的“个性”，我选择更换掉主题。正好，现在的主题也是我非常喜欢的。</p><a id="more"></a> <h1 id="过的好吗"><a href="#过的好吗" class="headerlink" title="过的好吗"></a>过的好吗</h1><p>没有写个人博客的这段时间里，我是有所改变的。</p><p>来到了新的公司，接触了许多非常棒的新同事。也许技术上目前公司没有能够提供太多帮助，但是在程序规范、其他软技能等方面，我的提升是非常明显的。</p><p>这段时间，我花了大概一个多月，牺牲掉个人的下班时间与双休日，总算是完成了一由个Flutter编写的开源app。开源后的一个月，github上的star数从0涨到600多，期间我总是时不时的打开github，像是在开奖一样，紧张又期待的看着star的数量是不是又有所增长。时而失望，时而惊喜。</p><p>然后我逐渐开始讨厌自己这样的状态，因为这太耗费我的精力了，好在之后star数到了500，而我也终于放下了，因为我的目标算是达到了。</p><h1 id="有何打算"><a href="#有何打算" class="headerlink" title="有何打算"></a>有何打算</h1><p>最近公司搬到了一个新的地方，环境有了极大的改善，再也不用承受拥挤的座位了，并且我也可以骑着放置了三个月的自行车去上班，时间上稳定了不少，也减少了不少。</p><p>不过因为公司架构组织的调整，我也不清楚下一步会发生什么。但是不论接下来会有何动作，我都能够以轻松的态度去面对，也算是没有任何后顾之忧吧。</p><p>在技术上，还是一如既往的保持不断学习，之前是往广度上学，之后应该会在深度上再多费些心思。</p><p>接下来，这个博客就不准备再写技术性的文章了，而是写一些心情类的、生活类的文章。技术文章我会全部放在掘金上，而这个博客，就作为真真正正的个人博客吧，不以服务大众为目的，而是服务自己。</p><h1 id="下次再会"><a href="#下次再会" class="headerlink" title="下次再会"></a>下次再会</h1><p>这次的博客就写到这里了。我要开始过新的日子了！再会.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>骚年，你还没开始学Flutter吗？</title>
      <link href="undefined2019/05/04/%E9%AA%9A%E5%B9%B4%EF%BC%8C%E4%BD%A0%E8%BF%98%E6%B2%A1%E5%BC%80%E5%A7%8B%E5%AD%A6Flutter%E5%90%97%EF%BC%9F/"/>
      <url>2019/05/04/%E9%AA%9A%E5%B9%B4%EF%BC%8C%E4%BD%A0%E8%BF%98%E6%B2%A1%E5%BC%80%E5%A7%8B%E5%AD%A6Flutter%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="开场闲聊"><a href="#开场闲聊" class="headerlink" title="开场闲聊"></a>开场闲聊</h1><p>在去年12月份的Flutter Live 2018上，谷歌的Flutter团队宣布<strong>Flutter 1.0 release版</strong>正式发布。</p><p>想必很多小伙伴和我一样，都是从那个时候开始了解到Flutter的，而我也是顺带从那个时候入了Flutter的坑。</p><p>不过应该还有一部分小伙伴对Flutter只是略有耳闻，甚至闻所未闻。为了把这部分小伙伴拉到这个 <strong>“大坑”</strong> 里面来，我不得不在这里向你们展示<strong>Flutter的魅力</strong>所在，同时为了保持客观公正，我也会介绍一些我遇到过的<strong>Flutter的麻烦</strong>之处。<br>就像谈恋爱一样，因为优点才会在一起，也因为接受得了缺点才能使情感继续保持。</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/introduce_flutter/001.png" alt="image"></p><p>话不多说，接下来就由我来为诸位展示Flutter所具备的这些的特性吧。<br><a id="more"></a> </p><h1 id="Flutter的特性"><a href="#Flutter的特性" class="headerlink" title="Flutter的特性"></a>Flutter的特性</h1><p>在我看来，Flutter的特性主要分为两类，分别是<strong>高效性</strong>与<strong>舒适性</strong>，这两者都会是你在进行Flutter开发时最直观的感受，而下面的这些特性从侧面也会展示出这部分效果</p><h3 id="一、热重载"><a href="#一、热重载" class="headerlink" title="一、热重载"></a>一、热重载</h3><p>热重载大家应该都耳熟能详了，和前端开发一样，对代码进行修改后，可以即时看到效果，这点相比于原生开发每次做了一点修改就要从头到尾编译一次不知道高到哪里去了！</p><p>下面是一点简单的演示效果：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/introduce_flutter/002.gif" alt="image"></p><p>可以看到，热重载带来的体验提升是巨大的！作为一名原生开发者，你心动了吗？</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/introduce_flutter/003.gif" alt="image"></p><p>不过关于热重载还有一些需要说明的地方，在用到可以保存状态的控件时，热重载不能将状态重置，比如说一个动画控件，在动画结束后再进行热重载是无法再次播放动画的（除非你对动画做了循环处理），所以有的时候你看着觉得热重载没效果，这时候就要考虑是不是用到了 <strong>StatefulWidget</strong> 之类的控件。</p><p>Flutter将热重载作为一个亮点，不过由于Flutter的布局是用代码去写的，和Android中的xml不同，它无法进行实时预览，所以你无法想象没有热重载的话，要怎么面对Flutter进行编程，这么看来热重载既是亮点，也是要点。</p><h3 id="二、万物基于Widget"><a href="#二、万物基于Widget" class="headerlink" title="二、万物基于Widget"></a>二、万物基于Widget</h3><p>Flutter中的页面都是由一个个的Widget组合而成，甚至连页面本身也是一个Widget，Widget与android中的组件类似，不过前者具有更好的组合性。<br>同时Flutter已经封装了许多简单好用的Widget，使用起来非常方便。</p><p>比如在android中你想创建下面这样一个圆，你需要重新写一个xml，并在xml定义各种属性：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/introduce_flutter/004.png" alt="image"></p><p>而在Flutter中实现是非常容易的：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/introduce_flutter/005.png" alt="image"></p><p>不管是圆形，还是圆角矩形，又或者是不对称圆角矩形，Flutter都提供了很方便的实现方法。</p><p>关于Widget可以看到代码的结构是一层一层的，对于初次接触的人来说想必是很难接受这种代码格式。因为我当初看到Flutter这样的代码时，还产生过劝退的想法，不过写了一段时间后还是觉得蛮带感的。打个比方的话就像初见JoJo和再见JoJo的感觉。</p><p>在android中视图在xml中，代码则由java负责，在习惯了flutter后，我觉得用代码直接去创建视图也未尝不是一种好的解决方法，毕竟xml+java也算历史悠久了。而我也接触过一个前端框架——Vue，flutter的这种结构和vue的就非常类似。</p><p>孰好孰坏因人而异，想必等你使用过一段时间后的flutter后心中会有着一个自己的答案。</p><h3 id="三、跨平台"><a href="#三、跨平台" class="headerlink" title="三、跨平台"></a>三、跨平台</h3><p>跨平台其实是flutter最突出的一个特点了，与其他如React、Week这类跨平台框架不同，Flutter作为后起之秀能脱颖而出与其性能表现和稳点程度是有很大关系的。</p><p>在Flutter Live 2018上，官方已经放出了好几个纯Flutter的应用，并演示了他们在android和ios上的运行效果，其中最为惊艳的就是 <strong>《The History Of Everything》</strong> 了，下面给大家简单的展示一下真机运行效果：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/introduce_flutter/007.gif" alt="image"></p><p>想自行体验的话可以去Google Play或者App Store中下载</p><p>上面应用中的动画大部分由 <strong>Flare</strong> 实现，具体可以参见 <a href="https://www.2dimensions.com/" target="_blank" rel="noopener">2dimensions(需科学上网)</a>，这样可以跑满60帧的矢量动画也只是Flutter性能展现的一面，在跨平台上，其最大的特点就是<strong>接近原生效果</strong>。</p><p>不过目前而言，flutter在跨平台上有一些问题还是需要完善的。比如视频的播放<br>具体原因可以看这篇文章：<a href="https://www.yuque.com/xytech/flutter/pfpo68" target="_blank" rel="noopener">万万没想到——flutter这样外接纹理</a></p><p>还有那些需要用到第三方sdk的时候，可能就需要做双端的channel通信了，但是也有比较积极的团队专门做了flutter的sdk，<strong>声网</strong>就是其中之一</p><h3 id="四、年轻"><a href="#四、年轻" class="headerlink" title="四、年轻"></a>四、年轻</h3><p>年轻是flutter的一大优势，同时也是一大劣势。</p><p>就像上面说的，许多第三方sdk还没有开始为flutter做适配，所以flutter的开发生态自然比不了其他技术框架和平台，然而因其发展的势头非常迅猛，所以这其实也是一个机会。大量的开发者可以在这个领域再做建树，未来会是何种状况还是非常令人期待的。</p><p>如同 <strong>Kotlin</strong> 一样，现阶段如果去看国外的一些技术博客，如 <strong>Medium</strong> 里关于 Android 的，大部分语言都已经是kotlin的了，只是国内的博客可能普及度还没有那么高。但是良禽择木而栖，趋势一直都在，怎么选择就看个人了。</p><p>也正是因为flutter比较年轻，所以有些东西还没有一个既定的公认的解决方案。就比如flutter开发过程中都会遇到的 <strong>状态管理</strong>。</p><p>目前flutter中的状态管理框架有许多，最知名的比如从前端引鉴过来的 <strong>Redux</strong>，同时还有 <strong>Bloc</strong>， <strong>Provide</strong> 等。每个状态管理框架解决的范围都不一样，学习成本也各有差异，如何选择还是需要看项目需求与个人喜好。<br>具体选择可以看这篇文章：<a href="https://juejin.im/post/5bac54c45188255c681589d3" target="_blank" rel="noopener">（译）让我来帮你理解和选择Flutter状态管理方案</a></p><h3 id="五、Dart语言"><a href="#五、Dart语言" class="headerlink" title="五、Dart语言"></a>五、Dart语言</h3><p>flutter的开发语言使用的是dart，对于刚接触kotlin的同学来说，再去使用dart想必是一件很苦恼的事情。</p><p>比如kotlin中用 <strong>var表示变量(variable)</strong>，<strong>val表示常量(value)</strong>，而到了dart中虽然可以用var表示变量，但是常量还是只能用final或者const去修饰。</p><p>从很多方面看来kotlin都算是算是采各家所长集于一身，而dart则像是修行还没结束就半路出山了。</p><p>不过因为对比对象是kotlin，所以dart显得不那么出色，其实dart还是有很多好用的点的。</p><p>比如</p><h4 id="调用前做对象判空："><a href="#调用前做对象判空：" class="headerlink" title="调用前做对象判空："></a>调用前做对象判空：</h4><pre><code>//kotlina?.m()//darta?.m()</code></pre><p>不同之处在于kotlin如果对象为空则不做处理,同时要求你做对象为空时的赋值，dart如果对象为空则返回null,</p><h4 id="对象为空时赋值"><a href="#对象为空时赋值" class="headerlink" title="对象为空时赋值"></a>对象为空时赋值</h4><pre><code>//kotlinvar x = a?.b ?: c//dartvar x = a?.b ?? c</code></pre><p>两者区别不大.不过dart中还可以使用 ??= 代替?? ,区别是前者可以单独作为赋值语句</p><p>dart虽然在使用上不及kotlin那么舒适，但dart也一直在更新换代，优秀的语言发展到最后一定是有很多共同性的，所以不要过于纠结于语言的选择上，因为它终究只是一种工具。</p><h1 id="结束闲聊"><a href="#结束闲聊" class="headerlink" title="结束闲聊"></a>结束闲聊</h1><p>从去年12月flutter发布1.0 release版本到今天，flutter已经迭代了好多个版本了</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/introduce_flutter/008.png" alt="image"></p><p>而我在使用过程中确实遇到过一些问题，或简单或麻烦，但大部分都有了解决方案。从稳定性上来讲，使用flutter的交互其实就是对数据进行操作，而正是因为这样，做到了视图与数据分离，所以出bug的情况要少得多。</p><p>为什么我要介绍flutter甚至是鼓励各位原生开发者们去学flutter，主要原因有两个：</p><ul><li>一、学习flutter的成本很低，因为它难度不大</li><li>二、从flutter的性能表现上来看，它是可以代替原生应用的，只是现在火候不够</li></ul><p>所以对于现阶段的初中级原生开发者而言，我建议你一定要抽出时间去了解了解flutter，因为大部分你能通过原生去实现的东西，用flutter一样也是可以的，并且还更加轻松，还可以跨平台。</p><p>写到这里，文章中也很少涉及到技术上的东西，主要还是以介绍为主</p><p>下面再介绍一点点我非常推荐的学习flutter的途径吧：</p><p>1、 <strong>首先自然是Youtube上flutter官方的视频项目(科学上网)：<br><a href="https://www.youtube.com/channel/UCwXdFgeE9KYzlDdR7TG9cMw" target="_blank" rel="noopener">Flutter</a></strong></p><p>这里面有个超赞的系列，就是每周一更的 <strong>Flutter Widget of the Week</strong></p><p>2、<strong>然后你也可以关注B站的</strong> <strong><a href="https://space.bilibili.com/64169458/" target="_blank" rel="noopener">Google中国账号</a></strong></p><p>其中的视频都有中文翻译，可以找到关于flutter的学习视频，不过和youtube上相比更新要慢很多</p><p>3、<strong><a href="https://book.flutterchina.club/" target="_blank" rel="noopener">《Flutter实战》</a></strong></p><p>万分感谢这位作者开源这本技术书！</p><p>剩下的学习途径还有许多，不过学习也是发散的，知道上面三个后，其他的途径于你也不在话下了。</p><p>最后再介绍一个学习途径</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/apk/apk.png" alt="image"></p><p>没错，就是我用flutter写的一个小项目</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/introduce_flutter/009.jpg" alt="image"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter图文混排原生实现方案</title>
      <link href="undefined2019/04/19/Flutter%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"/>
      <url>2019/04/19/Flutter%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p>图文混排在移动端的实现方案主要有两大种，比如通过HTML去做一个WebView的富文本，或者通过原生的方式去实现。</p><p>使用WebView在性能上自然不及原生实现，同时开发者需要具备一定的前端知识，它最大的优势是跨平台;</p><p>出于性能的考虑，以及我对前端知识的了解程度，这里我只是介绍一下如何通过原生的方式去实现图文混排。<br><a id="more"></a> </p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>在手机上，你经常能看到这样的图文实现方式，比如贴吧的这种：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Flutter%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/001.png" width="600" height="300" div="" align="center"></p><p>点进去后是这样的展示：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Flutter%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/002.png" width="400" height="720" div="" align="center"></p><p>这种实现方式比较简单，算是文字与图片分开展示。不过既然我们要实现的是图文混排，那一定会稍稍复杂一点。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>下面是demo的效果：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Flutter%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/003.gif" alt="image"></p><p>从上面的demo可以看到，通过原生的图文混排实现了下面这些效果：</p><pre><code>1.单个图片的插入2.多个图片的插入3.插入图片时对文字进行切割4.删除图片时对文字进行合并</code></pre><p>其实看到这里，你应该能够看得出来一个大致的实现方法了，接下来我来介绍一下整个图文混排的结构。</p><p>由于是用Flutter实现，所以图文混排用的ListView，如果是android的话则可以使用RecyclerView(ios的话我不太了解所以就不说了)，因为实现图文混排主要是对数据的处理，所以平台的限制不大。</p><p><strong>既然是ListView，可以看得出来，ListView的内容全部是由Image与TextField组成，每当你插入一个Image的时候，同时会新増一个TextField，而这个TextField的内容则是上个TextField光标后的文字。</strong></p><p>既然知道了结构，那么下面来看一下是如何实现的吧。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>图文混排的主要逻辑在于两个：</p><pre><code>1.插入2.删除</code></pre><p>在进行操作之前，先定义一个抽象的结构，用于存储字符串数据，其实只是对MapEntry的一个简单修改：</p><pre><code>class TextEntry&lt;K, V&gt; {  K key;  V value;  factory TextEntry(K key, V value) = TextEntry&lt;K, V&gt;._;  TextEntry._(this.key, this.value);  String toString() =&gt; &quot;TextEntry($key: $value)&quot;;}</code></pre><p>然后来看一下插入的实现：</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><pre><code>class RichTextList&lt;T&gt;{  List&lt;TextEntry&lt;T, String&gt;&gt; _list = [];  void insertOne(int currentPosition, String beforeText, String selectText,      String afterText, T t) {    _list[currentPosition].value = beforeText;    _list.insert(currentPosition + 1, TextEntry(t, &quot;&quot;));    _list.insert(currentPosition + 2, new TextEntry(null, afterText));  }}</code></pre><p>传递的参数中各个的意义如下：</p><ul><li>currentPosition：当前TextField所在的位置</li><li>beforeText：当前TextField中光标前的文字</li><li>selectText：当前TextField中选中的文字，在这里没有进行处理</li><li>afterText：当前TextField中光标后的文字</li><li>t：你传入的泛型参数</li></ul><p>可以看到，每插入一个数据，还会自动插入一个value为null的TextEntry，而这个Entry则是文字的内容：</p><pre><code>_list.insert(currentPosition + 2, new TextEntry(null, afterText));</code></pre><p>所以图文混排的关键在于有一个统一的数据结构，后续如果想对这个数据结构进行转换也可以依据这个来，value为空的TextEntry表示文字，其他的则是你传入的泛型参数。</p><p>下面是插入多条的代码：</p><pre><code>  void insert(int currentPosition, String beforeText, String selectText, String afterText, List&lt;T&gt; list){    _list[currentPosition].value = beforeText;    for(int i = 0; i &lt; list.length; i++){      _list.insert(currentPosition + 2*i + 1, TextEntry(list[i], &quot;&quot;));      _list.insert(currentPosition + 2*i + 2, new TextEntry(null, i == list.length - 1?afterText:&quot;&quot;));    }  }</code></pre><p>当然，你可以用插入多个的替代上面插入单个的。</p><p>然后就是删除的逻辑了：</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除也非常简单：</p><pre><code>  void remove(int currentPosition) {      String afterText = _list[currentPosition + 1].value;      _list[currentPosition - 1].value += afterText;      _list.removeAt(currentPosition + 1);      _list.removeAt(currentPosition);  }</code></pre><p>删除的主要逻辑在于把下一个TextField中的内容补在上一个TextField中</p><p>核心的逻辑大概就是这样。</p><p>其中有点不方便的就是可能会与你的数据结构不太相同，所以转换的工作需要自己另外实现，当然如果你不想使用抽象的结构也可以自己自定义一种，比如说下面这种：</p><pre><code>class CustomTypeList{  TypeFlag flag;//默认为文字——0：文字，1：图片，2：视频，3：音乐  var imageUrl;  CustomTypeList({this.flag = TypeFlag.text, this.imageUrl = &quot;&quot;});}enum TypeFlag{  text,  image,  video,  music}</code></pre><p>实际使用中可以把枚举类型替换成int值，这样配合后端更佳。</p><p><strong>通过ListView实现图文混排最大的一个优势在于你可以将文字与任何类型的布局混合在一起，可以是图片，可以是视频，也可以是音乐！</strong></p><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>这篇文章没有把全部的代码贴出来，我已经把demo放在仓库里了，小伙伴们有意向可以去下载查看。</p><p><a href="https://github.com/asjqkkkk/TextPicList" target="_blank" rel="noopener"><strong>项目地址</strong></a></p><p>最后的最后，为我用纯Flutter写的一个测试项目打个小广告：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/apk/apk.png" alt="image"></p><p>如果你对于上面图文混排最后的效果不是特别满意，也可以到上面的app(android版)里面瞧一下,有做过特殊处理哦！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂谈-gun&amp;legal</title>
      <link href="undefined2019/04/16/%E6%9D%82%E8%B0%88-gun-legal/"/>
      <url>2019/04/16/%E6%9D%82%E8%B0%88-gun-legal/</url>
      
        <content type="html"><![CDATA[<h1 id="sequence"><a href="#sequence" class="headerlink" title="sequence"></a>sequence</h1><p>好久都没有写博客了，久到我几乎要忘了markdown的写作格式。</p><p>当初给自己的目标是每个月至少一篇技术博客，如今看来这个目标因为种种原因而被搁置，好在我每周锻炼三次的习惯一直持续了半年之久。</p><a id="more"></a> <p>停写博客的这段时间，我又学了许多新的东西，我的技术旅途上也多了一个新的伙伴——Flutter,相较于原来的Android而言，我实在是太喜欢Flutter了，从这种喜新厌旧的表现上来看，也许我是一个渣男吧？<br><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E6%9D%82%E8%B0%88/001.jpg" alt="image"></p><h1 id="leave"><a href="#leave" class="headerlink" title="leave"></a>leave</h1><p>这一个月里，我经历了离职、(因为离职)请朋友吃饭、面试、朋友(后脚离职)请我们吃饭等各种事情。</p><p>关于这群朋友，我感触颇深，和他们在公司的这段日子里我成长了不少，而我特别感谢的就是他们曾经热情地带领一个刚毕业的大学生融入了公司的环境，不然以那个涉世未深且又颇为内向的大学生的能力，想要达到这种效果可得费好大一番功夫。</p><p>也是因为这群朋友，我比以前优秀了！</p><p>在这里再次默默祝你们——前程似锦，万事可期！</p><h1 id="recent"><a href="#recent" class="headerlink" title="recent"></a>recent</h1><p>上周，面试了整整一个星期，除了周一外，每天两场面试。最赶一次，上午面试完回家刚吃完饭，就要开始下一家的面试，而下一家光是往返就花了我近五个小时。这样的奔波劳碌，直接导致我这周不想再去投递简历，除了上周约了今天下午的面试，这周我再没投过简历。</p><p>我打算休息一下。</p><p>写博客对我而言是一种爱好，也是休息方式之一。不过写这篇博客的主要目的还是想写下我心中的一个想法，一个早已根植心底的想法。</p><h1 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h1><p>这个想法，很久之前就有过了，只是最近社会上又发生的一些事情，导致我的想法更加清晰、具象。</p><p>这段日子里，发生了好多人尽皆知的社会新闻，比如：</p><p><a href="https://news.163.com/19/0414/20/ECOGCK760001899O.html" target="_blank" rel="noopener">【女车主称被迫交纳1.5万金融服务费 奔驰发声明回应】</a></p><p><a href="https://news.163.com/19/0413/04/ECK70O1L0001899N.html" target="_blank" rel="noopener">【一张图赔2万!视觉中国年赚3亿背后每天15.6起官司】</a></p><p>以及和我们程序员相关的996事件：</p><p><a href="https://github.com/996icu/996.ICU/blob/master/README_CN.md" target="_blank" rel="noopener">【996.ICU】</a></p><p><a href="https://tech.163.com/19/0412/18/ECJ6M1PE00097U7R.html" target="_blank" rel="noopener">【刘强东朋友圈回应996：”混日子的人不是我的兄弟”】</a></p><p><a href="https://news.163.com/19/0412/18/ECJ56LP00001875P.html" target="_blank" rel="noopener">【马云谈”996”:能做是一种巨大福气 很多人都没机会】</a></p><p>在我看来，这些新闻都说明了一个问题：我们离“<strong>法制社会</strong>”还有着很长一段距离！</p><p>而我的想法，就是和这相关的。</p><h1 id="idea-origin"><a href="#idea-origin" class="headerlink" title="idea_origin"></a>idea_origin</h1><p>在正式说明这个想法之前，我还是想写一下我是怎么产生这样的想法的。</p><p><strong>大概是有过一段中二且愤世嫉俗的时期吧。</strong></p><p>当时经常看到XXX村的干部又对XXX村民做了强取豪夺之事这类的新闻,比如这样：</p><p><a href="https://news.163.com/19/0415/11/ECQ4K3SH0001899O.html" target="_blank" rel="noopener">【村支书因货车刮到遮阳棚将司机打死 之后继续打牌】</a></p><p>又或者这样：</p><p><a href="http://money.163.com/18/0927/11/DSN633T4002580T4.html" target="_blank" rel="noopener">【”劫后”谭秦东称今生绝不入蒙 曾吐槽鸿茅药酒被抓】</a></p><p>那时我是这么想的：</p><pre><code>如果这种事情发生在美国，会是这样的结果吗？不会，美国人的持枪率导致他们的自卫能力远远强于其他国家没有武器的人们。</code></pre><p>现在看来，当初的想法过于简单粗暴，因为它会造成许多新的问题，在不持有枪支的情况下，你都能看到类似下面这样的新闻：</p><p><a href="http://news.163.com/19/0221/10/E8HJIL0B0001899O.html" target="_blank" rel="noopener">【江西一男子在校门口持刀伤人 砍伤学生辅警等11人】</a></p><p>而如果全民持枪的话，不知道又会出现多少起类似美国的枪支伤人事件。这个想法除了简单粗暴以外，还有一点就是天方夜谭，除了小说里面，现实是不可能出现全民持枪的情况的，永远都不会。</p><h1 id="idea-transform"><a href="#idea-transform" class="headerlink" title="idea_transform"></a>idea_transform</h1><p>如果有可以替代枪支用于自卫的武器，那么它一定是 <strong>法律</strong> 。</p><p>同时，法律公正、具备执行力、不带有任何情感，相较于枪支而言，它安全的多。</p><p>不过就如同我之前所说，真正意义上的 <strong>法制社会</strong> 我们还是难以企及。脱离了现实基础去谈论法律的使用无异于建造一所空中楼阁。</p><p>目前的法律显然不具备这些特点：普及性、易用性、服务性。</p><p>普通人想去使用法律，成本与难度还是很高的，就连我这种把技术作为代号的程序员，对法律也是一窍不通。</p><p>所以写到这里，我就要说出我真实的想法了。</p><h1 id="I-have-an-idea"><a href="#I-have-an-idea" class="headerlink" title="I have an idea"></a>I have an idea</h1><p><strong>我希望未来有一家公司，可以实现让人们低成本、便捷的去使用法律</strong></p><p>对，不是一家机构，是一个公司。就像阿里巴巴一样，本来应该交给银行去做的无现金社会，最后还需要靠马云去实现。而真正的无障碍使用法律的实现，也许只能由非官方非机构的某家公司去做。</p><p>我希望未来不管是谁，一定要出现一家这样的公司，实现这样的目的。</p><p>虽然我很想亲自去做这件事，但是目前而言我没有这个胆量，也没有这么坚定的信念，不过目前关于公司的一些构想，已经在我脑海里有了初步的雏形。</p><h1 id="idea-blueprint"><a href="#idea-blueprint" class="headerlink" title="idea blueprint"></a>idea blueprint</h1><!--公司的终极目的：实现 **法治社会** --><!--公司的主要目的：普及法律知识、降低法律使用成本、提高法律作为武器与防具的力量--><p>下面是我脑海中一个模糊的结构：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E6%9D%82%E8%B0%88/002.png" alt="image"></p><p>项目的名字就叫 <strong>民律</strong></p><p>虽然我不知道这样对不对，但是我希望未来我或者其他人可以去完成这个事业。</p><p>而我对于它的发展与结局是这样看待的，最理想的情况就是：生于乱世，匿于盛世。</p><p>当真正处于 <strong>法治社会</strong> 的时候，这样的产品自然也就销声匿迹了，这也是我乐于见到的场景。</p><p><strong>那么，我心中的想法就此写下，以后我睡觉的时候再不用去花时间考虑这个问题了  :D</strong></p><h1 id="about-996"><a href="#about-996" class="headerlink" title="about 996"></a>about 996</h1><p>最后，关于996谈一下我的看法。</p><p>本来马云在我心中是99分的第一类钦佩的存在，现在因为他的996言论，他只有95分了，第一类目前还有雷军、任正非，都是99分。</p><p>关于996这个问题，我觉得它一定是不适合技术人员的，特别是程序员这个种族。</p><p>因为技术人员的技术是会随着自身的积累慢慢增加的，技术越高的人会越讨厌毫无意义的重复性劳动，也会越追崇高效率的工作，同时他们思考的质量也会逐渐上升。</p><p>拿我自身的经历来说，如果让我全神贯注去敲代码，四个小时后我就会宕机，之后再进行这样高强度的脑力活动，我的效率会大幅度下降，并且工作积极性也会因为脑力下降而跌落。这时候加班反而不能起到正面促进的效果，只是把人带入了一个恶循环当中。</p><p>虽然我不提倡996，但是就像人有三急一样，有的时候项目确实会出现很赶的情况，这时候适当的加班也是没问题的。但我理想的情况应该是这样：项目规划的好，任务安排合理，基本上用不着加班，每天在工作时限内就可以很好的完成任务。如果需要加班，一定不能是长期的，并且加班需要有加班费，而这个加班费，我希望永远不会有拿的机会。</p><p>那关于996就是这样了，人们工作是为了更好的生活，就像人们健身也是为了生活而服务的。现在许多人因为健身耽误了正常的生活状态，反而是本末倒置，就像现在的996一样，得不偿失。</p><p>最后，关于我之前的想法，如果有朝一日我能实现这个想法，我一定推己及人，从自身的行业开始，让955成为常态，如果影响力够大的话，甚至是可以去实行10，5，5的。然而这也只是实现想法后的冰山一角，能改善的东西，还有更多！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Studio自定义模板实现一键创建MVP结构</title>
      <link href="undefined2018/12/02/Android-Studio%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/"/>
      <url>2018/12/02/Android-Studio%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前有写过关于如何使用 DataBinding 的两篇文章，不仅仅是为了消灭掉一部分重复代码，更是为了提高开发效率。详情可以点击下方的传送门<br><a href="https://oldchen.top/2018/10/17/DataBinding%E2%80%94%E2%80%94%E4%BB%8E%E8%B7%AF%E4%BA%BA%E5%88%B0%E5%A5%BD%E5%8F%8B%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%88%9D%E9%81%87/" target="_blank" rel="noopener">DataBinding——从路人到好友（一）：初遇</a><br><a href="https://oldchen.top/2018/10/20/DataBinding%E2%80%94%E2%80%94%E4%BB%8E%E7%9B%B8%E8%AF%86%E5%88%B0%E7%9B%B8%E7%9F%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BA%92%E9%85%8C/" target="_blank" rel="noopener">DataBinding——从相识到相知（二）：互酌</a></p><a id="more"></a> <p>而这篇文章主要介绍的就是如何通过 Android Studio 提供的模版功能去自定义模版结构，从而实现类似于一键创建整个MVP代码的功能。可以说在提高效率的道路上，又向前走了一大步<br><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/001.jpg" alt="image"></p><p>下面可以来看一看具体效果：<br><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/002.gif" alt="image"></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>在 Android Studio 中，创建一个 Activity 可以直接通过 <strong>File -&gt; New -&gt; Activity</strong> 来进行选择创建</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/003.png" alt="image"></p><p>通过这种方式创建的 Activity 会自动在 AndroidManifest.xml 中完成注册，创建其他组件也可以通过这种方式。</p><p>不过，如果你正在使用某种开发模式，譬如 <strong>MVP、MVVM</strong> 等，你每创建一个 Activity 就意味着需要同时创建一系列其他相关的类。</p><p>为了避免这种毫无意义的重复性劳动，我们可以编写模板代码去实现一键创建重复代码。</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>下面我们就来开始模版的编写吧。</p><p>首先，找到你的 <strong>Android Studio</strong> 的安装目录，然后根据这个目录找到 <strong>…\templates</strong> 目录：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/004.png" alt="image"></p><p>然后进入 <strong>activityes</strong> 目录，我们将要编写的各种模版就在这个目录内：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/005.png" alt="image"></p><p>要说如何去编写模版代码，一开始我也是一无所知的，不过好在 Android Studio 已经为我们提供了这些例子，我们直接参考例子去写。</p><p>就拿最简单的 <strong>Empty Activity</strong> 来开始吧</p><p>进入到 <strong>EmptyActivity</strong> 目录</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/006.png" alt="image"></p><h2 id="globals-xml-ftl"><a href="#globals-xml-ftl" class="headerlink" title="globals.xml.ftl"></a>globals.xml.ftl</h2><p>打开 <strong>globals.xml.ftl</strong> 文件，下面是它的内容：</p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;&lt;globals&gt;    &lt;global id=&quot;hasNoActionBar&quot; type=&quot;boolean&quot; value=&quot;false&quot; /&gt;    &lt;global id=&quot;parentActivityClass&quot; value=&quot;&quot; /&gt;    &lt;global id=&quot;simpleLayoutName&quot; value=&quot;${layoutName}&quot; /&gt;    &lt;global id=&quot;excludeMenu&quot; type=&quot;boolean&quot; value=&quot;true&quot; /&gt;    &lt;global id=&quot;generateActivityTitle&quot; type=&quot;boolean&quot; value=&quot;false&quot; /&gt;    &lt;#include &quot;../common/common_globals.xml.ftl&quot; /&gt;&lt;/globals&gt;</code></pre><p>根据文件名来看， <strong>globals.xml.ftl</strong> 的作用是用来控制一些全局变量，比如是否显示 <strong>ActionBar</strong> 等，暂且先不用管它</p><h2 id="recipe-xml-ftl"><a href="#recipe-xml-ftl" class="headerlink" title="recipe.xml.ftl"></a>recipe.xml.ftl</h2><p> <strong>recipe.xml.ftl</strong> 文件内容如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;&lt;#import &quot;root://activities/common/kotlin_macros.ftl&quot; as kt&gt;&lt;recipe&gt;    &lt;#include &quot;../common/recipe_manifest.xml.ftl&quot; /&gt;    &lt;@kt.addAllKotlinDependencies /&gt;&lt;#if generateLayout&gt;    &lt;#include &quot;../common/recipe_simple.xml.ftl&quot; /&gt;    &lt;open file=&quot;${escapeXmlAttribute(resOut)}/layout/${layoutName}.xml&quot; /&gt;&lt;/#if&gt;    &lt;instantiate from=&quot;root/src/app_package/SimpleActivity.${ktOrJavaExt}.ftl&quot;                   to=&quot;${escapeXmlAttribute(srcOut)}/${activityClass}.${ktOrJavaExt}&quot; /&gt;    &lt;open file=&quot;${escapeXmlAttribute(srcOut)}/${activityClass}.${ktOrJavaExt}&quot; /&gt;&lt;/recipe&gt;</code></pre><p>第一段</p><pre><code>    &lt;#import &quot;root://activities/common/kotlin_macros.ftl&quot; as kt&gt;</code></pre><p>就是用于导入Kotlin的相关命令，同时它的别名为 <strong>kt</strong></p><p>主要还是注意 <strong>instantiate</strong> 代码块中的相关信息， 其中 <strong>${ktOrJavaExt}</strong> 表示当你创建模版的时候，创建的 <strong>.java</strong> 文件还是 <strong>.kt</strong> 文件，而相对应的，你需要在编写模版例子的时候分别写上对应的两份 <strong>Java</strong> 与 <strong>Kotlin</strong> 代码</p><p><strong>open</strong> 代码块就是创建模版后，默认打开的文件</p><h1 id="template-xml"><a href="#template-xml" class="headerlink" title="template.xml"></a>template.xml</h1><p><strong>template.xml</strong> 代码略长，这里只是贴出了大致代码</p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;&lt;template    format=&quot;5&quot;    revision=&quot;5&quot;    name=&quot;Empty Activity&quot;    minApi=&quot;9&quot;    minBuildApi=&quot;14&quot;    description=&quot;Creates a new empty activity&quot;&gt;    &lt;category value=&quot;Activity&quot; /&gt;    &lt;formfactor value=&quot;Mobile&quot; /&gt;    &lt;parameter        id=&quot;activityClass&quot;        name=&quot;Activity Name&quot;        type=&quot;string&quot;        constraints=&quot;class|unique|nonempty&quot;        suggest=&quot;${layoutToActivity(layoutName)}&quot;        default=&quot;MainActivity&quot;        help=&quot;The name of the activity class to create&quot; /&gt;        ...    &lt;!-- 128x128 thumbnails relative to template.xml --&gt;    &lt;thumbs&gt;        &lt;!-- default thumbnail is required --&gt;        &lt;thumb&gt;template_blank_activity.png&lt;/thumb&gt;    &lt;/thumbs&gt;    &lt;globals file=&quot;globals.xml.ftl&quot; /&gt;    &lt;execute file=&quot;recipe.xml.ftl&quot; /&gt;&lt;/template&gt;</code></pre><p>我们挑出其中的重点来说</p><pre><code>&lt;category value=&quot;Activity&quot; /&gt;</code></pre><p>表示当前的这个模版的分类，当前的 <strong>Value</strong> 是 <strong>Activity</strong> ，就表示它会出现在 <strong>File -&gt; New -&gt; Activity</strong> 中，这个是可以自定义的.</p><pre><code>        &lt;thumbs&gt;        &lt;!-- default thumbnail is required --&gt;        &lt;thumb&gt;template_blank_activity.png&lt;/thumb&gt;        &lt;/thumbs&gt;</code></pre><p><strong>thumbs</strong> 用于指定创建模版时所展示出来的图片</p><p>而最重要的，还是 <strong>parameter</strong> 代码块的内容了，在这之中，我们只需要关注以下几个，其他的顾名思义即可。</p><pre><code>    &lt;parameter        id=&quot;activityClass&quot;        name=&quot;Activity Name&quot;        type=&quot;string&quot;        constraints=&quot;class|unique|nonempty&quot;        suggest=&quot;${layoutToActivity(layoutName)}&quot;        default=&quot;MainActivity&quot;        help=&quot;The name of the activity class to create&quot; /&gt;</code></pre><p><strong>activityClass</strong> 表示所要创建的 Activity ，其中 <strong>default</strong> 为默认名。</p><pre><code>    &lt;parameter        id=&quot;generateLayout&quot;        name=&quot;Generate Layout File&quot;        type=&quot;boolean&quot;        default=&quot;true&quot;        help=&quot;If true, a layout file will be generated&quot; /&gt;</code></pre><p>上面的代码块表示是否同时自动创建一个Activity对应的布局</p><pre><code>  &lt;parameter        id=&quot;layoutName&quot;        name=&quot;Layout Name&quot;        type=&quot;string&quot;        constraints=&quot;layout|unique|nonempty&quot;        suggest=&quot;${activityToLayout(activityClass)}&quot;        default=&quot;activity_main&quot;        visibility=&quot;generateLayout&quot;        help=&quot;The name of the layout to create for the activity&quot; /&gt;</code></pre><p> <strong>layoutName</strong> 则表示布局的名字，这里的 <strong>suggest</strong> 属性所填写的内容即为布局名，<strong>${activityToLayout(activityClass)}</strong>则为跟随Activity的名字，其中 <strong>activityClass</strong> 是Activity名字的引用</p><p> 剩下的不用再作说明，基本上可以见名知意。</p><h1 id="模版代码"><a href="#模版代码" class="headerlink" title="模版代码"></a>模版代码</h1><p>接下来我们从 <strong>EmptyActivity</strong> 中的 <strong>root</strong> 目录一直进入，直到看到下面两个文件</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/007.png" alt="image"></p><p>可以看到，一个后缀是 <strong>java.ftl</strong> 另外一个后缀是 <strong>kt.ftl</strong>，他们分别用于创建 Java模版与Kotlin模版，如果你暂时不使用Kotlin的话，可以不用去关心 Kotlin模版，当你完成了Java模版的编写，也可以使用 Android Studio自带的转换功能，还是蛮方便的。</p><p>下面来看一下Java的模版代码：</p><pre><code>package ${packageName};import ${superClassFqcn};import android.os.Bundle;&lt;#if (includeCppSupport!false) &amp;&amp; generateLayout&gt;import android.widget.TextView;&lt;/#if&gt;public class ${activityClass} extends ${superClass} {    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);&lt;#if generateLayout&gt;        setContentView(R.layout.${layoutName});       &lt;#include &quot;../../../../common/jni_code_usage.java.ftl&quot;&gt;&lt;#elseif includeCppSupport!false&gt;        // Example of a call to a native method        android.util.Log.d(&quot;${activityClass}&quot;, stringFromJNI());&lt;/#if&gt;    }&lt;#include &quot;../../../../common/jni_code_snippet.java.ftl&quot;&gt;}</code></pre><ul><li>${packageName}：表示当前包名</li><li>${activityClass}：表示当前的Activity名字</li><li>${superClass}：表示继承的Activity，同时为了让这个父类生效，需要在import中加入${superClassFqcn}</li><li>${layoutName}：当前Activity所对应的布局名</li></ul><p>目前我们只需要关注上面这部分，接下来可以看一下我们实际想要创建的MVP结构：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/008.png" alt="image"></p><p>编写模版代码前，最好的方式是先写一遍例子，然后对照例子去替换关键名部分，这样做是最轻松的。</p><p>下面就来看一看具体的实现吧：</p><h1 id="样例代码"><a href="#样例代码" class="headerlink" title="样例代码"></a>样例代码</h1><h2 id="接口部分：TestActivityContact"><a href="#接口部分：TestActivityContact" class="headerlink" title="接口部分：TestActivityContact"></a>接口部分：TestActivityContact</h2><pre><code>package com.example.testcustomtemplates.contact;public interface TestActivityContact {    interface Presenter&lt;T&gt; {        void succeed(T t);        void failed(T t);        void error(Throwable e);        void subscribe();        void unSubscribe();    }    interface View&lt;T&gt; {        void setPresenter(Presenter presenter);        void succeed(T t);        void failed(T t);        void error(Throwable e);    }    interface Model {        void setPresenter(Presenter presenter);    }}</code></pre><p>为了方便测试，这里并没有另外创建一些基类接口，可以看到上面代码中分别对应 MVP 结构中三个模块的接口，写的是最基本的需求方法，不过 MVP 也不都是完全一样的，这里你可以定义自己想写的方法。</p><h2 id="Model层：TestActivityModel"><a href="#Model层：TestActivityModel" class="headerlink" title="Model层：TestActivityModel"></a>Model层：TestActivityModel</h2><pre><code>package com.example.testcustomtemplates.model;import android.content.Context;import com.example.testcustomtemplates.contact.TestActivityContact;public class TestActivityModel implements TestActivityContact.Model {    private Context context;    private TestActivityContact.Presenter mPresenter;    public TestActivityModel(Context context) {        this.context = context;    }    @Override    public void setPresenter(TestActivityContact.Presenter presenter) {        this.mPresenter = presenter;    }}</code></pre><p>Model层主要就是做一些网络请求，存储之类的数据相关操作，不可以持有对View的引用，他是通过Presenter去和View进行交互的。</p><h2 id="Presenter层：TestActivityPresenter"><a href="#Presenter层：TestActivityPresenter" class="headerlink" title="Presenter层：TestActivityPresenter"></a>Presenter层：TestActivityPresenter</h2><pre><code>package com.example.testcustomtemplates.presenter;import android.content.Context;import com.example.testcustomtemplates.contact.TestActivityContact;import com.example.testcustomtemplates.model.TestActivityModel;public class TestActivityPresenter&lt;T&gt; implements TestActivityContact.Presenter&lt;T&gt; {    private TestActivityContact.View mView;    private TestActivityModel mModel;    private Context context;    public TestActivityPresenter(TestActivityContact.View mView, Context context) {        this.mView = mView;        this.context = context;        mModel = new TestActivityModel(context);    }    @Override    public void succeed(T t) {    }    @Override    public void failed(T t) {    }    @Override    public void error(Throwable e) {    }    @Override    public void subscribe() {    }    @Override    public void unSubscribe() {    }}</code></pre><p>Presenter层自然不必多说，他最好是不要持有View控件的引用，大部分的逻辑操作需要他来完成，不过不可避免的，如果业务逻辑复杂了，Presenter层也会变得臃肿，这也是MVP结构的一个短处。</p><h2 id="View层：TestActivity"><a href="#View层：TestActivity" class="headerlink" title="View层：TestActivity"></a>View层：TestActivity</h2><pre><code>package com.example.testcustomtemplates.activity;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import com.example.testcustomtemplates.R;import com.example.testcustomtemplates.contact.TestActivityContact;import com.example.testcustomtemplates.presenter.TestActivityPresenter;public class TestActivity&lt;T&gt; extends AppCompatActivity implements TestActivityContact.View&lt;T&gt; {    private TestActivityContact.Presenter mPresenter;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_test);        new TestActivityPresenter&lt;T&gt;(this, this);    }    @Override    public void setPresenter(TestActivityContact.Presenter presenter) {        this.mPresenter = presenter;    }    @Override    public void succeed(T t) {    }    @Override    public void failed(T t) {    }    @Override    public void error(Throwable e) {    }}</code></pre><p>Activity或者Fragment都可以用作View层，这层主要是对一些视图控件的状态进行切换，不做复杂的逻辑操作。</p><p>看完上面的这些代码后，其实就可以开始直接编写我们的模版代码了。</p><h1 id="模版编写"><a href="#模版编写" class="headerlink" title="模版编写"></a>模版编写</h1><p>首先，可以Copy一份 <strong>EmptyActivity</strong> 整个模版的文件，然后改一下名字，随便什么都可以，这里我将其改成 <strong>MvpDemoActivity</strong></p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/009.png" alt="image"></p><p>然后我们首先对 <strong>template.xml</strong> 文件进行修改，主要修改下面这个部分：</p><pre><code>&lt;category value=&quot;Activity&quot; /&gt;</code></pre><p>然后是对 <strong>recipe.xml.ftl</strong> 文件进行修改，修改后如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;&lt;#import &quot;root://activities/common/kotlin_macros.ftl&quot; as kt&gt;&lt;recipe&gt;    &lt;#include &quot;../common/recipe_manifest.xml.ftl&quot; /&gt;    &lt;@kt.addAllKotlinDependencies /&gt;&lt;#if generateLayout&gt;    &lt;#include &quot;../common/recipe_simple.xml.ftl&quot; /&gt;    &lt;open file=&quot;${escapeXmlAttribute(resOut)}/layout/${layoutName}.xml&quot; /&gt;&lt;/#if&gt;    &lt;!--View-activity--&gt;    &lt;instantiate from=&quot;root/src/app_package/MvpActivity.java.ftl&quot;                   to=&quot;${escapeXmlAttribute(srcOut)}/activity/${activityClass}.java&quot; /&gt;    &lt;!--Model--&gt;    &lt;instantiate from=&quot;root/src/app_package/MvpModel.java.ftl&quot;                   to=&quot;${escapeXmlAttribute(srcOut)}/model/${activityClass}Model.java&quot; /&gt;        &lt;!--Contact--&gt;    &lt;instantiate from=&quot;root/src/app_package/MvpContact.java.ftl&quot;                   to=&quot;${escapeXmlAttribute(srcOut)}/contact/${activityClass}Contact.java&quot; /&gt;    &lt;!--Presenter--&gt;    &lt;instantiate from=&quot;root/src/app_package/MvpPresenter.java.ftl&quot;                   to=&quot;${escapeXmlAttribute(srcOut)}/presenter/${activityClass}Presenter.java&quot; /&gt;           &lt;open file=&quot;${escapeXmlAttribute(srcOut)}/activity/${activityClass}.java&quot; /&gt;&lt;/recipe&gt;</code></pre><p>上面的代码表示只编写了Java版，当然你在修改这个文件之前还是需要创建相对应的几个类的模版代码的。这里出于篇幅考虑暂时就不贴出实际的模版代码了，下面会给出github地址，编写了Java版和Kotlin版的，大家可以拿去参考</p><p><a href="https://github.com/asjqkkkk/TemplatesTest" target="_blank" rel="noopener">Github项目链接</a></p><p>当然，有好的模版也可以一起分享一下</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/010.png" alt="image"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 模版代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Room Database入门指南</title>
      <link href="undefined2018/10/30/Room-Database%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
      <url>2018/10/30/Room-Database%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>说到Android端有哪些可以使用的数据库，大家首先想到的自然是SQLite这种带有官方属性加持的轻型的数据库。</p><p>不过对于像我这种基本上没有接触过SQL数据库语言编写的人来说，要通过去写难以查错且又毫不熟悉的数据库代码才能操作数据库的话，那就太令人头大了。</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/001-001.jpg" alt="image"></p><p>于是乎，便于Android开发者操作数据库的框架也就多了起来，其中人气较高的就有GreenDao、Realm，ObjectBox等，而Room则是谷歌官方十分推荐的，可以代替SQlite的不二之选。<br><a id="more"></a><br>本篇的主要介绍对象也是Room数据库，不过在此之前，还得简单介绍一下上面提到过的其他几位，同时做个小小的对比。</p><h1 id="一、介绍与比较"><a href="#一、介绍与比较" class="headerlink" title="一、介绍与比较"></a>一、介绍与比较</h1><p>由于我用过的数据库框架并不多，所以对于用过的可以说一下感受，没用过的就简单带过了。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="GreenDao-和-ObjectBox"><a href="#GreenDao-和-ObjectBox" class="headerlink" title="GreenDao 和 ObjectBox"></a>GreenDao 和 ObjectBox</h3><p>在这些数据库中， <strong>GreenDao</strong> 算是早闻其名，不过一直没有用过，后来它的作者又出了个 <strong>ObjectBox</strong> ，而且你可以在 <a href="https://github.com/greenrobot/greenDAO" target="_blank" rel="noopener"><strong>GreenDao</strong>的GitHub页面</a> 找到推荐使用 <strong>ObjectBox</strong> 的 <a href="https://objectbox.io/" target="_blank" rel="noopener">ObjectBox地址</a> .</p><h3 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h3><p>我真正使用过的还只有 <strong>Realm</strong> 数据库，这里要提一下，<strong>Realm</strong> 数据库对于中国的开发者非常的友好，就像大名鼎鼎的Glide一样， <strong>Realm</strong> 也有中文的介绍文档，文档地址在此：<br><a href="https://realm.io/cn/docs/java/latest/" target="_blank" rel="noopener">开始使用Realm</a><br>虽然这份文档对应的版本不是最新的. 不过对于初次接触 <strong>Realm</strong> 人来说，看这份文档就可以上手了</p><p>最开始使用Realm的时候也是碰过不少坑，不过最主要的是所有数据库对象需要继承 <strong>RealmObject</strong> 这个类(也可以通过接口实现)，这样对项目已有的数据结构不太友好，同时我还发现继承了 <strong>RealmObject</strong> 的对象并不能与 <strong>Gson</strong> 完美结合，如果需要转换的话，还是得费一番周折的。<br>种种原因，导致我最后从项目中抽去了Realm这个数据库.</p><h3 id="Room"><a href="#Room" class="headerlink" title="Room"></a>Room</h3><p>与 Realm 分手后的日子里，我并没有放弃对新的数据库的寻找，后来在浏览 Google官方文档的时候才发现了 <strong>Room</strong> 这个新的数据库，经过我一番使用后，就决定是它了！<br><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/001-002.jpg" alt="image"></p><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>因为懒惰的原因，我并没有做过深入的测试，下面会给出从网上找到的关于这些数据库的对比，原文地址如下：</p><p><a href="https://notes.devlabs.bg/realm-objectbox-or-room-which-one-is-for-you-3a552234fd6e" target="_blank" rel="noopener"><strong>Realm, ObjectBox or Room. Which one is for you?</strong></a></p><p>然后是数据量达到 <strong>100k/10k</strong> 的时候，进行增删改查等操作消耗的时间对比：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/001.jpeg" alt="image"><br><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/002.jpeg" alt="image"></p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/003.jpeg" alt="image"><br><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/004.jpeg" alt="image"></p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/005.jpeg" alt="image"><br><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/006.jpeg" alt="image"></p><p>可以看到，在各个方面，统统都是 <strong>ObjectBox</strong> 傲视群雄。<br>那这篇文章为什么还是要写介绍关于 <strong>Room Database</strong> 呢？</p><p>首先是官方Buff加持，和介绍文档里的一句话：<br><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/007.png" alt="image"><br><a href="https://developer.android.google.cn/training/data-storage/room/" target="_blank" rel="noopener">这里是Room的官方介绍文档地址</a></p><p>大致意思就是：<strong>我们强烈建议你用Roon去代替SQLite，不过如果你是个铁头娃非得用SQLite，那我们也没有办法。</strong></p><p>除了上面这段话，还有一点也可以作为选择Room的原因，就是对于Apk的“增量”是多少。据别人的测试</p><blockquote><p>ObjectBox和Realm分别占用1-1.5MB和3-4MB（大小取决于手机架构），而作为SQL封装的Room只占用大约50KB。在方法的增量上，Room只有300多个，ObjectBox和Realm则分别是1300和2000个</p></blockquote><p>当然，如果你的数据量很大的话，我觉得还是 <strong>ObjectBox</strong> 更加适合你，因为就从上面的操作数据对比来看， <strong>ObjectBox</strong> 太牛逼了！我以后肯定也会花时间去对 <strong>ObjectBox</strong> 做一番研究，不过目前还是先来介绍介绍 <strong>Room</strong> 吧。</p><h1 id="二、Room的结构"><a href="#二、Room的结构" class="headerlink" title="二、Room的结构"></a>二、Room的结构</h1><p>之前有说过，<strong>Room</strong> 是可以代替 <strong>SQLite</strong> 的，不过我觉得Google推出它更多的是为了搭配 <strong>DataBinding</strong> 使用，如果你对于 <strong>DataBinding</strong> 不太熟悉，可以看一看我前面的关于 <strong>DataBinding</strong> 的文章，这里就不再赘述了。下面就开始说说 <strong>Room</strong> 的结构。</p><p>Room主要分为三个部分，分别是 <strong>Database</strong>(数据库) 、<strong>Entity</strong>(实体) 、<strong>DAO</strong>(数据访问对象) </p><h2 id="Database-数据库"><a href="#Database-数据库" class="headerlink" title="Database(数据库)"></a>Database(数据库)</h2><p>数据库指的就是一个数据库对象，它继承于 <strong>RoomDataBase</strong> 这个类，并且需要用 <strong>@DataBase</strong> 注解，获取这个数据库对象的方法是通过调用 <strong>Room.databaseBuilder()</strong> 或者 <strong>Room.inMemoryDatabaseBuilder()</strong> ，后者表示在内存中存储数据，如果程序结束了数据也就消失了，所以一般还是使用前者。</p><h2 id="Entity-实体"><a href="#Entity-实体" class="headerlink" title="Entity(实体)"></a>Entity(实体)</h2><p>实体的概念就比较简单了，就类似于MySQL数据库里面的表，一个实体类相当于一个表，而一个实体类有多个属性，就相当于表的多个字段，这个看一看接下来关于 <strong>Entity</strong> 的代码便一目了然。</p><h2 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h2><p>关于 <strong>DAO</strong> ，抽象的概念就表示<strong>数据访问对象</strong>，在这里简单的解释一下就是数据操作接口，可以通过编写 <strong>DAO接口</strong> 对数据库进行增删改查等一系列操作。  </p><blockquote><p>PS:这些接口可以支持RxJava的哦！</p></blockquote><p>下面是图片说明：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/009.png" alt="image"></p><h1 id="三、开始使用"><a href="#三、开始使用" class="headerlink" title="三、开始使用"></a>三、开始使用</h1><p>在 <strong>Room</strong> 的使用过程中，也是遇到一些坑的，不过都已经解决掉了。如果你也遇到过某些问题，不妨对照一下我的接入流程，说不定就找到了问题所在。</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/008.png" alt="image"></p><h2 id="接入Gradle"><a href="#接入Gradle" class="headerlink" title="接入Gradle"></a>接入Gradle</h2><p>为了避免之后的单元测试出现 <font color="#DC143C">java.lang.RuntimeException: Method e in android.util.Log not mocked. See <a href="http://g.co/androidstudio/not-mocked" target="_blank" rel="noopener">http://g.co/androidstudio/not-mocked</a> for details.</font> 的错误，除了 <strong>Room</strong> 相关的依赖需要添加外，这里还需要再引用一下 <strong>robolectric单元测试库</strong> 解决问题！</p><pre><code>    //room数据库    def room_version = &quot;1.1.1&quot;    implementation &quot;android.arch.persistence.room:runtime:$room_version&quot;    annotationProcessor &quot;android.arch.persistence.room:compiler:$room_version&quot;    kapt &quot;android.arch.persistence.room:compiler:$room_version&quot;      // 由于要使用Kotlin,这里使用了kapt    implementation &quot;android.arch.persistence.room:rxjava2:$room_version&quot;        //之后会用到rxjava，所以这里也可以有//    implementation &quot;android.arch.persistence.room:guava:$room_version&quot;        //由于我们不用guava，这行注释掉    testImplementation &quot;android.arch.persistence.room:testing:$room_version&quot;     //robolectric测试    testImplementation &#39;org.robolectric:shadows-multidex:3.8&#39;    testImplementation &quot;org.robolectric:robolectric:3.8&quot;    //这样就资瓷单元测试咯！</code></pre><p>和我一样使用Kotlin的童鞋别忘了下面这行：</p><pre><code>apply plugin: &#39;kotlin-kapt&#39;</code></pre><p>还有，需要做如下更改：</p><pre><code>    androidTestImplementation &#39;com.android.support.test:runner:1.0.2&#39;    //更改为    implementation &#39;com.android.support.test:runner:1.0.2&#39;</code></pre><p>这点一定要改哦！不然会出现一些莫名其妙的问题</p><p>相关库的依赖成功添加后就可以开始动手了！</p><h2 id="创建-Entity、Dao-与-DataBase"><a href="#创建-Entity、Dao-与-DataBase" class="headerlink" title="创建 Entity、Dao 与 DataBase"></a>创建 Entity、Dao 与 DataBase</h2><h3 id="创建Entity"><a href="#创建Entity" class="headerlink" title="创建Entity"></a>创建Entity</h3><p>首先，创建一个 <strong>Entity</strong> 对象，就把它命名为 <strong>Book</strong> 吧</p><pre><code>@Entityclass Book(@field:ColumnInfo(name = &quot;book_name&quot;)           var bookName: String?, var author: String?, var type: String?) {    @PrimaryKey(autoGenerate = true)    var id: Int = 0}</code></pre><p><strong>Book</strong> 有三个属性，分别表示书名、作者、类型。其中有三点需要注意：</p><ul><li>每个 <strong>Entity对象</strong> 都需要使用 <strong>@Entity</strong> 注释声明</li><li><strong>@PrimaryKey</strong> 注释用于声明主键，这里还添加了 autoGenerate = true，表示它是自增的</li><li><strong>@ColumnInfo</strong> 注释用来给属性设置别名，如果 <strong>bookName</strong> 属性不设置别名的话，查询的时候可以通过 “<strong>bookName</strong>”进行查询，设置别名后就可以通过设置的“<strong>book_name</strong>” 进行查询了，看 <strong>DAO接口</strong> 便知</li></ul><h3 id="创建-DAO"><a href="#创建-DAO" class="headerlink" title="创建 DAO"></a>创建 DAO</h3><p>这里，通过 <strong>DAO接口</strong> 来对 <strong>Book</strong> 这个对象进行增删改查：</p><pre><code>@Daointerface BookDao {    @get:Query(&quot;SELECT * FROM book&quot;)    val all: List&lt;Book&gt;    @Query(&quot;SELECT * FROM book WHERE author LIKE :author&quot;)    fun getBookByAuthor(author: String): List&lt;Book&gt;    @Query(&quot;SELECT * FROM book WHERE book_name LIKE :name&quot;)    fun getBookByNamer(name: String): List&lt;Book&gt;    @Insert    fun insert(book: Book): Long?    @Insert    fun insert(vararg books: Book): List&lt;Long&gt;    @Insert    fun insert(books: List&lt;Book&gt;): List&lt;Long&gt;    @Update    fun update(book: Book): Int    @Update    fun update(vararg books: Book): Int    @Update    fun update(books: List&lt;Book&gt;): Int    @Delete    fun delete(book: Book): Int    @Delete    fun delete(vararg books: Book): Int    @Delete    fun delete(books: List&lt;Book&gt;): Int}</code></pre><p>上面的 <strong>DAO接口</strong>，同样需要进行几点说明：</p><ul><li><strong>DAO接口</strong> 需要使用 <strong>@Dao</strong> 注释进行声明</li><li><strong>Insert</strong> 操作可以使用 <strong>Long</strong> 作为返回值的类型，表示插入操作前的对象数量</li><li><strong>Update</strong> 和 <strong>Delete</strong> 操作可以使用 Int 作为返回值，表示更新或者删除的行数</li><li>返回类型还可以是 <strong>void</strong> ，如果结合 <strong>Rxjava</strong> 使用的话还可以是 <strong>Completable、Single、 Maybe、Flowable</strong>等，具体可以参见这篇文章：<a href="https://medium.com/androiddevelopers/room-rxjava-acb0cd4f3757" target="_blank" rel="noopener">Room 🔗 RxJava</a>(需要备好梯子，不过后续有时间的话我也会介绍一下Room搭配Rxjava的使用)</li></ul><p><strong>Dao接口</strong> 编写完成后，还剩下最重要的 <strong>DataBase</strong></p><h3 id="创建-DataBase"><a href="#创建-DataBase" class="headerlink" title="创建 DataBase"></a>创建 DataBase</h3><blockquote><p>由于实例化一个 <strong>RoomDatabase</strong> 对象的开销是比较大的，所以 <strong>DataBase</strong> 的使用需要遵循单例模式，只在全局创建一个实例即可。</p></blockquote><p>这里为了方便理解，还是使用java代码去创建一个 <strong>BookDataBase类</strong>，当然，转换成Kotlin只需要Shift + Alt + Ctrl + K 即可</p><p>如果你使用的是饿汉式的单例模式，在Kotlin中通过object修饰可达到同样效果</p><pre><code>@Database(entities = {Book.class}, version = 1)public abstract class BookDataBase extends RoomDatabase {    public abstract BookDao bookDao();    private static BookDataBase instance;    public static BookDataBase getInstance(Context context){        if (instance == null){            synchronized (BookDataBase.class){                if (instance == null){                    instance = create(context);                }            }        }        return instance;    }    private static BookDataBase create(Context context) {        return Room.databaseBuilder( context,BookDataBase.class,&quot;book-db&quot;).allowMainThreadQueries().build();    }}</code></pre><p>上面的例子中有一些需要特别注意：</p><ul><li><strong>@Database</strong> 注释用于进行声明，同时还需要有相关的 <strong>entity对象</strong>，其中 <strong>version</strong> 是当前数据库的版本号，如果你对数据相关的<strong>实体类结构</strong>进行了更改，这里的 <strong>version</strong> 就需要<strong>加一</strong></li><li><strong>BookDataBase</strong> 除了继承于 <strong>RoomDatabase</strong> ，还需要实例出相关的 <strong>DAO接口</strong></li><li>create()方法中的”<strong>book-db</strong>“是数据库的名字，这里随意，不过需要注意的是 <strong>allowMainThreadQueries()</strong> 方法，这里由于我们会用到单元测试，所以加上这行代码是为了防止 【<em>Cannot access database on the main thread since it may potentially lock the UI for a long period of time.</em>】 的报错。正式使用时，请务必去掉这行代码，因为它会让所有耗时操作运行在主线程！</li></ul><p>到这里，我们就可以先愉快的进行测试了.</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="初级测试"><a href="#初级测试" class="headerlink" title="初级测试"></a>初级测试</h3><p>找到 <strong>src</strong> 下的 <strong>test</strong> 目录，然后可以像我这样创建一个 <strong>RoomTest</strong> 类进行测试</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/010.png" alt="image"></p><p>说到这里，可能会有童鞋尚未了解过单元测试，这时候你可以先去看看相关博客，比如这篇</p><p><a href="https://juejin.im/post/5b57e3fbf265da0f47352618" target="_blank" rel="noopener">Android 单元测试只看这一篇就够了</a></p><p>不过这里使用的单元测试是 Android Studio 自带的，也没有用到太复杂的东西，同时我会做一些说明，不够了解的童鞋也可以继续往下看，看完你也就了解了</p><pre><code>@RunWith(AndroidJUnit4::class)class RoomTest {    private var bookDao: BookDao? = null    private var bookDataBase: BookDataBase? = null    @Before    @Throws(Exception::class)    fun setUp() {        ShadowLog.stream = System.out      //这样方便打印日志        val context = InstrumentationRegistry.getTargetContext()        bookDataBase = BookDataBase.getInstance(context)        bookDao = bookDataBase!!.bookDao()    }    @Test    fun insert() {        val book1 = Book(&quot;时间简史&quot;, &quot;斯蒂芬·威廉·霍金&quot;, &quot;科学&quot;)        val book2 = Book(&quot;百年孤独&quot;, &quot;西亚·马尔克斯&quot;, &quot;文学&quot;)        val list = bookDao!!.insert(book1, book2)        assert(list.size == 2)    }    @Test    fun query(){        val books = bookDao!!.all        for (book in books) {            Log.e(javaClass.name, &quot;获取的书籍数据: ${Gson().toJson(book)}&quot;)        }    }    @After    @Throws(Exception::class)    fun cloaseDb() {        bookDataBase?.close()    }}</code></pre><p>可以看到，这里的单元测试使用的是 <strong>AndroidJUnit4</strong>，通过 <strong>@Before</strong> 注释的方法，表示用于<strong>相关资源的初始化</strong>，类似于Activity的onCreate()方法；而通过 <strong>@After</strong> 注释的方法，则是用于<strong>相关资源的销毁</strong>，类似于Activity的onDestroy()方法。</p><p>剩下的，通过 <strong>@Test</strong> 注释的方法就表示用于测试的单元，每个测试类里面可以有多个测试单元，这里目前只写了插入和查询两个单元，在 <strong>RoomTest</strong> 类上通过右键运行，然后看一下结果：<br><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/011.png" alt="image"></p><p>在测试代码中的 <strong>insert()单元 </strong> 里，有这样一行代码：</p><pre><code>assert(list.size == 2)</code></pre><p>而测试的结果是一片绿色，就表示这个断言是正确的，list列表长度刚好为2，这里为了验证返回的list是整个数据库长度还是仅仅表示此次进行插入操作的长度，我们修改一下 insert()测试单元：</p><pre><code>   @Test    fun insert() {        val book1 = Book(&quot;时间简史&quot;, &quot;斯蒂芬·威廉·霍金&quot;, &quot;科学&quot;)        val book2 = Book(&quot;百年孤独&quot;, &quot;西亚·马尔克斯&quot;, &quot;文学&quot;)        val list = bookDao!!.insert(book1, book2)        assert(list.size == 2)        val list2 = bookDao!!.insert(book1, book2)        assert(list2.size == 4)    }</code></pre><p>这时候在 <strong>insert()单元测试区域</strong> 右键运行，就只测试这一个单元，然后结果如下：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/012.png" alt="image"></p><p>我们在 insert()单元 中进行了两次插入操作，所以数据库的总长度应该为 4 ，而这里第39行的代码：</p><pre><code>assert(list2.size == 4)</code></pre><p>返回的cede 是 -1，就表示实际上每次插入操作返回的列表长度应该为插入的数量，而非数据库总量。其他操作亦是如此。</p><p>在单元测试中，我们的测试并不能直接用于正式的项目中，因为数据库操作属于耗时操作，所以一定不能把这些操作放在主线程里，而最方便的线程切换，莫过于 <strong>Rxjava</strong> 啦！</p><p>现在开始使用 <strong>Rxjava</strong> 进行测试吧</p><h3 id="结合Rxjava的测试"><a href="#结合Rxjava的测试" class="headerlink" title="结合Rxjava的测试"></a>结合Rxjava的测试</h3><p>首先，要在项目中添加 <strong>Rxjava</strong> 的依赖：</p><pre><code>    //rxJava2+rxAndroid    implementation &quot;io.reactivex.rxjava2:rxjava:2.x.y&quot;    implementation &#39;io.reactivex.rxjava2:rxandroid:2.1.0&#39;</code></pre><p>在单元测试中，RxJava 如果做 <strong>IO线程</strong> 到 <strong>UI线程</strong> 的切换操作，结果是无法获取的，所以需要将这些线程进行合并，方法如下：</p><pre><code>    @Before    @Throws(Exception::class)    fun setUp() {        val context = InstrumentationRegistry.getTargetContext()        bookDataBase = BookDataBase.getInstance(context)        bookDao = bookDataBase!!.bookDao()        ShadowLog.stream = System.out        initRxJava2()    }    private fun initRxJava2() {        RxJavaPlugins.reset()        RxJavaPlugins.setIoSchedulerHandler { Schedulers.trampoline() }        RxAndroidPlugins.reset()        RxAndroidPlugins.setMainThreadSchedulerHandler { Schedulers.trampoline() }    }</code></pre><p>在 <strong>@Before注解</strong> 下的 <strong>setUp()</strong> 方法中进行RxJava的配置，然后我们可以把RxJava常用的线程切换写在一个方法里，方便复用：</p><pre><code>    private fun&lt;T&gt; doWithRxJava(t: T): Observable&lt;T&gt;{        return Observable.create&lt;T&gt;{it.onNext(t)}                .subscribeOn(Schedulers.io())                .unsubscribeOn(Schedulers.io())                .observeOn(AndroidSchedulers.mainThread())    }</code></pre><p>接着，对 <strong>insert单元</strong> 和 <strong>query单元</strong> 进行修改：</p><pre><code>    @Test    fun insert() {        val book1 = Book(&quot;时间简史&quot;, &quot;斯蒂芬·威廉·霍金&quot;, &quot;科学&quot;)        val book2 = Book(&quot;百年孤独&quot;, &quot;西亚·马尔克斯&quot;, &quot;文学&quot;)        doWithRxJava(bookDao!!.insert(book1, book2))                .subscribe ({                    Log.e(&quot;insert长度：&quot; , &quot;${it.size}&quot;)                    assert(it.size == 2)                },{                    Log.e(&quot;insert出错：&quot; , &quot;${it.stackTrace}-${it.message}&quot;)                })    }    @Test    fun query(){        doWithRxJava(bookDao?.all)                .subscribe({                    for(book in it?: emptyList()){                        Log.e(javaClass.name, &quot;获取的书籍数据: ${Gson().toJson(book)}&quot;)                        assert(it?.size == 2)                    }                },{                    Log.e(&quot;query出错：&quot; , &quot;${it.stackTrace}-${it.message}&quot;)                })    }</code></pre><p>然后看一下测试的结果：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/013.png" alt="image"></p><p>那么， <strong>Room DataBase</strong> 的入门指南，就写到这里啦！</p><p>后续我可能会再写一篇进阶版的文章，涵盖了真实使用的场景，然后看能不能写一个简单的Demo出来，这样更方便学习吧！</p><p><del><em>不过我发现我现在的懒癌是越来越严重了，也不知道下一篇是什么时候</em></del></p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/014.png" alt="image"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataBinding——从相识到相知（二）：互酌</title>
      <link href="undefined2018/10/20/DataBinding%E2%80%94%E2%80%94%E4%BB%8E%E7%9B%B8%E8%AF%86%E5%88%B0%E7%9B%B8%E7%9F%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BA%92%E9%85%8C/"/>
      <url>2018/10/20/DataBinding%E2%80%94%E2%80%94%E4%BB%8E%E7%9B%B8%E8%AF%86%E5%88%B0%E7%9B%B8%E7%9F%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BA%92%E9%85%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇里，主要讲了关于Databinding的以下几点：</p><ul><li>接入与使用</li><li>简单的数据绑定</li><li>点击事件的绑定</li></ul><p>这一篇将会继续上一篇的步伐，对DataBinding的使用更深几分.首先依旧是从数据绑定开始<br><a id="more"></a> </p><blockquote><p>之前所介绍的，虽然UI与数据进行了绑定，但是修改数据对象的时候并不会同时更新 <strong>UI</strong> .<br>现在有三种不同类型的 <strong>observable</strong> 类：<strong>objects</strong>, <strong>fields</strong>, 还有 <strong>collections</strong>.<br>当其中某个 <strong>observable</strong> 数据对象绑定到 <strong>UI</strong> 并且数据对象的属性发生更改时， UI 将自动更新，下面开始介绍.</p></blockquote><h1 id="Observable数据"><a href="#Observable数据" class="headerlink" title="Observable数据"></a>Observable数据</h1><p>如果你的数据类只有几个属性，那么没必要去实现 <strong>Observable</strong> 接口来监听数据的改变，可以使用下面这些字段：</p><ul><li><a href="https://developer.android.google.cn/reference/android/databinding/ObservableBoolean.html" target="_blank" rel="noopener"><strong>ObservableBoolean</strong></a></li><li><a href="https://developer.android.google.cn/reference/android/databinding/ObservableByte.html" target="_blank" rel="noopener"><strong>ObservableByte</strong></a></li><li><a href="https://developer.android.google.cn/reference/android/databinding/ObservableChar.html" target="_blank" rel="noopener"><strong>ObservableChar</strong></a></li><li><a href="https://developer.android.google.cn/reference/android/databinding/ObservableShort.html" target="_blank" rel="noopener"><strong>ObservableShort</strong></a></li><li><a href="https://developer.android.google.cn/reference/android/databinding/ObservableInt.html" target="_blank" rel="noopener"><strong>ObservableInt</strong></a></li><li><a href="https://developer.android.google.cn/reference/android/databinding/ObservableLong.html" target="_blank" rel="noopener"><strong>ObservableLong</strong></a></li><li><a href="https://developer.android.google.cn/reference/android/databinding/ObservableFloat.html" target="_blank" rel="noopener"><strong>ObservableFloat</strong></a></li><li><a href="https://developer.android.google.cn/reference/android/databinding/ObservableDouble.html" target="_blank" rel="noopener"><strong>ObservableDouble</strong></a></li><li><a href="https://developer.android.google.cn/reference/android/databinding/ObservableParcelable.html" target="_blank" rel="noopener"><strong>ObservableParcelable</strong></a></li></ul><p>现在，我们再创建一个类</p><pre><code>class ObservableBean {    val text = ObservableField&lt;String&gt;()}</code></pre><p>布局文件改为：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;data&gt;        &lt;variable name=&quot;model&quot; type=&quot;com.test.project.testdatabinding.MVP.DataBinding.Bean.ObservableBean&quot;/&gt;    &lt;/data&gt;    &lt;LinearLayout        android:orientation=&quot;vertical&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;&gt;        &lt;EditText            android:id=&quot;@+id/et_test&quot;            android:text=&quot;@={model.text}&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot; /&gt;        &lt;TextView            android:id=&quot;@+id/tv_test&quot;            android:text=&quot;@{model.text}&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;/&gt;    &lt;/LinearLayout&gt;&lt;/layout&gt;</code></pre><p>需要注意的是，上面的 <strong>EditText</strong> 的 <strong>text</strong> 属性使用的是 <strong>@={}</strong> 而 <strong>TextView</strong> 使用的是 <strong>@{}</strong> 。当你想要使用双向绑定的时候，可别忘了这个 <strong>=</strong> 号</p><p>Activity的代码只改变了绑定对象：</p><pre><code>class DataBindingActivity&lt;T&gt; : AppCompatActivity() {    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)//        setContentView(R.layout.activity_data_binding)        val bindingBinding : ActivityDataBindingBinding = DataBindingUtil.setContentView(this, R.layout.activity_data_binding)        bindingBinding.model = ObservableBean()    }}</code></pre><p>效果如下：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/DataBinding/two/databinding-001.gif" alt="image"></p><p>可以看到，直接使用 <strong>Observable</strong> 字段去实现双向数据绑定是很轻松的，不过实际项目里面需求各不相同，要将数据都换成 <strong>Observable</strong> 字段还是很麻烦的，所以自定义双向数据绑定非常有必要！</p><p>这时对 <strong>ObservableBean</strong> 进行修改：</p><pre><code>class ObservableBean : BaseObservable() {    @get:Bindable    var text: String = &quot;&quot;    set(value) {        field = value        notifyPropertyChanged(BR.text)    }}//相较于Kotlin写法，这里我觉得Java写法更有助于理解：public  class ObservableBean extends BaseObservable {    private String text;    @Bindable    public String getText() {        return text;    }    public ObservableBean setText(String text) {        this.text = text;        notifyPropertyChanged(BR.text);        return this;    }}</code></pre><p>修改过后的效果与之前使用 <strong>Observable</strong> 字段的效果一样，上面需要注意的两点：</p><ul><li>使用了 <strong>@Bindable</strong> 注解，进行绑定声明</li><li>使用了 <strong>notifyPropertyChanged()</strong> 方法为数据刷新做准备</li></ul><p>不过在我看来，通过这种继承的方法对于我们原有的数据结构并不过友好，尤其是继承了 <strong>BaseObservable</strong> 类的数据类不能通过  <strong>Gson</strong> 去与 <strong>Json</strong> 相互转换。</p><p>所以使用的时候，我们可以考虑通过某个中介类的方式去进行转换.</p><h1 id="布局的绑定"><a href="#布局的绑定" class="headerlink" title="布局的绑定"></a>布局的绑定</h1><p>第第一篇中，有写到Activity中如何获取自动生成的布局绑定类——xxxBinding，这种类的命名与使用数据绑定的布局文件xml有关，比如说 <strong>activity_main.xml</strong> 就会生成 <strong>ActivityMainBinding</strong> </p><p>这里再详细说明一下，不同类型的布局，应该怎么获取生成的 <strong>Binding绑定类</strong> </p><blockquote><p>事先并不知道绑定类型的对象可以使用 <strong>DataBindingUtil</strong> 去创建绑定</p></blockquote><pre><code>val rootView = LayoutInflater.from(this).inflate(layoutId, parent, attachToParent)val binding: ViewDataBinding? = DataBindingUtil.bind(viewRoot)</code></pre><h2 id="获取带-ID-的-View对象"><a href="#获取带-ID-的-View对象" class="headerlink" title="获取带 ID 的 View对象"></a>获取带 ID 的 View对象</h2><p>如果使用的是Kotlin，可以直接在Activity里很方便的使用id获取View对象，不过使用DataBinding后，就有另外一种获取View对象的方式了</p><p>布局里面的 Id 如下：</p><pre><code>    ...        &lt;EditText            android:id=&quot;@+id/et_test&quot;            android:text=&quot;@={model.text}&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot; /&gt;    ...</code></pre><p>通过 Id 获取 EditText 的方法如下：</p><pre><code>        ...        super.onCreate(savedInstanceState)        val bindingBinding : ActivityDataBindingBinding = DataBindingUtil.setContentView(this, R.layout.activity_data_binding)        bindingBinding.model = ObservableBean()        val editText = bindingBinding.root.rootView.findViewById&lt;EditText&gt;(R.id.et_test)</code></pre><blockquote><p><strong>立即绑定</strong>  </p><p>当变量或可观察对象发生更改时，绑定会在下一帧之前更改。 不过有的时候需要立刻执行绑定.  </p><p>若要强制执行，可以使用 <strong>executePendingBindings()</strong> 方法。</p></blockquote><h2 id="高级绑定"><a href="#高级绑定" class="headerlink" title="高级绑定"></a>高级绑定</h2><p>有时候，特定的绑定类是未知的.  </p><p>例如，针对任意布局操作的 <strong>RecyclerView.Adapter</strong> 不知道特定的绑定类.它仍然必须在调用 <strong>onBindViewHolder()</strong> 方法时分配绑定值.</p><p>在 <strong>RecyclerView</strong> 的  <strong>onBindViewHolder()</strong> 方法里，可以这样写：</p><pre><code>override fun onBindViewHolder(holder: BindingHolder, position: Int) {    item: T = mItems.get(position)    holder.binding.setVariable(BR.item, item);    holder.binding.executePendingBindings();}</code></pre><h2 id="使用-BindingAdapter自定义绑定逻辑"><a href="#使用-BindingAdapter自定义绑定逻辑" class="headerlink" title="使用@BindingAdapter自定义绑定逻辑"></a>使用@BindingAdapter自定义绑定逻辑</h2><p>DataBinding为我们提供了一种可以对绑定逻辑进行自定义的方法，比如说我想在xml中对一个ImageView控件加载图片，并且是使用的Glide加载框架，这时候可以这样：</p><pre><code>//随便创建一个类，然后在类中定义如下方法@BindingAdapter(&quot;imageUrl&quot;)fun loadImage(view: ImageView, url: String) {    GlideApp.with(view.getContext())   .load(url)   .fitCenter()   .into(view);}</code></pre><p>使用的时候编译器会自动生成对应属性：</p><pre><code>&lt;ImageView app:imageUrl=&quot;@{model.imageUrl}&quot;  /&gt;</code></pre><p>使用 <strong>@BindAdapter</strong> 几乎可以完成你想要的各种逻辑，不过我觉得，只有那种使用率特别高的代码，才最适合这个属性.</p><h2 id="使用-BindingConversion完成转换功能"><a href="#使用-BindingConversion完成转换功能" class="headerlink" title="使用@BindingConversion完成转换功能"></a>使用@BindingConversion完成转换功能</h2><p>在某些情况下，特定类型之间需要自定义转换。 例如，视图的android:background属性需要Drawable，但指定的颜色值是整数。 </p><p>官方例子中，转换功能的具体用法如下：</p><pre><code>@BindingConversionfun convertColorToDrawable(color: Int) = ColorDrawable(color)</code></pre><p>使用的时候可以这样：</p><pre><code>&lt;View   android:background=&quot;@{isError ? @drawable/error : @color/white}&quot;   android:layout_width=&quot;wrap_content&quot;   android:layout_height=&quot;wrap_content&quot;/&gt;</code></pre><h1 id="暂歇"><a href="#暂歇" class="headerlink" title="暂歇"></a>暂歇</h1><p>本篇关于DataBindin的介绍也就到此结束，不过DataBinding的使用还没有到头，下一篇将会侧重实际上的操作以及DataBinding还可以为我们带来哪些便捷.</p><hr><h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataBinding——从路人到好友（一）：初遇</title>
      <link href="undefined2018/10/17/DataBinding%E2%80%94%E2%80%94%E4%BB%8E%E8%B7%AF%E4%BA%BA%E5%88%B0%E5%A5%BD%E5%8F%8B%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%88%9D%E9%81%87/"/>
      <url>2018/10/17/DataBinding%E2%80%94%E2%80%94%E4%BB%8E%E8%B7%AF%E4%BA%BA%E5%88%B0%E5%A5%BD%E5%8F%8B%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%88%9D%E9%81%87/</url>
      
        <content type="html"><![CDATA[<h1 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h1><blockquote><p>在编程领域，对于一名初学者而言，最开始的进阶方式都是不断重复的练习，然后在练习中遇到各种困难，同时也在这个过程里积累了不少的经验。</p><p>一般情况下，我们获取的经验可以有效的减少我们的失误，也可以为我们预防掉许多“隐藏”的Bug。</p><p>但是，随着我们能力的提升，我们逐渐的对于那些重复性非常高、而且意义并不大的代码产生了厌倦感。首当其冲的就是像 <strong>findViewById</strong> 这样的代码！</p></blockquote><a id="more"></a> <p>大量的 <strong>findViewById</strong> 与全局变量想必是许多初学者都会经历的阶段，不过学的东西越多，对于这类代码的接受力也就越低。所以许多人选择用了 <strong>ButterKnife</strong> 去解决这个问题。</p><p>然鹅当 <strong>Kotlin</strong> 出现后，<strong>ButterKnife</strong> 也可以随之抛弃了，这时候 <strong>DataBinding</strong> 的用处却和 <strong>Kotlin</strong> 并不冲突，相反二者结合使用，反而会让你有意想不到的、久违的、可圈可点的、眼前一亮的、拍手称赞的体验！</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>使用 <strong>Data-Binding</strong> ，首先需要在 <strong>app moudle</strong> 下的 <strong>build.gradle</strong> 中添加：</p><pre><code>android {    ...    dataBinding {        enabled = true    }    ...}</code></pre><p>然后就可以正常使用了，不过需要注意，最低支持的Android版本是4.0（反正几乎没有比这更低的android设备了），gradle插件版本是1.5.0 （都2018年了，android开发者们肯定不能用比这更低的版本了吧！）</p><p>接下来，举个最简单的栗子，我们创建一个 <strong>Cartoon</strong> 类：</p><pre><code>class Cartoon(var name:String = &quot;JOJO的奇妙冒险&quot; , var series :String = &quot;黄金之风&quot;,              var leader : String = &quot;乔鲁诺·乔巴纳&quot;, var feature : String = &quot;黄金体验&quot;) {}</code></pre><p>然后新建一个Activity，在这个Activity的xml中的根布局下，通过Alt+Enter快捷键创建databinding的布局，同时，导入 <strong>Cartoon</strong> 类：<br><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/DataBinding/one/databinding-001.png" alt="image"></p><p>这时候，编译器会自动根据这个布局生成相应的绑定类，这里会生成一个 <strong>ActivityDataBindingBinding</strong> 的类 ，暂时先不用管，我们继续在xml上工作，修改一下布局样式：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/DataBinding/one/databinding-002.png" alt="image"></p><p>然后，在对应的Activity内对生成的 <strong>ActivityDataBindingBinding</strong> 类进行操作：</p><pre><code>class DataBindingActivity : AppCompatActivity() {    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)//        setContentView(R.layout.activity_data_binding)        val bindingBinding : ActivityDataBindingBinding = DataBindingUtil.setContentView(this, R.layout.activity_data_binding)        bindingBinding.cartoon = Cartoon()    }}</code></pre><p>由于Kotlin创建的Cartoon实体类已经给每个字段都赋予了初始值，这里不用再进行赋值，然后看一下效果：<br><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/DataBinding/one/databinding-003.png" alt="image"></p><blockquote><p>如果你使用的是 items 去进行的绑定，例如Fragment、RecyclerView的adapter，可以使用 inflate() 的方法去绑定或者 DataBindingUtil 类，就像下面这样</p></blockquote><pre><code>val listItemBinding = ListItemBinding.inflate(layoutInflater, viewGroup, false)// orval listItemBinding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, false)</code></pre><p>如果这时候你想使用字符串拼接，可以在 <strong>string.xml</strong> 中创建，比如：</p><pre><code>    &lt;string name=&quot;cartoon_name&quot;&gt;动漫名:%s&lt;/string&gt;    &lt;string name=&quot;cartoon_series&quot;&gt;系列:%s&lt;/string&gt;    &lt;string name=&quot;cartoon_leader&quot;&gt;主角:&lt;/string&gt;    &lt;string name=&quot;cartoon_bodyDouble&quot;&gt;替身:&lt;/string&gt;</code></pre><p>使用的时候可以是这样：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;data&gt;        &lt;variable name=&quot;cartoon&quot; type=&quot;com.test.project.testdatabinding.DataBinding.Cartoon&quot;/&gt;    &lt;/data&gt;    &lt;LinearLayout        android:orientation=&quot;vertical&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;&gt;        &lt;TextView            android:layout_gravity=&quot;center&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:text=&quot;@{@string/cartoon_name(cartoon.name)}&quot;/&gt;        &lt;TextView            android:layout_gravity=&quot;center&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:text=&quot;@{@string/cartoon_series(cartoon.series)}&quot;/&gt;        &lt;TextView            android:layout_gravity=&quot;center&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:text=&quot;@{@string/cartoon_leader + cartoon.leader}&quot;/&gt;        &lt;TextView            android:layout_gravity=&quot;center&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:text=&quot;@{@string/cartoon_bodyDouble + cartoon.feature}&quot;/&gt;    &lt;/LinearLayout&gt;&lt;/layout&gt;</code></pre><p>效果如下：<br><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/DataBinding/one/databinding-004.png" alt="image"></p><p>至此，我们完成了与DataBinding的初次接触！</p><p>可以看到，相较于往常的通过findViewById去获取控件实例，然后给控件设置数据的方法，这样显然去掉了Activity内许多不必要的代码。</p><p>不过以上只是比较简单的DataBinding用法，下面将会介绍DataBinding的其他功能，这样才能应更复杂的需求。</p><h2 id="集合的使用"><a href="#集合的使用" class="headerlink" title="集合的使用"></a>集合的使用</h2><pre><code>&lt;data&gt;    &lt;import type=&quot;android.util.SparseArray&quot;/&gt;    &lt;import type=&quot;java.util.Map&quot;/&gt;    &lt;import type=&quot;java.util.List&quot;/&gt;    &lt;variable name=&quot;list&quot; type=&quot;List&lt;String&gt;&quot;/&gt;    &lt;variable name=&quot;sparse&quot; type=&quot;SparseArray&lt;String&gt;&quot;/&gt;    &lt;variable name=&quot;map&quot; type=&quot;Map&lt;String, String&gt;&quot;/&gt;    &lt;variable name=&quot;index&quot; type=&quot;int&quot;/&gt;    &lt;variable name=&quot;key&quot; type=&quot;String&quot;/&gt;&lt;/data&gt;…android:text=&quot;@{list[index]}&quot;…android:text=&quot;@{sparse[index]}&quot;…android:text=&quot;@{map[key]}&quot;  //这里也可以使用 @{map.key}代替</code></pre><h2 id="点击事件"><a href="#点击事件" class="headerlink" title="点击事件"></a>点击事件</h2><p>点击事件也是可以在xml中绑定的，在 DataBindingActivity 中添加如下方法：</p><pre><code>    fun doClick(view: View){        Toast.makeText(this, &quot;点击测试&quot;, Toast.LENGTH_SHORT).show()    }</code></pre><p>不要忘了在括号中传入View</p><p>然后再xml中写一个button的点击事件</p><pre><code> &lt;Button            android:text=&quot;DataBinding-点击测试&quot;            android:onClick=&quot;doClick&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot; /&gt;</code></pre><p>如果想通过点击事件传入参数的话，可以通过下面这种方法：</p><pre><code>&lt;variable name=&quot;handler&quot; type=&quot;com.test.project.testdatabinding.DataBinding.DataBindingActivity&quot;/&gt;&lt;Button            android:text=&quot;DataBinding-点击测试&quot;            android:onClick=&quot;@{() -&gt; handler.doClick(cartoon.name)}&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot; /&gt;</code></pre><p>从xml中导入 DataBindingActivity 后，再修改代码：</p><pre><code>class DataBindingActivity : AppCompatActivity() {    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)//        setContentView(R.layout.activity_data_binding)        val bindingBinding : ActivityDataBindingBinding = DataBindingUtil.setContentView(this, R.layout.activity_data_binding)        bindingBinding.cartoon = Cartoon()        bindingBinding.handler = this    }    fun doClick(message: String){        Toast.makeText(this, message, Toast.LENGTH_SHORT).show()    }}</code></pre><p>点击效果如下：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/DataBinding/one/databinding-005.png" alt="image"></p><p>如果有更加复杂的点击事件，可以参考官介绍中的，如带View参数的：</p><pre><code>class Presenter {    fun onSaveClick(view: View, task: Task){}}android:onClick=&quot;@{(theView) -&gt; presenter.onSaveClick(theView, task)}&quot;</code></pre><h2 id="import-与-include"><a href="#import-与-include" class="headerlink" title="import 与 include"></a>import 与 include</h2><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>在xml中，可以通过导入一些工具类进行简单地操作，比如说导入View类：</p><pre><code>&lt;data&gt;    &lt;import type=&quot;android.view.View&quot;/&gt;&lt;/data&gt;</code></pre><p>这样你就可以直接在xml中使用它的一些静态方法或者变量,官方的例子中简单地用法如下：</p><pre><code>&lt;TextView   android:text=&quot;@{user.lastName}&quot;   android:layout_width=&quot;wrap_content&quot;   android:layout_height=&quot;wrap_content&quot;   android:visibility=&quot;@{user.isAdult ? View.VISIBLE : View.GONE}&quot;/&gt;</code></pre><p>不过我觉得xml中不适合做太多逻辑判断的操作，所以使用的时候应该考虑一下某些操作是否真的合适</p><h3 id="include"><a href="#include" class="headerlink" title="include"></a>include</h3><p>如果你有在xml中使用到 include ，通过下面例子中的方法就行绑定：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;    &lt;data&gt;        &lt;variable name=&quot;cartoon&quot; type=&quot;com.test.project.testdatabinding.DataBinding.Cartoon&quot;/&gt;    &lt;/data&gt;    &lt;LinearLayout        android:orientation=&quot;vertical&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;&gt;       &lt;include layout=&quot;@layout/layout_test&quot;           bind:cartoon=&quot;@{cartoon}&quot;/&gt;    &lt;/LinearLayout&gt;&lt;/layout&gt;</code></pre><p>layout_test 布局：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;data&gt;        &lt;variable name=&quot;cartoon&quot; type=&quot;com.test.project.testdatabinding.DataBinding.Cartoon&quot;/&gt;    &lt;/data&gt;    &lt;android.support.constraint.ConstraintLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;&gt;        &lt;TextView            android:text=&quot;@{cartoon.name}&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot; /&gt;    &lt;/android.support.constraint.ConstraintLayout&gt;&lt;/layout&gt;</code></pre><p>注意，要使用 bind 属性，可别忘了下面的这行代码：</p><pre><code>xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;</code></pre><h1 id="暂歇"><a href="#暂歇" class="headerlink" title="暂歇"></a>暂歇</h1><p>出于篇幅考虑，关于 <strong>DataBinding</strong> 的使用，暂且就讲到这里，关于它更详尽的用法，后续再作介绍。</p><hr><h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手把手教你接入android端微信支付</title>
      <link href="undefined2018/10/08/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E6%8E%A5%E5%85%A5android%E7%AB%AF%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/"/>
      <url>2018/10/08/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E6%8E%A5%E5%85%A5android%E7%AB%AF%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/</url>
      
        <content type="html"><![CDATA[<h2 id="Android端接入微信支付，蛮简单的"><a href="#Android端接入微信支付，蛮简单的" class="headerlink" title="Android端接入微信支付，蛮简单的"></a>Android端接入微信支付，蛮简单的</h2><h3 id="一、添加gradle依赖："><a href="#一、添加gradle依赖：" class="headerlink" title="一、添加gradle依赖："></a>一、添加gradle依赖：</h3><p>在app module目录下的build.gralde中添加</p><pre><code>dependencies {    //微信SDK接入    implementation &#39;com.tencent.mm.opensdk:wechat-sdk-android-with-mta:+&#39;}</code></pre><a id="more"></a> <p>gralde构建完成之后，再做下一步的操作。</p><h3 id="二、在AndroidManifest-xml中添加相关权限："><a href="#二、在AndroidManifest-xml中添加相关权限：" class="headerlink" title="二、在AndroidManifest.xml中添加相关权限："></a>二、在AndroidManifest.xml中添加相关权限：</h3><pre><code>    &lt;!--微信支付权限--&gt;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.MODIFY_AUDIO_SETTINGS&quot;/&gt;    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;</code></pre><h3 id="三、创建wxapi目录，并创建WXPayEntryActivity"><a href="#三、创建wxapi目录，并创建WXPayEntryActivity" class="headerlink" title="三、创建wxapi目录，并创建WXPayEntryActivity"></a>三、创建wxapi目录，并创建WXPayEntryActivity</h3><p>在你的package目录下，创建<strong>wxapi</strong>目录，比如说我使用的demo项目，<strong>wxapi</strong>就在目录<strong>net.sourceforge.simcpux</strong>目录下</p><p>同时，在<strong>wxapi</strong>目录下创建<strong>WXPayEntryActivity</strong></p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/wxpay-001.png" alt="image"></p><p><strong>WXPayEntryActivity</strong>实现<strong>IWXAPIEventHandler</strong>接口，这个Activity页面就是支付结果的回调页面，下面是它最简单地实现：</p><pre><code>public class WXPayEntryActivity extends Activity implements IWXAPIEventHandler{    private static final String TAG = &quot;MicroMsg.SDKSample.WXPayEntryActivity&quot;;    private IWXAPI api;    @Override    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.pay_result);        api = WXAPIFactory.createWXAPI(this, &quot;你的appid&quot;);        api.handleIntent(getIntent(), this);    }    @Override    protected void onNewIntent(Intent intent) {        super.onNewIntent(intent);        setIntent(intent);        api.handleIntent(intent, this);    }    @Override    public void onReq(BaseReq req) {    }    @Override    public void onResp(BaseResp resp) {        Log.d(TAG, &quot;onPayFinish, errCode = &quot; + resp.errCode);        if (resp.getType() == ConstantsAPI.COMMAND_PAY_BY_WX) {            AlertDialog.Builder builder = new AlertDialog.Builder(this);            builder.setTitle(&quot;支付结果&quot;);            builder.setMessage(getString(R.string.pay_result_callback_msg, String.valueOf(resp.errCode)));            builder.show();        }    }}</code></pre><p>同时，别忘了在<strong>AndroidManifest.xml</strong>中声名<strong>WXPayEntryActivity</strong></p><pre><code>        &lt;activity            android:name=&quot;.wxapi.WXPayEntryActivity&quot;            android:exported=&quot;true&quot;            android:launchMode=&quot;singleTop&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;                &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;                &lt;data android:scheme=&quot;你的appid&quot;/&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;</code></pre><p>当这些准备工作都做好之后，就可以准备使用了。</p><h3 id="四、使用"><a href="#四、使用" class="headerlink" title="四、使用"></a>四、使用</h3><p>当你从服务端获取到订单的相关信息后，就可以调用支付接口了：</p><pre><code>                IWXAPI api = WXAPIFactory.createWXAPI(context, null);                api.registerApp(IntentKey.WX_APP_ID);                PayReq req = new PayReq();                req.appId            = &quot;wx8888888888888888&quot;;//你的微信appid                req.partnerId        = &quot;1900000109&quot;;//商户号                req.prepayId        = &quot;WX1217752501201407033233368018&quot;;//预支付交易会话ID                req.nonceStr        = &quot;5K8264ILTKCH16CQ2502SI8ZNMTM67VS&quot;;//随机字符串                req.timeStamp        = &quot;1412000000&quot;;//时间戳                req.packageValue    = &quot;Sign=WXPay&quot;;扩展字段,这里固定填写Sign=WXPay                req.sign            = &quot;C380BEC2BFD727A4B6845133519F3AD6&quot;;//签名//                req.extData            = &quot;app data&quot;; // optional                // 在支付之前，如果应用没有注册到微信，应该先调用IWXMsg.registerApp将应用注册到微信                api.sendReq(req);</code></pre><p>这里需要注意的是，上面的这些信息，都应该从服务器去获取，比如说随机字符串之类的长短也不一定和上面例子中的一致。具体是什么，得看你们的后端给的是什么。</p><p>不出意外的话，通过上面接口的调用，你就可以正常使用微信提供的APP支付了。</p><p>是不是非常简单？！</p><p><strong><em>然鹅。。。</em></strong></p><p>事情哪儿有这么顺利，到了真正使用的时候，遇到的问题可不少，下面会列举出遇到过的问题，然后说明解决办法。</p><h2 id="Android端接入微信支付，坑蛮多的"><a href="#Android端接入微信支付，坑蛮多的" class="headerlink" title="Android端接入微信支付，坑蛮多的"></a>Android端接入微信支付，坑蛮多的</h2><p><strong>微信支付app的接入，要我来说，对初次尝试的人非常不友好</strong></p><p>一般情况下，开发者使用新的工具都需要先看一看它的说明文档，如果说明文档写的够好，直接用就是了；如果文档介绍的不够全面，还需要有Demo提供参考。微信的App支付就属于后者。<br>下面是它的接入文档页面：</p><p><a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=1417751808&amp;token=&amp;lang=zh_CN" target="_blank" rel="noopener">Android接入指南</a>（还有其他相关信息也可以通过这个页面接入）</p><p>由于仅仅靠着文档的说明不足以让我掌握对微信支付的使用，所以自然而然的，Demo就成了初次接触微信支付者的学习教材啦！</p><p><a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=11_1" target="_blank" rel="noopener">Demo下载</a></p><p>当你接入Demo后，一系列的问题将会接踵而至，下面来看一看具体是什么问题</p><h3 id="接入Demo"><a href="#接入Demo" class="headerlink" title="接入Demo"></a>接入Demo</h3><p>将下载后的Demo按照Import moudule的方式接入到某个项目中：<br><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/wxpay-002.png" alt="image"></p><p>然后选中这个项目，进行编译：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/wxpay-003.png" alt="image"></p><p>接下来，编译器就开始报错了，找到报错的位置，发现是如下问题：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/wxpay-004.png" alt="image"></p><p><strong>到这里开始，我就要吐槽了</strong></p><p>这种问题一看就是找不到包了，于是我们看一下这个项目中的build.gralde中的依赖，如下</p><pre><code>dependencies {    compile files(&#39;libs/libammsdk.jar&#39;)    compile files(&#39;libs/wechat-sdk-android-with-mta-1.0.2.jar&#39;)}</code></pre><p>很显然，是导入的本地jar包，为了方便起见，我们将这里的依赖修改成之前配置时的：</p><pre><code>dependencies {    //微信SDK接入    implementation &#39;com.tencent.mm.opensdk:wechat-sdk-android-with-mta:+&#39;}</code></pre><p>同时，我们还可以发现，重新构建完项目后，上面的问题并没有解决。</p><p>这时候我们在Android studio的中的<strong>External Libraries</strong>去看一看新构建的库:</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/wxpay-005.png" alt="image"></p><p>可以看到，正确的引用路径应该是把<strong>sdk</strong>换成<strong>opensdk</strong></p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/wxpay-006.png" alt="image"></p><p>当你将所有的路径都修改过来后，还会有如下问题：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/wxpay-007.png" alt="image"></p><p>将上面的 <strong>imgObj.imageUrl = url</strong> 修改为：</p><pre><code>imgObj.setImagePath(url);</code></pre><p>这个错误出现的地方有两处吧，当你把这些错误都解决后，再次进行编译，就可以正常运行啦！</p><p>Demo运行后的界面是这样的：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/wxpay-008.png" alt="image"></p><p>到了这里，基本上就可以进行测试了，剩下的东西无需再多说，过程差不多和上面直接接入的流程一样，不过要demo里面的更加详细，只需多多观摩即可。</p><p>那么，最后还是说一下需要注意的点吧。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在微信开放平台上面设置app相关参数的时候，需要<strong>应用包名</strong>以及<strong>应用签名</strong></p><p><img src="https://pay.weixin.qq.com/wiki/doc/api/img/chapter8_5_2.png" alt="image"></p><p>获取应用签名的工具地址是：<a href="https://open.weixin.qq.com/zh_CN/htmledition/res/dev/download/sdk/Gen_Signature_Android.apk" target="_blank" rel="noopener">签名工具下载地址</a></p><blockquote><p>这里又要吐槽一下，签名工具就是一个apk，装到手机上后，输入包名，然后生成签名，最关键的是这个签名无法复制，使用下来就一个感受，不方便啊！！！！</p></blockquote><p>签名工具里面输入的包名就是之前提到过的，可以直接在Androidmanifest.xml中复制。</p><p><strong>但是</strong></p><pre><code>尽管包名一样，release版的项目和debug版的项目最后生成的签名都是不一样的，这点很重要！</code></pre><p><strong>所以如果你是用的debug进行测试，那么网站里面的签名一定要填写debug版下获取到的签名，正式发布的时候，要把它换成release版的！如果签名不一致，你是无法通过那个“-1”返回值获取到任何有效的错误信息的!切记！</strong></p><font face="STCAIYUN"><del>~</del><del>~</del><del>~</del><del>~</del><del>~</del>~~~~那么</font><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/wxpay-009.png" alt="image"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin笔记(五):基础篇latest</title>
      <link href="undefined2018/10/05/Kotlin%E7%AC%94%E8%AE%B0-%E4%BA%94-%E5%9F%BA%E7%A1%80%E7%AF%87latest/"/>
      <url>2018/10/05/Kotlin%E7%AC%94%E8%AE%B0-%E4%BA%94-%E5%9F%BA%E7%A1%80%E7%AF%87latest/</url>
      
        <content type="html"><![CDATA[<h3 id="1-可空类型"><a href="#1-可空类型" class="headerlink" title="1.可空类型"></a>1.可空类型</h3><p>问号可以加在任何类型的后面来表示这个类型的变量可以存储 null 引用 ： String?、 Int?、 MyCustomType? ，等等</p><p>一旦你有一个可空类型的值，能对它进行的操作也会受到限制。例如，不能再调用它的方法 </p><pre><code>&gt;&gt; fun strLenSafe(s: String?) = s.length() ERROR: only safe (?.) or non null asserted (!!.) calls are allowed on a nullable receiver of type kotlin.String?</code></pre><a id="more"></a> <p>也不能把它赋值给非空类型的变量 ：</p><pre><code>&gt;&gt; val x: String? = null &gt;&gt; var y: String = x ERROR: Type mismatch: inferred type is String? but String was expected </code></pre><p>也不能把可空类型的值传给拥有非空类型参数的函数 ：</p><pre><code>&gt;&gt; strLen(x) ERROR: Type mismatch: inferred type is String? but String was expected </code></pre><p>那么你可以对它做什么呢？最重要的操作就是和 null 进行比较。 而且一旦你 进行了比较操作，编译器就会记住，并且在这次比较发生的作用域内把这个值当作非空来对待</p><h3 id="2-安全调用运算符：”-”"><a href="#2-安全调用运算符：”-”" class="headerlink" title="2.安全调用运算符：”?.”"></a>2.安全调用运算符：”?.”</h3><blockquote><p>Kotlin的弹药库中最有效的一种工具就是安全调用运算符：?.，它允许你把一 次null检查和一次方法调用合并成一个操作。</p></blockquote><p>例如，表达式 s?.toUpperCase() 等同于下面这种烦琐的写法：if(s!=null) s.toUpperCase() else null。 </p><h3 id="3-Elvis运算符：”-”"><a href="#3-Elvis运算符：”-”" class="headerlink" title="3.Elvis运算符：”?:”"></a>3.Elvis运算符：”?:”</h3><p>Kotlin 有方便的运算符来提供代替null的默认值。它被称作<strong>Elvis运算符</strong>（或者 null合并运算符，如果你喜欢听起来更严肃的名称）。下面展示了它是如何使用的：</p><pre><code>fun foo(s: String?) {    val t: String= s?:&quot;&quot;}</code></pre><p><em>Elvis 运算符接收两个运算数，如果第一个运算数不为null，运算结果就是第 一个运算数；如果第一个运算数为null，运算结果就是第二个运算数。</em></p><h3 id="4-安全转换：”as-”"><a href="#4-安全转换：”as-”" class="headerlink" title="4.安全转换：”as?”"></a>4.安全转换：”as?”</h3><blockquote><p>as? 运算符尝试把值转换成指定的类型，如果值不是合适的类型就返回 null</p></blockquote><p>一种常见的模式是把安全转换和 Elvis 运算符结合使用。例如，实现 equals 方法的时候这样的用法非常方便。</p><pre><code>class Person(val firstNarne: String, val lastNarne: String){    override fun equals(o: Any?): Boolean {        val otherPerson = o as? Person?: return false        return otherPerson.firstNarne == firstNarne &amp;&amp; otherPerson.lastNarne == lastNarne     }    override fun hashCode(): Int = firstNarne.hashCode() * 37 + lastNarne.hashCode() }&gt;&gt; val pl = Person ( &quot;Drnitry&quot;,&quot;Jernerov&quot;) &gt;&gt; val p2 = Person ( &quot;Drnitry&quot;,&quot;Jernerov&quot;) &gt;&gt; println (pl == p2) true&gt;&gt; println(pl.equals(42)) false </code></pre><h3 id="5-非空断言：”-”"><a href="#5-非空断言：”-”" class="headerlink" title="5.非空断言：”!!”"></a>5.非空断言：”!!”</h3><blockquote><p>非空断言是 Kotlin 提供给你的最简单直率的处理可空类型值的工具。它使用双感叹号表示，可以把任何值转换成非空类型。如果对 null 值做非空断言，则会抛出异常。</p></blockquote><p>某些问题适合用非空断言来解决。当你在一个函数中检查一个值是否为null，而在另一个函数中使用这个值时，这种情况下编译器无法识别这种用法是否安全。如果你确信这样的检查一定在其他某个函数中存在，你可能不想在使用这个值之前重复检查，这时你就可以使用非空断言。</p><p> 当你使用 !! 并且它的结果是异常时， 异常调用械的跟踪信息只表明异常发生在哪一行代码，而不会表明异常发生在哪一个表达 式。 为了让跟踪信息更清晰精确地表示哪个值为 null，最好避免在同一行中使用多个!!断言</p><h3 id="6-”let”函数"><a href="#6-”let”函数" class="headerlink" title="6.”let”函数"></a>6.”let”函数</h3><blockquote><p>let 函数让处理可空表达式变得更容易。 和安全调用运算符一起，它允许你对表达式求值，检查求值结果是否为 null，并把结果保存为一个变量。 所有这些动作都在同一个简洁的表达式中。 </p></blockquote><p>下面举个栗子：</p><pre><code>fun sendEmailTo(email: String) { /* ... */ } </code></pre><p>不能把可空类型的值传上面给这个函数：</p><pre><code>&gt;&gt; val email: String? = ...&gt;&gt; sendEmailTo(email) ERROR: Type mismatch: inferred type is String? but String was expected </code></pre><p>必须显式地检查这个值不为 null:</p><pre><code>if (email != null) sendEmailTo(email)</code></pre><p>如果使用了let函数，会是下面这样子的：</p><pre><code>email?.let { email -&gt; sendEmailTo(email) } </code></pre><p><strong>let</strong> 函数只在 email 的值非空时才被调用，所以你就能在 lambda 中把 email 当作非空的实参使用。<br>使用自动生成的名字 it 这种简明语法之后，上面的代码就更短了 ： </p><pre><code> email?.let{ sendEmailTo(it) ｝ </code></pre><h3 id="7-延迟初始化的属性"><a href="#7-延迟初始化的属性" class="headerlink" title="7.延迟初始化的属性"></a>7.延迟初始化的属性</h3><p>Kotlin 通常要求你在构造方法中初始化所有属性，如果某个属性是 非空类型，你就必须提供非空的初始化值。否则，你就必须使用可空类型。否则， 你就必须使用可空类型。如果你这样做，该属性的每一次访问都需要 null 检查或者 !! 运算符。</p><pre><code>class MyService {    fun performAction() : String = &quot;foo&quot;}class MyTest{    private var myService: MyService? = null     @Before fun setUp(){        myService = MyService()     }    @Test fun testAction(){        //必须注意可空性：要么 用!!， 要么用?.        Assert.assertEquals( &quot;foo&quot; ， myService!!.performAction() )     }}</code></pre><p>这段代码很难看，尤其是你要反复使用这个属性的时候。<br>为了解决这个问题， 使用 <strong>lateinit</strong> 修饰符来完成这样的声明。</p><pre><code>class MyService {    fun performAction() : String = &quot;foo&quot;}class MyTest{    //声明一个不需要初始化 器的非空类型的属性    private lateinit var myService: MyService    @Before fun setUp(){        myService = MyService()     }    @Test fun testAction(){        //不需要 null 检查直接访问属性        Assert.assertEquals( &quot;foo&quot; ， myService!!.performAction() )     }}</code></pre><p><em>注意， 延迟初始化的属性都是 var，因为需要在构造方法外修改它的值</em></p><h3 id="8-”Any”和”Any-”：根类型"><a href="#8-”Any”和”Any-”：根类型" class="headerlink" title="8.”Any”和”Any?”：根类型"></a>8.”Any”和”Any?”：根类型</h3><blockquote><p>和 Object 作为 Java 类层级结构的根差不多， <strong>Any</strong> 类型是 Kotlin 所有非空类型的超类型（非空类型的根）。</p><p>但是在 Java 中， Object 只是所有引用类型的超类 型（引用类型的根），而基本数据类型并不是类层级结构的一部分。</p><p>这意味着当你 需要 Object 的时候，不得不使用像 java.lang.Integer 这样的包装类型来表示基本数据类型的值。 <strong>而在 Kotlin 中， Any 是所有类型的超类型（所有类型的根）</strong>， 包括像 Int 这样的基本数据类型。 </p></blockquote><p>和 Java 一样，把基本数据类型的值赋给 <strong>Any</strong> 类型的变量时会自动装箱：</p><pre><code>val answer: Any = 42 </code></pre><p><em>注意 <strong>Any</strong> 是非空类型，所以 <strong>Any</strong> 类型的变量不可以持有 null 值</em></p><h3 id="9-Unit-类型-：-Kotlin-的”void”"><a href="#9-Unit-类型-：-Kotlin-的”void”" class="headerlink" title="9.Unit 类型 ： Kotlin 的”void”"></a>9.Unit 类型 ： Kotlin 的”void”</h3><p>Kotlin 中的 <strong>Unit</strong> 类型完成了 Java 中的 void 一样的功能。当函数没什么有意思的结果要返回时，它可以用作函数的返回类型：</p><pre><code>fun f () : Unit { . . . } </code></pre><p>语法上，这和写一个带有代码块体但不带类型声明的函数没有什么不同：</p><pre><code>fun f () { .. }         //缩写版</code></pre><blockquote><p>Unit 是一个完备的类型，可以作为类型参数，而 void 却不行。</p></blockquote><p>在函数式编程语言中， Unit 这个名字习惯上被用来表示“只有一个实例”，这正是 Kotlin 的 Unit 和 Java 的 void 的区别。</p><h3 id="10-Nothing类型：“这个函数永不返回”"><a href="#10-Nothing类型：“这个函数永不返回”" class="headerlink" title="10.Nothing类型：“这个函数永不返回”"></a>10.Nothing类型：“这个函数永不返回”</h3><p>对某些 Kotlin 函数来说，”返回类型”的概念没有任何意义，因为它们从来不会成功地结束<br>,Kotlin 使用一种特殊的返回类型 Nothing 来表示：</p><pre><code>fun fail(message: String): Nothing {     throw IllegalStateException (message)}&gt;&gt; fail (&quot;Error occurred&quot;)java.lang.IllegalStateException: Error occurred </code></pre><p>Nothing 类型没有任何值， 只有被当作函数返回值使用，或者被当作泛型函数 返回值的类型参数使用才会有意义。在其他所有情况下，声明一个不能存储任何值 的变量没有任何意义。 </p><h3 id="11-可空性和集合"><a href="#11-可空性和集合" class="headerlink" title="11.可空性和集合"></a>11.可空性和集合</h3><p>遍历一个包含可空值的集合并过滤掉 null 是一个非常常见的操作，因此 Kotlin 提供了一个标准库函数 <strong>filterNotNull</strong> 来完成它。 </p><h3 id="12-只读集合与可变集合"><a href="#12-只读集合与可变集合" class="headerlink" title="12.只读集合与可变集合"></a>12.只读集合与可变集合</h3><p>Kotlin 的集合设计和 Java 不同的另一项重要特质是，它把访问集合数据的接口和修改集合数据的接口分开了。这种区别存在于最基础的使用集合的接口之中:kotlin.collections.Collection。</p><p>使用 kotlin.collections.MutableCollection 接口可以修改集合中的数据。它继承了普通的 kotlin.collections.Collection 接口,还提供了方法来添加和移除元素、清空集合等。 </p><p>一般的规则是在代码的任何地方都应该使用只读接口，只在代码需要修改集合的地方使用可变接口的变体</p>]]></content>
      
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin笔记(四):基础篇most plus</title>
      <link href="undefined2018/10/03/Kotlin%E7%AC%94%E8%AE%B0-%E5%9B%9B-%E5%9F%BA%E7%A1%80%E7%AF%87most-plus/"/>
      <url>2018/10/03/Kotlin%E7%AC%94%E8%AE%B0-%E5%9B%9B-%E5%9F%BA%E7%A1%80%E7%AF%87most-plus/</url>
      
        <content type="html"><![CDATA[<h3 id="1-成员引用"><a href="#1-成员引用" class="headerlink" title="1.成员引用"></a>1.成员引用</h3><p>Kotlin和Java8一样，如果把函数转换成一个值，你就可以传递它。  </p><blockquote><p>使用:: 运算符来转换 ：</p></blockquote><pre><code>val getAge = Person::age </code></pre><p>这种表达式称为成员引用，它提供了简明语法，来创建一个调用单个方法或者 访问单个属性的函数值。双冒号把类名称与你要引用的成员（一个方法或者一个属性）名称隔开<br><a id="more"></a> </p><h3 id="2-集合的函数式API"><a href="#2-集合的函数式API" class="headerlink" title="2.集合的函数式API"></a>2.集合的函数式API</h3><p><strong>filter</strong> 函数遍历集合并选出应用给定 <strong>lambda</strong> 后会返回 <strong>true</strong> 的那些元素：</p><pre><code>&gt;&gt; val list= listOf(l, 2, 3, 4) &gt;&gt; println(list.filter{it % 2 == 0}) </code></pre><p><strong>filter</strong> 函数可以从集合中移除你不想要的元素，但是它并不会改变这些元素。 元素的变换是 <strong>map</strong> 的用武之地。 </p><p><strong>map</strong> 函数对集合中的每一个元素应用给定的函数并把结果收集到一个新集合。可以把数字列表变换成它们平方的列表，比如：</p><pre><code>&gt;&gt; val list= listOf(l, 2, 3, 4) &gt;&gt; println(list.map { it * it }{1, 4, 9, 16}</code></pre><h3 id="3-”all””any””count”和”find”：对集合应用判断式"><a href="#3-”all””any””count”和”find”：对集合应用判断式" class="headerlink" title="3.”all””any””count”和”find”：对集合应用判断式"></a>3.”all””any””count”和”find”：对集合应用判断式</h3><p>检查集合中的所有元素是否都符合某个条件（或者它的变种，是否存在符合的元素）。Kotlin中，它们是通过 <strong>all</strong> 和 <strong>any</strong> 函数表达的。 </p><pre><code>val canBeinClub27 = { p: Person - &gt; p.age &lt;= 27 } </code></pre><blockquote><p>如果你对是否所有元素都满足判断式感兴趣，应该使用 <strong>all</strong> 函数：</p></blockquote><pre><code>&gt;&gt; val people= listOf(Person (&quot;Alice&quot;, 27), Person(&quot;Bob&quot;, 31))&gt;&gt; println( people.all(canBeinClub27) ) false</code></pre><blockquote><p>如果你需要检查集合中是否至少存在一个匹配的元素，那就用 <strong>any</strong> :</p></blockquote><pre><code>&gt;&gt; println(people any(canBeinClub27)) true </code></pre><blockquote><p>如果你想知道有多少个元素满足了判断式，使用 <strong>count</strong> : </p></blockquote><pre><code>&gt;&gt; val people= listOf(Person(&quot;Alice&quot;, 27) , Person (&quot;Bob&quot;, 31)) &gt;&gt; println(people.count(canBeinClub27))1</code></pre><blockquote><p>要找到一个满足判断式的元素，使用 <strong>find</strong> 函数 ：</p></blockquote><pre><code>&gt;&gt; val people= listOf(Person(&quot;Alice&quot;， 27) , Person(&quot;Bob&quot;, 31)) &gt;&gt; println(people.find(canBeinClub27)) Person(name=Alice, age=27) </code></pre><h3 id="4-groupBy-：把列表转换成分组的-map"><a href="#4-groupBy-：把列表转换成分组的-map" class="headerlink" title="4.groupBy ：把列表转换成分组的 map"></a>4.groupBy ：把列表转换成分组的 map</h3><p>假设你需要把所有元素按照不同的特征划分成不同的分组。例如，你想把人按年龄分组，相同年龄的人放在一组。把这个特征直接当作参数传递十分方便。<strong>groupBy</strong> 函数可以帮你做到这一点：</p><pre><code>&gt;&gt; val people= listOf(Person(&quot;Alice&quot;, 31), Person(&quot;Bob&quot;, 29), Person (&quot;Carol&quot;, 31))&gt;&gt; println(people.groupBy {it.age})</code></pre><p>这次操作的结果是一个 <strong>map</strong>，是元素分组依据的键（这个例子中是age）和元素分组（persons）之间的映射</p><h3 id="5-flatMap-和-flatten-：处理嵌套集合中的元素"><a href="#5-flatMap-和-flatten-：处理嵌套集合中的元素" class="headerlink" title="5.flatMap 和 flatten ：处理嵌套集合中的元素"></a>5.flatMap 和 flatten ：处理嵌套集合中的元素</h3><p>假设你有一堆藏书，使用 Book 类表示 ：</p><pre><code>class Book (val title: String, val authors: List&lt;String&gt;) </code></pre><p>每本书都可能有一个或者多个作者，可以统计出图书馆中的所有作者的 set : </p><pre><code>books.flatMap { it.authors } toSet() </code></pre><p><strong>flatMap</strong> 函数做了两件事情：首先根据作为实参给定的函数对集合中的每个元素做变换（或者说映射），然后把多个列表合并（或者说平铺）成一个列表。 </p><blockquote><p><strong>注意，如果你不需要做任何变换，只是需要平铺一个集合，可以使用flatten函数：listOfLists.flatten() 。</strong></p></blockquote><p>Kotlin 标准库参考文档有说明，<strong>filter</strong> 和 <strong>map</strong> 都会返回一个列表。这意味着元素过多的时候，（链式）调用就会变得十分低效。为了提高效率，可以把操作变成使用序列，而不是直接使用集合，下面是对比的例子</p><pre><code>people.map(Person: :name) .filter { it.startsWith(&quot;A&quot;)｝</code></pre><p>转化为：</p><pre><code>people.asSequence()    .map (Person: : name)    .filter{it.startsWith(&quot;A&quot;)}    .tolist</code></pre><p>Kotlin惰性集合操作的入口就是 <strong>Sequence</strong> 接口。这个接口表示的就是一个可以逐个列举元素的元素序列。 </p><p>可以调用扩展函数 <strong>asSequence</strong> 把任意集合转换成序列，调用  <strong>toList</strong> 来做反向的转换。 </p><h3 id="6-使用Java函数式接口"><a href="#6-使用Java函数式接口" class="headerlink" title="6.使用Java函数式接口"></a>6.使用Java函数式接口</h3><p> <strong>OnClickListener</strong> 接口只有一个抽象方法。这种接口被称为 <strong>函数式接口</strong>，或者 <strong>SAM接口</strong>，<strong>SAM</strong> 代表抽象方法。JavaAPI中随处可见像<strong>Runnable</strong>和<strong>Callable</strong>这样的函数式接口，以及支持它们<br> 的方法。 Kotlin 允许你在调用接收函数式接口作为参数的方法时使用 <strong>lambda</strong>，来保证你的 Kotlin代码既整洁又符合习惯。</p><p>可以把 <strong>lambda</strong> 传给任何期望函数式接口的方法。例如，下面这个方法，它有一个 <strong>Runnable</strong> 类型的参数：</p><pre><code>/* Java */ void postponeComputation(int delay, Runnable computation); </code></pre><p>下面是显式地创建一个实现了 <strong>Runnable</strong> 的匿名对象的例子：</p><pre><code>post postponeComputation(1OOO, object : Runnable {     override fun run() {    println(42)     })}</code></pre><p>在 Kotlin 中，可以调用它并把一个 <strong>lambda</strong> 作为实参传给它。编译器会自动把它转换成一个 <strong>Runnable</strong> 的实例：</p><pre><code>postponeComputation(lOOO) { println(42) }</code></pre><p>完全等价的实现应该是下面这段代码中的显式<strong>object</strong>声明，它把<strong>Runnable</strong>实例存储在一个变量中，并且每次调用的时候都使用这个变量：</p><pre><code>val runnable = Runnable { println(42) } fun handleComputation(){ postponeComputation(1OOO, runnable)} </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin笔记(三):基础篇more plus</title>
      <link href="undefined2018/10/02/Kotlin%E7%AC%94%E8%AE%B0-%E4%B8%89-%E5%9F%BA%E7%A1%80%E7%AF%87more-plus/"/>
      <url>2018/10/02/Kotlin%E7%AC%94%E8%AE%B0-%E4%B8%89-%E5%9F%BA%E7%A1%80%E7%AF%87more-plus/</url>
      
        <content type="html"><![CDATA[<h3 id="1-接口的默认实现"><a href="#1-接口的默认实现" class="headerlink" title="1.接口的默认实现"></a>1.接口的默认实现</h3><p>接口的方法可以有一个默认实现。与Java8不同的是，Java8中需要你在这样的实现上标注default关键字，对于这样的方法，Kotlin没有特殊的注解 ：只需要提供一个方法体</p><pre><code>interface Clickable{    fun click()    fun showOff = println(&quot;I&#39;m clickable&quot;)}</code></pre><a id="more"></a> <p>在实现接口的地方如果要显式地实现方法，在Kotlin中需要把 基类的名字放在尖括号中 ：</p><pre><code>super&lt;Clickable&gt;.showOff() </code></pre><h3 id="2-定义类的继承结构"><a href="#2-定义类的继承结构" class="headerlink" title="2.定义类的继承结构"></a>2.定义类的继承结构</h3><pre><code>Java的类和方法默认是open的，而Kotlin中默认都是final的。 </code></pre><p>如果你想允许创建一个类的子类，需要使用 <strong>open</strong> 修饰符来标示这个类。此外，需要给每一个可以被重写的属性或方法添加open修饰符。</p><blockquote><p><em>注意，如果你重写了一个基类或者接口的成员，重写了的成员同样默认是 open的。如果你想改变这一行为，阻止你的类的子类重写你的实现，可以显式地将重写的成员标注为 <strong>final</strong> 。</em></p></blockquote><h3 id="3-嵌套类与内部类"><a href="#3-嵌套类与内部类" class="headerlink" title="3.嵌套类与内部类"></a>3.嵌套类与内部类</h3><p>Kotlin中没有显式修饰符的嵌套类与Java中的static嵌套类是一样的。要把它变成一个内部类来持有一个外部类的引用的话需要使用 <strong>inner</strong> 修饰符。</p><p>在Kotlin中引用外部类实例的语法也与Java不同。需要使用 <strong>this@Outer</strong> 从 <strong>Inner</strong> 类去访问 <strong>Outer</strong> 类：</p><pre><code>class Outer{    inner class Inner{        fun getOuterReference() : Outer = this@Outer    }}</code></pre><h3 id="4-密封类：定义受限的类继承结构"><a href="#4-密封类：定义受限的类继承结构" class="headerlink" title="4.密封类：定义受限的类继承结构"></a>4.密封类：定义受限的类继承结构</h3><p>为父类添加一个 <strong>sealed</strong> 修饰符，对可能创建的子类做出严格的限制。</p><p>如果你在 when 表达式中处理所有 <strong>sealed</strong> 类的子类，你就不再需要提供默认分支。注意， <strong>sealed</strong> 修饰符隐含的这个类是一个 <strong>open</strong> 类， 你不再需要显式地添加 <strong>open</strong> 修饰符。</p><h3 id="5-声明一个带非默认构造方法或属性的类"><a href="#5-声明一个带非默认构造方法或属性的类" class="headerlink" title="5.声明一个带非默认构造方法或属性的类"></a>5.声明一个带非默认构造方法或属性的类</h3><p>举个栗子：</p><pre><code>class User constructor(_nickname: String) {    val nickname : String    init{        nickname = _nickname    }}</code></pre><p>在这个例子中，可以看到两个新的Kotlin关键宇：<strong>constructor</strong> 和 <strong>init</strong> 。 <strong>constructor</strong> 关键字用来开始一个主构造方法或从构造方法的声明。 <strong>init</strong> 关键字用来引入一个初始化语句块。这种语句块包含了在类被创建时执行的代码， 并会与主构造方法一起使用。</p><blockquote><p>如果你想要确保你的类不被其他代码实例化，必须把构造方法标记为 private：</p></blockquote><pre><code>class Secretive private constructor() {}//一般这么做表示这个类是一个静态实用工具成员的容器或者是单例的</code></pre><h3 id="6-通过-getter-或-setter-访问支持字段"><a href="#6-通过-getter-或-setter-访问支持字段" class="headerlink" title="6.通过 getter 或 setter 访问支持字段"></a>6.通过 getter 或 setter 访问支持字段</h3><p>假设你想在任何对存储在属性中的数据进行修改时输出日志，你声明了一个可变属性并且在每次 setter 访问时执行额外的代码。</p><pre><code>class ·user (val name: String) {     var address: String =&quot;unspecified&quot;         set(value: String) {             println (””“ A Address was changed for $name:            &quot;$field&quot; -&gt; &quot;value&quot;.&quot;&quot;&quot;&quot;.trimIndent())            field = value        }    }</code></pre><p>可以像平常一样通过使用 user.address ＝ “new value”， 来修改一个属性的值，这其实在底层调用了 setter。</p><p>在 setter 的函数体中，使用了特殊的标识符 <strong>field</strong> 来访问支持字段的值。</p><p>如果你想修改访问器的可见性，可以像下面这样：</p><pre><code>class LengthCounter {    var counter: Int = 0     private set     //这下就不能在类外部修改这个属性了    fun addWord(word: String){        counter += word.length    }}</code></pre><h3 id="7-数据类：自动生成通用方法的实现"><a href="#7-数据类：自动生成通用方法的实现" class="headerlink" title="7.数据类：自动生成通用方法的实现"></a>7.数据类：自动生成通用方法的实现</h3><p>如果想要你的类是一个方便的数据容器，你需要重写这些方法 ： <strong>toString</strong>、 <strong>equals</strong> 和 <strong>hashCode</strong> 。在Kotlin中你不必再去生成这些方法了 。如果为你的类添加 <strong>data</strong> 修饰符，必要的方法将会自动生成好。</p><p>比如：</p><pre><code>data class Client(val name: String, val postalCode: Int)</code></pre><h3 id="8-数据类和不可变性：-copy-方法"><a href="#8-数据类和不可变性：-copy-方法" class="headerlink" title="8.数据类和不可变性： copy()方法"></a>8.数据类和不可变性： copy()方法</h3><p>为了让使用不可变对象的数据类变得更容易，Kotlin编译器为它们多生成了一个方法：一个允许 <strong>copy</strong> 类的实例的方法，并在 <strong>copy</strong> 的同时修改某些属性的值:</p><pre><code>class Client (val name: String, val postalCode: Int) {    fun copy(name: String = this.name, postalCode: Int =     this.postalCode) = Client(name, postalCode)}//使用&gt;&gt;&gt; val bob = Client(&quot;Bob”, 973293) &gt;&gt;&gt; println(bob.copy(postalCode = 382555)) </code></pre><h3 id="9-类委托：使用“by”关键字"><a href="#9-类委托：使用“by”关键字" class="headerlink" title="9.类委托：使用“by”关键字"></a>9.类委托：使用“by”关键字</h3><p>(装饰模式我还不是太了解，了解以后再记录)</p><h3 id="10-对象声明：创建单例易如反掌"><a href="#10-对象声明：创建单例易如反掌" class="headerlink" title="10.对象声明：创建单例易如反掌"></a>10.对象声明：创建单例易如反掌</h3><p>在面向对象系统设计中一个相当常见的情形就是只需要一个实例的类。在Java中，这通常通过单例模式来实现 </p><p>Kotlin 通过使用对象声明功能为这一切提供了最高级的语言支持。对象声明将类声明与该类的单一实例声明结合到了一起。 </p><pre><code>object Payroll {     val allErnployees = arrayListOf&lt;Person&gt;()    fun calculateSalary() {         for {person in allErnployees) {         ...        }    }}</code></pre><blockquote><p>对象声明通过object关键宇引入。一个对象声明可以非常高效地以一句话来定义一个类和一个该类的变量。 </p></blockquote><h3 id="11-伴生对象：工厂方法和静态成员的地盘"><a href="#11-伴生对象：工厂方法和静态成员的地盘" class="headerlink" title="11.伴生对象：工厂方法和静态成员的地盘"></a>11.伴生对象：工厂方法和静态成员的地盘</h3><p>在类中定义的对象之一可以使用一个特殊的关键字来标记：<strong>companion</strong>。如果这样做，就获得了直接通过容器类名称来访问这个对象的方法和属性的能力，不再需要显式地指明对象的名称。最终的语法看起来非常像 Java 中的静态方法调用。</p><pre><code>class A {     companion object {         fun bar() {         println (&quot;Companion object called&quot;)         }    }}&gt;&gt; A.bar() Companion object called</code></pre><p>伴生对象可以访问类中的所有private成员，包括private构造方法，它是实现工厂模式的理想选择。 </p><pre><code>class User private constructor(val nickname: String) {    companion object {        fun newSubscribingUser(email: String) =        User(email.substringBefore (&#39;@&#39;))         fun newFacebookUser(accountld: Int) =         User(getFacebookName(accountld))     }}&gt;&gt; val subscribingUser = User.newSubscribingUser (&quot;bob@gmail.com&quot;) &gt;&gt; val facebookUser = User.newFacebookUser(4) &gt;&gt; println(subscribingUser.nickname)bob</code></pre><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><ul><li>Kotlin 的接口与 Java 的相似，但是可以包含默认实现 (Java 从第8版才开始支持)和属性。</li><li>所有的声明默认都是 final 和 public 的。</li><li>要想使声明不是 final 的，将其标记为 open。</li><li>internal 声明在同一模块中可见。</li><li>嵌套类默认不是内部类。使用inner关键字来存储外部类的引用。</li><li>sealed 类的子类只能嵌套在自身的声明中（Kotlin 1.1 允许将子类放置在同一文件的任意地方）。</li><li>初始化语句块和从构造方法为初始化类实例提供了灵活性。 </li><li>使用 field 标识符在访问器方法体中引用属性的支持字段。</li><li>数据类提供了编译器生成的 equals、 hashCode、 toString、 copy 和其他方法。 </li><li>类委托帮助避免在代码中出现许多相似的委托方法。 </li><li>对象声明是 Kotlin 中定义单例类的方法。</li><li>伴生对象（与包级别函数和属性一起）替代了Java静态方法和字段定义。 </li><li>伴生对象与其他对象一样，可以实现接口，也可以拥有有扩展函数和属性。</li><li>对象表达式是 Kotlin中针对Java匿名内部类的替代品，并增加了诸如实现多个接口的能力和修改在创建对象的作用域中定义的变量的能力等功能。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin笔记(二):基础篇plus</title>
      <link href="undefined2018/10/01/Kotlin%E7%AC%94%E8%AE%B0-%E4%BA%8C-%E5%9F%BA%E7%A1%80%E7%AF%87plus/"/>
      <url>2018/10/01/Kotlin%E7%AC%94%E8%AE%B0-%E4%BA%8C-%E5%9F%BA%E7%A1%80%E7%AF%87plus/</url>
      
        <content type="html"><![CDATA[<h3 id="1-顶层函数和属性"><a href="#1-顶层函数和属性" class="headerlink" title="1.顶层函数和属性"></a>1.顶层函数和属性</h3><p>在Kotlin中，可以把那些工具类里的函数直接放到代码文件的顶层，不用从属于任何的类。这些放在文件顶层的函数依然是包内的成员，如果你需要从包外访问它，则需要import，但不再需要额外包一层</p><h3 id="2-给别人的类添加方法：扩展函数和属性"><a href="#2-给别人的类添加方法：扩展函数和属性" class="headerlink" title="2.给别人的类添加方法：扩展函数和属性"></a>2.给别人的类添加方法：扩展函数和属性</h3><p>扩展函数非常简单，它就是一个类的成员函数，不过定义在类的外面。举个例子：</p><pre><code>package strings fun String.lastChar(): Char = this.get(this.length - 1) //this可以省略</code></pre><a id="more"></a> <p>从某种意义上说，你已经为String类添加了自己的方法。即使字符串不是代码的一部分，也没有类的源代码，你仍然可以在自己的项目中根据需要去扩展方法。</p><blockquote><p>注意，扩展函数并不允许你打破它的封装性。和在类内部定义的方法不同的是，扩展函数不能访私有的或者是受保护的成员。 </p><p>对于你定义的一个扩展函数，它不会自动地在整个目范围内生效。相反，如果你要使用它，需要进行导入</p><p>扩展函数并不存在重写，因为Kotiin会把它们当作静态函数对待</p></blockquote><p>下面是声明一个扩展属性：</p><pre><code>val String.lastChar: Char get() = get(length - 1) </code></pre><p>可以看到，和扩展函数一样，扩展属性也像接收者的一个普通的成员属性一样。这里，必须定义getter函数，因为没有支持字段，因此没有默认getter的实现。同理，初始化也不可以：因为没有地方存储初始值。</p><pre><code>注意，当你需要从Java中访问扩展属性的时候，应该显式地调用它的getter函数</code></pre><h3 id="3-可变参数：让函数支持任意数量的参数"><a href="#3-可变参数：让函数支持任意数量的参数" class="headerlink" title="3.可变参数：让函数支持任意数量的参数"></a>3.可变参数：让函数支持任意数量的参数</h3><p>当你在调用一个函数来创建列表的时候，可以传递任意个数的参数给它：</p><pre><code>val list= list0f(2, 3, 5, 7, 11) </code></pre><p>Kotlin的可变参数与Java类似，但语法略有不同：Kotlin在该类型之后不会再使用三个点，而是在参数上使用vararg修饰符。</p><p>Kotlin和Java 之间的另一个区别是，当需要传递的参数己经包装在数组中时，调用该函数的语法。在Java中，可以按原样传递数组，而Kotlin 则要求你显式地解包数组，以便每个数组元素在函数中能作为单独的参数来调用。从技术的角度来讲，这个功能被称为展开运算符，而使用的时候，不过是在对应的参数前面放一个*：</p><pre><code>fun main(args: Array&lt;String&gt;）{val list = listOf(&quot;args:”,*args) println(list) }</code></pre><h3 id="4-键值对的处理：中缀调用和解构声明"><a href="#4-键值对的处理：中缀调用和解构声明" class="headerlink" title="4.键值对的处理：中缀调用和解构声明"></a>4.键值对的处理：中缀调用和解构声明</h3><p>可以使用 mapOf 函数来创建 map:</p><pre><code>val map= mapOf(l to &quot;one&quot;， 7 to &quot;seven&quot;， 53 to &quot;fifty-three&quot;)</code></pre><p>这行代码中的单词to不是内置的结构，而是一种特殊的函数调用，被称为中缀调用。 </p><p>在中缀调用中，没有添加额外的分隔符，函数名称是直接放在目标对象名称和 参数之间的。以下两种调用方式是等价的：</p><pre><code>1.to(&quot;one&quot;)1 to &quot;one&quot;</code></pre><p>中缀调用可以与只有一个参数的函数一起使用，无论是普通的函数还是扩展函 数。要允许使用中缀符号调用函数，需要使用 infix 修饰符来标记它。下面是一个 简单的 to 函数的声明：</p><pre><code>infix fun Any.to(other: Any) = Pair(this, other)</code></pre><p>to 函数是一个扩展函数，可以创建一对任何元素，这意味着它是泛型接收者的 扩展：可以使用 1 to “one” 、”one” to 1、list to list.size()等写法。 </p><h3 id="5-让你的代码更整洁：局部函数和扩展"><a href="#5-让你的代码更整洁：局部函数和扩展" class="headerlink" title="5.让你的代码更整洁：局部函数和扩展"></a>5.让你的代码更整洁：局部函数和扩展</h3><p>Kotlin可以在函数中嵌套类中提取的函数。这样，既可以获得所需的结构，也无须额外的语法开销。</p><p>举个栗子：</p><pre><code>class User(val id: Int, val name: String, val address: String) fun saveUser(user : User){    if(user.name.isEmpty()){        ...    }    if(user.address.isEmpty()){        ...    }    //保存...}</code></pre><p>如果将验证代码放到局部函数中，可以摆脱重复，并保持清晰的代码结构，可以这样做 ：</p><pre><code>class User(val id: Int, val name: String, val address: String) fun saveUser(user : User){    fun validate(user: User, value: String, fieldName: String){        if(value.isEmpty()){            ...        }    }    validate (user, user.name, &quot;Name&quot;)    validate (user, user.address, &quot;Address&quot;)    //保存...}</code></pre><p>上面的代码看起来好多了，而且局部函数可以访问所在函数中的所有参数和变量。 我们可以利用这一点，去掉冗余的User参数，这里就不再演示了</p><p>我们可以继续改进，把验证逻辑放到 User 类的扩展函数中。</p><pre><code>class User(val id: Int, val name: String, val address: String) fun User.validateBeforeSave(){    fun validate(value: String, fieldName: String){        if(value.isEmpty()){            ...        }    }    validate (user.name, &quot;Name&quot;)    validate (user.address, &quot;Address&quot;)}fun saveUser(user : User){    user.validateBeforeSave()    //保存...}</code></pre><p><strong>小结：</strong></p><ul><li><p>Kotlin没有定义自己的集合类，而是在Java集合类的基础上提供了更丰富的API。</p></li><li><p>Kotlin可以给函数参数定义默认值，这样大大降低了重载函数的必要性，而且命名参数让多参数函数的调用更加易读。</p></li><li><p>Kotlin允许更灵活的代码结构：函数和属性都可以直接在文件中声明，而不仅仅是在类中作为成员。</p></li><li><p>Kotlin可以用扩展函数和属性来扩展任何类的API，包括在外部库中定义的类，而不需要修改其源代码，也没有运行时开销。 </p></li><li><p>中缀调用提供了处理单个参数的，类似调用运算符方法的简明语法。</p></li><li><p>Kotlin为普通字符串和正则表达式都提供了大量的方便字符串处理的函数。 </p></li><li><p>三重引号的字符串提供了一种简洁的方式，解决了原本在Java中需要进行大量啰嗦的转义和宇符串连接的问题。</p></li><li><p>局部函数帮助你保持代码整洁的同时，避免重复。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论国庆节的几种过法</title>
      <link href="undefined2018/10/01/%E8%AE%BA%E5%9B%BD%E5%BA%86%E8%8A%82%E7%9A%84%E5%87%A0%E7%A7%8D%E8%BF%87%E6%B3%95/"/>
      <url>2018/10/01/%E8%AE%BA%E5%9B%BD%E5%BA%86%E8%8A%82%E7%9A%84%E5%87%A0%E7%A7%8D%E8%BF%87%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 中秋刚过才一个星期，国庆就来了。这七天小长假可不能就这样寥寥草草，得好好准备准备看看怎么过才行！</p></blockquote><p><strong>下面就介绍一下国庆节的几种过法</strong></p><a id="more"></a> <h2 id="一、干粮"><a href="#一、干粮" class="headerlink" title="一、干粮"></a>一、干粮</h2><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%AE%BA%E5%9B%BD%E5%BA%86%E8%8A%82%E7%9A%84%E5%A5%BD%E5%87%A0%E7%A7%8D%E8%BF%87%E6%B3%95/%E5%B9%B2%E7%B2%AE.jpg" alt="image"></p><p>干粮是必不可少的一部分，有了这个，你就不必担心饿死了！</p><h2 id="二、游戏"><a href="#二、游戏" class="headerlink" title="二、游戏"></a>二、游戏</h2><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%AE%BA%E5%9B%BD%E5%BA%86%E8%8A%82%E7%9A%84%E5%A5%BD%E5%87%A0%E7%A7%8D%E8%BF%87%E6%B3%95/%E6%B8%B8%E6%88%8F.jpg" alt="image"></p><p>所谓饱暖思淫欲，当你不必为了食物而犯愁之后，你就可以思考自身的娱乐需求了。无论是召唤师峡谷，还是艾泽拉斯大陆，都有承载你欢乐的地方，如果这些地方你不满意，还剩下索尼微软任天堂好些游戏平台呢！</p><h2 id="三、阅读"><a href="#三、阅读" class="headerlink" title="三、阅读"></a>三、阅读</h2><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%AE%BA%E5%9B%BD%E5%BA%86%E8%8A%82%E7%9A%84%E5%A5%BD%E5%87%A0%E7%A7%8D%E8%BF%87%E6%B3%95/%E9%98%85%E8%AF%BB.jpg" alt="image"></p><p>劳逸结合一直是一种非常良好的生活方式，游戏玩过头了反而会荒废你的大脑，这时候应该静下心来看看书，文学类、科学类、教材类，各式各样，应有尽有。</p><h2 id="四、运动"><a href="#四、运动" class="headerlink" title="四、运动"></a>四、运动</h2><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%AE%BA%E5%9B%BD%E5%BA%86%E8%8A%82%E7%9A%84%E5%A5%BD%E5%87%A0%E7%A7%8D%E8%BF%87%E6%B3%95/%E8%BF%90%E5%8A%A8.jpg" alt="image"></p><p>一个人身体要是不好，那多少事情都干不了，学习、娱乐之余，可别忘了运动，毕竟90后的年轻人没几个希望中年发福吧！</p><h2 id="五、出行"><a href="#五、出行" class="headerlink" title="五、出行"></a>五、出行</h2><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%AE%BA%E5%9B%BD%E5%BA%86%E8%8A%82%E7%9A%84%E5%A5%BD%E5%87%A0%E7%A7%8D%E8%BF%87%E6%B3%95/%E9%AA%91%E8%A1%8C.jpg" alt="image"></p><p>在家待久了会生霉的，所以出去转转还能让自己保持新鲜！</p><p>而且节日出行也是蛮合理的一件事，如果你真有一颗不安分的心，外面的人山人海又怎能拦得住你？</p><hr><p><strong>那么，国庆节的过法就谈到这里！我要开始享受国庆了！</strong></p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%AE%BA%E5%9B%BD%E5%BA%86%E8%8A%82%E7%9A%84%E5%A5%BD%E5%87%A0%E7%A7%8D%E8%BF%87%E6%B3%95/001.jpeg" alt="image"></p><hr><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%AE%BA%E5%9B%BD%E5%BA%86%E8%8A%82%E7%9A%84%E5%A5%BD%E5%87%A0%E7%A7%8D%E8%BF%87%E6%B3%95/002.png" alt="image"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 逢年过节 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin笔记(一):基础篇</title>
      <link href="undefined2018/09/30/Kotlin%E7%AC%94%E8%AE%B0-%E4%B8%80-%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
      <url>2018/09/30/Kotlin%E7%AC%94%E8%AE%B0-%E4%B8%80-%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 在2017年的Google开发者大会上，Kotlin正式作为Android的官方开发语言闪亮登场。而现在已经到了2018年的下半年末，身为一名Android开发者，如果不会一点Kotlin，总感觉少了什么。  </p><p>于是乎，我准备动手学一学这门“年轻”的新语言了。不过新学一些东西往往会因为知识的消化需要时间而导致知识接收的效率不高，所以这时候好记性不如烂笔头的优势才得以体现嘛！  </p><p>所以，初学阶段，我还是准备记一记笔记，这样也许会对我学这门语言有所帮助吧？!</p></blockquote><p>关于Kotlin的官方文档，地址如下：</p><p><a href="https://www.kotlincn.net/docs/reference/" target="_blank" rel="noopener">Kotlin学习</a><br><a id="more"></a> </p><h3 id="1-在-Kotlin-中，if是表达式，而不是语句。"><a href="#1-在-Kotlin-中，if是表达式，而不是语句。" class="headerlink" title="1.在 Kotlin 中，if是表达式，而不是语句。"></a>1.在 Kotlin 中，if是表达式，而不是语句。</h3><p> 语句和表达式的区别在于，表达式有值，并且能作为另一个表达式的一部分使用；而语句总是包围着它的代码块中的顶层元素，并且没有自己的值。</p><ul><li>在Java中，所有的控制结构都是语句。而在Kotlin中，除了循环（ for, do 和 do/while ）以外大多数控制结构都是 表达式。<br>这种结合控制结构和其他表达式的能力让你可以简明扼要地表示许多 常见的模式，稍后你会在本书中看到这些内容。</li><li>另一方面，Java中的赋值操作是表达式，在Kotlin中反而变成了语句。这有助于避免比较和赋值之间的混淆，而这种混淆是常见的错误来源。</li></ul><h3 id="2-声明变量的关键字有两个-："><a href="#2-声明变量的关键字有两个-：" class="headerlink" title="2.声明变量的关键字有两个 ："></a>2.声明变量的关键字有两个 ：</h3><ul><li>val （来自 value） 一一不可变引用。使用 val 声明的变量不能在初始化之 后再次赋值。它对应的是 Java 的 final 变量。  </li><li>var （来自 variable） 一一可变引用。这种变量的值可以被改变。这种声明对 应的是普通（非 final）的 Java 变量。</li></ul><h3 id="3-局部变量的引用"><a href="#3-局部变量的引用" class="headerlink" title="3.局部变量的引用"></a>3.局部变量的引用</h3><p>和许多脚本语言一样， Kotlin 让你可 以在字符串字面值中引用局部变量，只需要在变量名称前面加上字符$。</p><p>这等价于 Java 中的字符串连接（ “Hello,”+ name ＋”！”），效率一样但是更紧凑。</p><pre><code>fun main(args: Array&lt;String&gt;) {    val name = if(args.size &gt; 0) args[0] else &quot;Kotlin&quot;    println(&quot;Hello, $name !&quot;)}</code></pre><p>还可以引用更复杂的表达式，而不是仅限于简单的变量名称，只需要把表达式 用花括号括起来.</p><h3 id="4-在Java中可以用switch语句完成的，而Kotlin-对应的结构是when"><a href="#4-在Java中可以用switch语句完成的，而Kotlin-对应的结构是when" class="headerlink" title="4.在Java中可以用switch语句完成的，而Kotlin 对应的结构是when"></a>4.在Java中可以用switch语句完成的，而Kotlin 对应的结构是when</h3><pre><code>fun getMnemonic(color: Color) = when (color) { Color . RED -&gt;”Richard&quot; Color.ORANGE -&gt;”Of” Color.YELLOW -&gt;”York&quot; Color .GREEN -&gt;”Gave” Color.BLUE -&gt;”Battle&quot; Color ．工NDIGO -&gt;”In” Color.VIOLET -&gt;”Vain }</code></pre><p>  在一个 when 分支上合并多个选项：</p><pre><code>fun getWarmth(color: Color) = when(color) {Color.RED, Color.ORANGE, Color.YELLOW - &gt; ”warm”Color.GREEN -&gt; ”neutral”Color.BLUE, Color.INDIGO, Color.VIOLET -&gt;”cold”}</code></pre><p>上面的代码中，也可以导入枚举常量后不用限定词就可以访问。比如去掉花括号里的Color也是可以的。</p><blockquote><p>Kotlin中的when结构比Java中的switch强大得多。switch要求必须使用常量（枚举常量、字符串或者数字字面值）作为分支条件，和它不一样， when允许使用任何对象。</p></blockquote><h3 id="5-类型判断"><a href="#5-类型判断" class="headerlink" title="5.类型判断"></a>5.类型判断</h3><p>在Kotlin中，你要使用is检查来判断一个变量是否是某种类型。is检查和Java中的instanceOf相似，不过在instanceOf检查之后还需要显式地加上类型转换。</p><p>在Kotlin中，编译器帮你完成了这些工作。如果你检查过一个变量是某种类型，后面就不再需要转换它，可以就把它当作你检查过的类型使用。</p><p>使用as关键字来表示到特定类型的显式转换；</p><h3 id="6-循环中的”in”关键字"><a href="#6-循环中的”in”关键字" class="headerlink" title="6.循环中的”in”关键字"></a>6.循环中的”in”关键字</h3><p>Kotlin里面关键字“in”有许多作用，比如检查区间的成员；作为when的分支；在for循环中使用等。关于in如何在list中使用，下章再介绍</p><h3 id="7-关于”try”"><a href="#7-关于”try”" class="headerlink" title="7.关于”try”"></a>7.关于”try”</h3><p>Kotlin中的try关键字就像if和when一样,引入了一个表达式，可以把它的值赋给一个变量。不同于if，你总是需要用花括号把语句主体括起来。和其他语句一样，如果其主体包含多个表达式，那么整个 try 表达式的值就是最后一个表达式的值。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bugly热修复使用及多渠道打包</title>
      <link href="undefined2018/09/26/Bugly%E7%83%AD%E4%BF%AE%E5%A4%8D%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85/"/>
      <url>2018/09/26/Bugly%E7%83%AD%E4%BF%AE%E5%A4%8D%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="头"><a href="#头" class="headerlink" title="头"></a>头</h2><p>不知道你是否遇到过这个情况，项目上线后或者开始给别人使用的时候，冷不丁的冒出个Bug，这时候首先要干嘛？</p><p><strong>先看崩溃日志啊</strong></p><p>看完崩溃日志你知道了造成崩溃的原因，然后干嘛？</p><p><strong>开始甩锅啊</strong></p><p>当查明了是谁造成的这个崩溃后，你发现不是你的问题，于是你心中一乐，长舒一口气<a id="more"></a> ，仰天大笑：码海沉浮又几载，我辈岂是蓬蒿人；笑完便准备躺床上睡觉去——秋豆麻袋，是不是忘了什么东西？</p><p>是的，即使你发现了问题，并且找到了问题的来源，这时候还差一步：解决问题的办法！如何解决？</p><p><strong>发布新版本？</strong></p><p>这样不觉得很麻烦吗？特别是如果一个项目处于初期阶段，Bug是想甩都甩不掉的，如果每发现一次崩溃，都需要靠发布一个新版本去解决的话，那未免就太麻烦了。不光是开发者麻烦，使用者也会因为频繁的升级而不耐烦（just like me），那问题又回来了，如何解决？</p><p><strong>热修复啊</strong></p><p>通过线上修复Bug，让用户在神不知鬼不觉的情况下就进行了一次应用更新，麻麻再也不用担心App崩溃啦！（不存在的）</p><p>热修复还有个隐藏的好处，那就是在测试人员不够（开发兼测试），测试机型不够的情况下可以显著改善App的崩溃率。好吧，准备开始使用吧。</p><h2 id="身"><a href="#身" class="headerlink" title="身"></a>身</h2><h3 id="一、为什么要用Bugly"><a href="#一、为什么要用Bugly" class="headerlink" title="一、为什么要用Bugly"></a>一、为什么要用Bugly</h3><p>市面上关于热修复和崩溃日志监测的相关技术和SDK种类各不相同，为什么偏偏要用Bugly呢？</p><ul><li>可以获取到App崩溃日志</li><li>可以集成Think热修复</li><li>界面好看，方便管理版本</li><li>免费</li><li>（凑巧就用了这一款，其他的都没有用过）</li></ul><p>基于以上原因，最后就使用了Bugly去解决上面提到过的问题；</p><h3 id="二、Bugly热更新接入流程"><a href="#二、Bugly热更新接入流程" class="headerlink" title="二、Bugly热更新接入流程"></a>二、Bugly热更新接入流程</h3><p>其实关于Bugly热更新的接入流程，官方的文档介绍的非常详细，对新手比较友好，我第一次使用也是直接参照的文档，下面是官方文档的地址：</p><p><a href="https://bugly.qq.com/docs/user-guide/instruction-manual-android-hotfix/?v=20180709165613" target="_blank" rel="noopener">【Bugly Android热更新使用指南】</a></p><p>虽然官方有例子，这里还是写了一个简化版，也方便以后哪天自己忘记了依旧能快速使用：</p><h4 id="第一步：添加依赖插件"><a href="#第一步：添加依赖插件" class="headerlink" title="第一步：添加依赖插件"></a>第一步：添加依赖插件</h4><p>在你的项目更目录下的“build.gradle”中添加：</p><pre><code>buildscript {    repositories {        jcenter()    }    dependencies {        // tinkersupport插件, 其中lastest.release指拉取最新版本，也可以指定明确版本号，例如1.0.4        classpath &quot;com.tencent.bugly:tinker-support:1.1.2&quot;    }}</code></pre><p>在写这篇文章的时候，最新的版本就是1.1.2</p><h4 id="第二步：配置依赖插件"><a href="#第二步：配置依赖插件" class="headerlink" title="第二步：配置依赖插件"></a>第二步：配置依赖插件</h4><h5 id="gradle配置"><a href="#gradle配置" class="headerlink" title="gradle配置"></a>gradle配置</h5><p>在app module的“build.gradle”文件中添加（示例配置）：</p><pre><code>...// 依赖插件脚本apply from: &#39;tinker-support.gradle&#39;android {        defaultConfig {          ndk {            //设置支持的SO库架构            abiFilters &#39;armeabi&#39; //, &#39;x86&#39;, &#39;armeabi-v7a&#39;, &#39;x86_64&#39;, &#39;arm64-v8a&#39;          }        }      }      dependencies {         implementation &#39;com.android.support:multidex:1.0.1&#39;        // 多dex配置        //注释掉原有bugly的仓库        //compile &#39;com.tencent.bugly:crashreport:latest.release&#39;//其中latest.release指代最新版本号，也可以指定明确的版本号，例如1.3.4        implementation &#39;com.tencent.bugly:crashreport_upgrade:1.3.5&#39;        // 指定tinker依赖版本（注：应用升级1.3.5版本起，不再内置tinker）        implementation &#39;com.tencent.tinker:tinker-android-lib:1.9.6&#39;        implementation &#39;com.tencent.bugly:nativecrashreport:latest.release&#39;        //其中latest.release指代最新版本号，也可以指定明确的版本号，例如2.2.0      }</code></pre><p>在这个版本的SDK里面，已经集成了崩溃日志上传的功能哦！</p><h5 id="tinker-support-gradle的配置"><a href="#tinker-support-gradle的配置" class="headerlink" title="tinker-support.gradle的配置"></a>tinker-support.gradle的配置</h5><p>接下来，你要在app module目录下创建另外一个gradle文件，命名为“tinker-support.gradle”，然后对它进行配置：</p><pre><code>apply plugin: &#39;com.tencent.bugly.tinker-support&#39;def bakPath = file(&quot;${buildDir}/bakApk/&quot;)/** * 此处填写每次构建生成的基准包目录 */def baseApkDir = &quot;app-0921-14-52-06&quot;/** * 对于插件各参数的详细解析请参考 */tinkerSupport {    // 开启tinker-support插件，默认值true    enable = true    // 指定归档目录，默认值当前module的子目录tinker    autoBackupApkDir = &quot;${bakPath}&quot;    // 是否启用覆盖tinkerPatch配置功能，默认值false    // 开启后tinkerPatch配置不生效，即无需添加tinkerPatch    overrideTinkerPatchConfiguration = true    // 编译补丁包时，必需指定基线版本的apk，默认值为空    // 如果为空，则表示不是进行补丁包的编译    // @{link tinkerPatch.oldApk }    baseApk = &quot;${bakPath}/${baseApkDir}/app-release.apk&quot;    // 对应tinker插件applyMapping    baseApkProguardMapping = &quot;${bakPath}/${baseApkDir}/app-release-mapping.txt&quot;    // 对应tinker插件applyResourceMapping    baseApkResourceMapping = &quot;${bakPath}/${baseApkDir}/app-release-R.txt&quot;    // 构建基准包和补丁包都要指定不同的tinkerId，并且必须保证唯一性    tinkerId = &quot;1.0.1-patch&quot;                //tinkerId = &quot;1.0.1-patch&quot;            tinkerId = &quot;1.0.1-base&quot;    // 构建多渠道补丁时使用    // buildAllFlavorsDir = &quot;${bakPath}/${baseApkDir}&quot;    // 是否启用加固模式，默认为false.(tinker-spport 1.0.7起支持）    // isProtectedApp = true    // 是否开启反射Application模式    enableProxyApplication = false    // 是否支持新增非export的Activity（注意：设置为true才能修改AndroidManifest文件）    supportHotplugComponent = true}/** * 一般来说,我们无需对下面的参数做任何的修改 * 对于各参数的详细介绍请参考: * https://github.com/Tencent/tinker/wiki/Tinker-%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97 */tinkerPatch {    //oldApk =&quot;${bakPath}/${appName}/app-release.apk&quot;    ignoreWarning = false    useSign = true    dex {        dexMode = &quot;jar&quot;        pattern = [&quot;classes*.dex&quot;]        loader = []    }    lib {        pattern = [&quot;lib/*/*.so&quot;]    }    res {        pattern = [&quot;res/*&quot;, &quot;r/*&quot;, &quot;assets/*&quot;, &quot;resources.arsc&quot;, &quot;AndroidManifest.xml&quot;]        ignoreChange = []        largeModSize = 100    }    packageConfig {    }    sevenZip {        zipArtifact = &quot;com.tencent.mm:SevenZip:1.1.10&quot;//        path = &quot;/usr/local/bin/7za&quot;    }    buildConfig {        keepDexApply = false        //tinkerId = &quot;1.0.1-base&quot;        //applyMapping = &quot;${bakPath}/${appName}/app-release-mapping.txt&quot; //  可选，设置mapping文件，建议保持旧apk的proguard混淆方式        //applyResourceMapping = &quot;${bakPath}/${appName}/app-release-R.txt&quot; // 可选，设置R.txt文件，通过旧apk文件保持ResId的分配    }}</code></pre><p>这里面的配置比较多，一开始看还是有点儿眼花缭乱的，所以得慢慢来；</p><p>这里对其中的几点进行说明：</p><ul><li><em>baseApkDir</em> ： 这里填写每次构建生成的基准包目录，每次打包的时候，都会有新的目录和新的基准包生成，但是只有你打算发布的那一个的目录才是有效的。</li><li><em>tinkerId</em> ： 构建基准包和补丁包都要指定不同的tinkerId，并且必须保证唯一性。比如你的第一个基准包打包的时候可以把这个id设置为“1.0.0-base”，当你想打包热修复补丁包的时候，需要把这个id换成1.0.0-patch。</li></ul><p>更详细的配置项参考：<a href="https://bugly.qq.com/docs/utility-tools/plugin-gradle-hotfix/" target="_blank" rel="noopener">tinker-support配置说明</a></p><h4 id="第三步：初始化SDK"><a href="#第三步：初始化SDK" class="headerlink" title="第三步：初始化SDK"></a>第三步：初始化SDK</h4><p>上面的“tinker-support.gradle”中的enableProxyApplication属性设置的是false，是Tinker推荐的接入方式。</p><h5 id="自定义Application，当enableProxyApplication为false的情况"><a href="#自定义Application，当enableProxyApplication为false的情况" class="headerlink" title="自定义Application，当enableProxyApplication为false的情况"></a>自定义Application，当enableProxyApplication为false的情况</h5><pre><code>public class SampleApplication extends TinkerApplication {    public SampleApplication() {        super(ShareConstants.TINKER_ENABLE_ALL, &quot;xxx.xxx.SampleApplicationLike&quot;,                &quot;com.tencent.tinker.loader.TinkerLoader&quot;, false);    }}</code></pre><p><strong>SampleApplicationLike</strong>需要是自定义的继承<strong>DefaultApplicationLike</strong>的类，不要忘了在<strong>AndroidManifest.xml</strong>中声名上面的这个Application哦。</p><pre><code>public class SampleApplicationLike extends DefaultApplicationLike {    public static final String TAG = &quot;Tinker.SampleApplicationLike&quot;;    public SampleApplicationLike(Application application, int tinkerFlags,                                 boolean tinkerLoadVerifyFlag, long applicationStartElapsedTime,                                 long applicationStartMillisTime, Intent tinkerResultIntent) {        super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent);    }    @Override    public void onCreate() {        super.onCreate();        // 这里实现SDK初始化，appId替换成你的在Bugly平台申请的appId        // 调试时，将第三个参数改为true        Bugly.init(getApplication(), &quot;900029763&quot;, false);    }    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)    @Override    public void onBaseContextAttached(Context base) {        super.onBaseContextAttached(base);        // you must install multiDex whatever tinker is installed!        MultiDex.install(base);        // 安装tinker        // TinkerManager.installTinker(this); 替换成下面Bugly提供的方法        Beta.installTinker(this);    }    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)    public void registerActivityLifecycleCallback(Application.ActivityLifecycleCallbacks callbacks) {        getApplication().registerActivityLifecycleCallbacks(callbacks);    }}</code></pre><p>上面需要注意的是在“onCreate()”方法中进行初始化的时候，填入的appId是你在Bugly创建的项目的Appid，其他地方基本上不用改了</p><h5 id="自定义Application，当enableProxyApplication为true的情况"><a href="#自定义Application，当enableProxyApplication为true的情况" class="headerlink" title="自定义Application，当enableProxyApplication为true的情况"></a>自定义Application，当enableProxyApplication为true的情况</h5><p>这种的接入方式要简单许多，无须你改造Application</p><pre><code>public class MyApplication extends Application {    @Override    public void onCreate() {        super.onCreate();        // 这里实现SDK初始化，appId替换成你的在Bugly平台申请的appId        // 调试时，将第三个参数改为true        Bugly.init(this, &quot;900029763&quot;, false);    }    @Override    protected void attachBaseContext(Context base) {        super.attachBaseContext(base);        // you must install multiDex whatever tinker is installed!        MultiDex.install(base);        // 安装tinker        Beta.installTinker();    }}</code></pre><h4 id="第四步：AndroidManifest-xml配置"><a href="#第四步：AndroidManifest-xml配置" class="headerlink" title="第四步：AndroidManifest.xml配置"></a>第四步：AndroidManifest.xml配置</h4><h5 id="1-权限配置："><a href="#1-权限配置：" class="headerlink" title="1.权限配置："></a>1.权限配置：</h5><pre><code>&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.READ_LOGS&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;</code></pre><h5 id="2-Activity配置："><a href="#2-Activity配置：" class="headerlink" title="2.Activity配置："></a>2.Activity配置：</h5><pre><code>&lt;activity    android:name=&quot;com.tencent.bugly.beta.ui.BetaActivity&quot;    android:configChanges=&quot;keyboardHidden|orientation|screenSize|locale&quot;    android:theme=&quot;@android:style/Theme.Translucent&quot; /&gt;</code></pre><h5 id="3-配置FileProvider"><a href="#3-配置FileProvider" class="headerlink" title="3.配置FileProvider"></a>3.配置FileProvider</h5><pre><code>注意：如果您想兼容Android N或者以上的设备，必须要在AndroidManifest.xml文件中配置FileProvider来访问共享路径的文件。</code></pre><pre><code>        &lt;!--热更新需要的Provider--&gt;        &lt;provider            android:name=&quot;android.support.v4.content.FileProvider&quot;            android:authorities=&quot;${applicationId}.fileProvider&quot;            android:exported=&quot;false&quot;            android:grantUriPermissions=&quot;true&quot;&gt;            &lt;meta-data                android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;                android:resource=&quot;@xml/provider_paths&quot;/&gt;        &lt;/provider&gt;</code></pre><p>在res目录新建xml文件夹，创建provider_paths.xml文件如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;paths xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;!-- /storage/emulated/0/Download/${applicationId}/.beta/apk--&gt;    &lt;external-path name=&quot;beta_external_path&quot; path=&quot;Download/&quot;/&gt;    &lt;!--/storage/emulated/0/Android/data/${applicationId}/files/apk/--&gt;    &lt;external-path name=&quot;beta_external_files_path&quot; path=&quot;Android/data/&quot;/&gt;&lt;/paths&gt;</code></pre><h4 id="第五步：混淆配置"><a href="#第五步：混淆配置" class="headerlink" title="第五步：混淆配置"></a>第五步：混淆配置</h4><p>为了避免混淆SDK，在Proguard混淆文件中增加以下配置：</p><pre><code>-dontwarn com.tencent.bugly.**-keep public class com.tencent.bugly.**{*;}# tinker混淆规则-dontwarn com.tencent.tinker.**-keep class com.tencent.tinker.** { *; }</code></pre><h3 id="三、打包"><a href="#三、打包" class="headerlink" title="三、打包"></a>三、打包</h3><p>当上面的环境配置都没有问题之后，就可以进行打包了。</p><p>打包之前，你还得配置一下编译正式版apk所需要的<strong>keystore.jks</strong>文件，这个文件怎么创建的就不介绍了，这里主要介绍一下如何配置：</p><p>在app moudle目录下的“build.gradle”中配置：</p><pre><code>android {    signingConfigs {        release {            keyAlias &#39;xxxxxxxx&#39;            keyPassword &#39;xxxxxxxx&#39;            storeFile file(&#39;../keystore.jks&#39;)            storePassword &#39;xxxxxxxx&#39;        }    }    ...    buildTypes {        release {            minifyEnabled true            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;            signingConfig signingConfigs.release        }    }}</code></pre><p>其中的各项参数就不必做说明了</p><p>然后就是打包过程<img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Bugly%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/bugly-001.png" alt="image"></p><p><strong>打包过程中需要注意之前提到过的tinkerId的配置，以及目录的配置，很重要哦！</strong></p><p>生成的基准包会在这个目录</p><p><img src="https://bugly.qq.com/docs/img/hotfix/android/Snip20170209_2.png?v=20180709165613" alt="image"></p><p>生成的补丁包会在这个目录</p><p><img src="https://bugly.qq.com/docs/img/hotfix/android/1479216059696.png?v=20180709165613" alt="image"></p><p>然后就准备开始使用吧</p><h3 id="四、使用"><a href="#四、使用" class="headerlink" title="四、使用"></a>四、使用</h3><p>找到你创建的产品，然后进入到下面的界面</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Bugly%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/bugly-002.png" alt="image"></p><p>接着，发布新补丁吧，看一看效果<br><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Bugly%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/bugly-003.png" alt="image"></p><p>具体的效果可以自行尝试一下，不过有时候你会遇到上传不成功的情况，一般下发后要过5到10分钟才会生效（可能是我的网络问题），如果太久没效果，应该是哪里出问题了</p><h2 id="尾"><a href="#尾" class="headerlink" title="尾"></a>尾</h2><p>前面的所有操作都尝试过后，接下来你可能就会面临新的需求了。比如说，多渠道打包的实现，比较旧的办法是通过productFlavors去实现分别打包，不过这样会有一个弊端，即有多少渠道打包流程就执行多少次，这样效率显然是不够的；</p><p>于是乎，新的打包方案出来了：</p><h3 id="使用Walle进行多渠道打包"><a href="#使用Walle进行多渠道打包" class="headerlink" title="使用Walle进行多渠道打包"></a>使用Walle进行多渠道打包</h3><p>下面是Walle的github地址：</p><p><a href="https://github.com/Meituan-Dianping/walle" target="_blank" rel="noopener">Walle（瓦力）：Android Signature V2 Scheme签名下的新一代渠道包打包神器</a></p><p>它的接入文档写的也十分友好，接下来实际操作一遍：</p><h4 id="Walle的Gradle接入"><a href="#Walle的Gradle接入" class="headerlink" title="Walle的Gradle接入"></a>Walle的Gradle接入</h4><p>在项目根目录的 <strong>build.gradle</strong> 中添加依赖：</p><pre><code>buildscript {    dependencies {        classpath &#39;com.meituan.android.walle:plugin:1.1.6&#39;    }}</code></pre><p>然后在app module中的 <strong>build.gradle</strong> 添加：</p><pre><code>apply plugin: &#39;walle&#39;dependencies {    compile &#39;com.meituan.android.walle:library:1.1.6&#39;}</code></pre><p>并进行插件配置</p><pre><code>walle {    // 指定渠道包的输出路径    apkOutputFolder = new File(&quot;${project.buildDir}/outputs/channels&quot;);    // 定制渠道包的APK的文件名称    apkFileNameFormat = &#39;${appName}-${packageName}-${channel}-${buildType}-v${versionName}-${versionCode}-${buildTime}.apk&#39;;    // 渠道配置文件    channelFile = new File(&quot;${project.getProjectDir()}/channel&quot;)}</code></pre><p>接着在app module目录下创建一个文件，和上面配置中要保持一致，就叫 <strong>channel</strong></p><pre><code>360yingyongbaobaiduwandoujiaxiaomioppolenovohuaweidefault_channel# 打包命令 gradlew clean assembleReleaseChannels  或者 gradlew assembleReleaseChannels</code></pre><p>最后，在你的Application中的<strong>onCreate</strong>方法里添加：</p><pre><code>        String channel = WalleChannelReader.getChannel(getApplication());        Bugly.setAppChannel(getApplication(), channel);</code></pre><p>如果你实现的是<strong>SampleApplicationLike</strong>，也是在它的<strong>onCreate</strong>方法里添加即可。</p><p>接下来通过运行上面的打包命令或者通过图中的手动操作，都是可以打包的</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Bugly%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/bugly-004.png" alt="image"></p><h2 id="末"><a href="#末" class="headerlink" title="末"></a>末</h2><p>至此，基本上整个配置流程就到此结束!!!</p><p>不过有一个问题我一直不知道如何解决，就是打包基准包的命名，在 <strong>tinker-support.gradle</strong> 进行配置是不起效果的，试了好久都没效果，看来还得交给其他小伙伴们解决了</p><p><em>那么</em></p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Bugly%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/zaihui.png" alt="image"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发者编写自己的API接口（下）</title>
      <link href="undefined2018/08/14/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>2018/08/14/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上一篇<a href="https://oldchen.top/2018/08/05/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="noopener">Android开发者编写自己的API接口（上）</a>中，已经介绍了如何搭建一个基本的开发环境，以及接口的编写，最后是能够成功运行的。</p><p>这一篇将更进一步，主要解决下面两个问题：</p><ul><li>①：如何让后台项目运行在TomCat上</li><li>②：如何在云服务器上部署自己的项目</li></ul><a id="more"></a><h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><h4 id="一、本地Tomcat的使用"><a href="#一、本地Tomcat的使用" class="headerlink" title="一、本地Tomcat的使用"></a>一、本地Tomcat的使用</h4><h5 id="1-1、安装Tomcat"><a href="#1-1、安装Tomcat" class="headerlink" title="1.1、安装Tomcat"></a>1.1、安装Tomcat</h5><p>使用TomCat，自然是要TomCat的安装包咯</p><p><a href="https://tomcat.apache.org/download-90.cgi" target="_blank" rel="noopener">安装包下载地址</a></p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/001.png" alt="image"></p><p>由于我们本地应该都是已经安装配置过JDK了的，所以安装Tomcat的时候一路Next就行了</p><h5 id="1-2、配置Gradle"><a href="#1-2、配置Gradle" class="headerlink" title="1.2、配置Gradle"></a>1.2、配置Gradle</h5><p>首先，在项目的gradle所在的目录下创建gradle.properties，然后在里面添加：</p><pre><code># true就去打包War，否则不打包BUILD_WAR=true</code></pre><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/002.png" alt="image"></p><p>接着在build.gradle中添加：</p><pre><code>if (BUILD_WAR.toBoolean()) {    apply plugin: &#39;war&#39;}dependencies {    ...    if (BUILD_WAR.toBoolean()) {        providedRuntime(&#39;org.springframework.boot:spring-boot-starter-tomcat&#39;)    }}</code></pre><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/003.png" alt="image"></p><p>同时，不要忘了创建一个ServletInitializer类，用于SpringBoot的初始化</p><pre><code>public class ServletInitializer extends SpringBootServletInitializer {    @Override    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {        return application.sources(TestForDemoApplication.class);    }}</code></pre><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/008.png" alt="image"></p><p>这些都完成后，在Terminal控制台输入：</p><pre><code>gradlew assemble</code></pre><p>等待结果，然后就可以看到一个war包了</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/004.png" alt="image"></p><h5 id="1-3、配置Tomcat"><a href="#1-3、配置Tomcat" class="headerlink" title="1.3、配置Tomcat"></a>1.3、配置Tomcat</h5><p>找到demo-0.0.1-SNAPSHOT.war所在目录，然后将其更名为oldchen.war</p><pre><code>注意，这里修改后的名字将会与部署到Tomcat上的网络请求地址有关哦</code></pre><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/005.png" alt="image"></p><p>然后找到Tomcat的安装目录下的webapps目录，将里面的其他文件和文件夹删除，把oldchen.war复制到该目录</p><p>接下来，在Tomcat目录下的bin目录中运行Tomcat9w.exe</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/006.png" alt="image"></p><p>然后你会发现，webapps目录下多了一个文件</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/007.png" alt="image"></p><h5 id="1-4、测试本地Tomcat"><a href="#1-4、测试本地Tomcat" class="headerlink" title="1.4、测试本地Tomcat"></a>1.4、测试本地Tomcat</h5><p>接下来，访问地址：</p><p><a href="http://localhost:8080/oldchen/user/user?account=oldchen" target="_blank" rel="noopener">http://localhost:8080/oldchen/user/user?account=oldchen</a></p><p>结果：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/009.png" alt="image"></p><p>可以看到，本地的Tomcat已经部署成功，接下来就是云服务器上部署Tomcat了。</p><h4 id="二、云服务器上Tomcat的部署"><a href="#二、云服务器上Tomcat的部署" class="headerlink" title="二、云服务器上Tomcat的部署"></a>二、云服务器上Tomcat的部署</h4><h5 id="2-1、购买云服务器"><a href="#2-1、购买云服务器" class="headerlink" title="2.1、购买云服务器"></a>2.1、购买云服务器</h5><p>想在云服务器上部署Tomcat，首先需要购买一个服务器，我买的是腾讯云的服务器，初次接触的同学建议去使用试用的云服务器，等操作成功后再买也不迟</p><p>出于对初学者的人文关怀（没错，Is me），这里我使用的是Windows版的服务器：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/010.png" alt="image"></p><p>为了能够正常访问服务器的地址，需要给服务器配置一下安全组，安全组中需要添加这样一项规则：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/011.png" alt="image"></p><p>然后，使用远程连接，连接到云服务器，具体操作是：</p><pre><code>一、win+R二、输入mstsc三、输入云服务器的Ip地址，用户名以及密码，连接</code></pre><p>如果你使用的是windows2016版的服务器，同时遇到了”身份验证错误，要求的函数不支持”，而且你恰好是win10家庭版，那么下面有解决办法：<br><a href="https://jingyan.baidu.com/album/67508eb47ae5499ccb1ce410.html?picindex=3" target="_blank" rel="noopener">windows10家庭版 远程桌面报错</a></p><p>成功登录后，整个界面只有一个孤伶伶的回收站，到了这步，就准备开始配置吧。</p><h5 id="2-2、配置云服务器"><a href="#2-2、配置云服务器" class="headerlink" title="2.2、配置云服务器"></a>2.2、配置云服务器</h5><p>云服务器上面运行项目只需要Tomcat+Mysql+Navicat+JDK，配置方法和之前在本地配置是一样的，不过这里不建议使用上传的方法，因为上传实际上和下载是一样的，有时候还会受限于你自己宽带的上行速度。</p><p>重新下载安装JDK是很头疼的，下面是详细教程：</p><p><a href="https://blog.csdn.net/qq_32519693/article/details/71330930" target="_blank" rel="noopener">非常详细图文JDK和Tomcat安装和配置的图文教程</a></p><p>全部需要准备的文件如下：<br><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/012.png" alt="image"></p><p>其中，<strong>PatchNavicat</strong> 用于Navicat的破解，在上一篇的链接中已经说明。</p><p>而<strong>oldchen.sql</strong>则是通过本地Navicat生成Mysql文件，具体操作是：右键你选中的数据库，选择【转储SQL文件】→【结构和数据】，然后就可以生成了。使用方法就是在云服务器上创建一个数据库后选择【运行SQL文件】即可。</p><p>这样，本地数据库的迁移就完成了。剩下的操作与之前介绍的基本一致，不过有一点需要注意，为了开启外网连接，需要在Tomcat安装目录下找到conf目录，修改其中的server.xml文件：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/013.png" alt="image"></p><p>将port由8080修改为80</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/014.png" alt="image"></p><p>当你完成全部的操作后，就可以测试接口了。</p><h5 id="2-3、测试云服务器接口"><a href="#2-3、测试云服务器接口" class="headerlink" title="2.3、测试云服务器接口"></a>2.3、测试云服务器接口</h5><p>只要你的步骤是ok的，那么云服务器不会有什么问题。</p><p>由于在写这篇文章期间，我又多写了个登录接口，所以这里的测试例子用的是新的接口，仅供参考：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/015.png" alt="image"></p><p>请求地址是：<a href="http://111.230.251.115/oldchen/user/login" target="_blank" rel="noopener">http://111.230.251.115/oldchen/user/login</a></p><h2 id="后语"><a href="#后语" class="headerlink" title="后语"></a>后语</h2><p>那么，编写接口的学习就到此为止了。</p><p>虽然有待完善的地方还不少，比如通过数据库指令对数据库进行增删改查、数据库之间相互关联等等，许多知识都需要慢慢学的。</p><p>此文章权当入门之径，剩下的还得靠大家自己多多钻研啦，毕竟作者本人需要学的地方也太多了，如有错误之处，还望指出，互相学习，岂不乐哉。</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/%E8%A1%A8%E6%83%85%E5%8C%85/%E5%91%8A%E8%BE%9E2.jpg" alt="image"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发者编写自己的API接口（上）</title>
      <link href="undefined2018/08/05/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>2018/08/05/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>作为一名Android开发人员，想要实现对一些数据的操作和展示，可以通过一些提供Api接口的网站去获取，虽然Api市场上种类繁多，不过别人提供的接口未必就是自己想要的，到最后，还是得自己去实现Api接口。</p><p>毕竟，最了解自己需求的人，还得是自己。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>很多小伙伴应该都会有着类似的需求，不过想去做的时候，常常无从下手。</p><p>所以这里做了一个整合，关于如何搭建开发环境，以及所需工具的下载等。</p><a id="more"></a> <p>参考文章：</p><ul><li><a href="https://www.jianshu.com/p/4a0d40806ea2" target="_blank" rel="noopener">Android程序员搭建一个属于自己的服务器，不再求各种公共API</a></li><li><a href="https://www.jianshu.com/p/f91ca5814bcf" target="_blank" rel="noopener">JAVA后台搭建(springboot+mybatis+mysql)项目搭建</a></li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>一套开发环境下来，需要下面这些步骤：</p><ul><li>1：搭建开发环境，IntelliJ + spring-boot + mybatis</li><li>2：搭建数据库，mysql + navicat</li><li>3：搭建运行环境，tomcat + 腾讯云（或者阿里云）</li></ul><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="一、搭建开发环境"><a href="#一、搭建开发环境" class="headerlink" title="一、搭建开发环境"></a>一、搭建开发环境</h3><h4 id="1-1-IntelliJ-IDEA的安装"><a href="#1-1-IntelliJ-IDEA的安装" class="headerlink" title="1.1 IntelliJ IDEA的安装"></a>1.1 IntelliJ IDEA的安装</h4><p>Android开发者所使用的Android studio是基于这个IDEA开发的，所以两者的界面非常非常相似。</p><p>而且现在比较流行的Android开发语言Kotlin也是由IntelliJ IDEA的开发公司JetBrains所开发的。</p><h5 id="下载-IntelliJ-IDEA"><a href="#下载-IntelliJ-IDEA" class="headerlink" title="下载 IntelliJ IDEA"></a>下载 IntelliJ IDEA</h5><p>首先，下载安装包——<a href="https://www.jetbrains.com/idea/download/#section=windows" target="_blank" rel="noopener">【IntelliJ下载地址】</a></p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001.png" alt="image"></p><h5 id="安装-IntelliJ-IDEA"><a href="#安装-IntelliJ-IDEA" class="headerlink" title="安装 IntelliJ IDEA"></a>安装 IntelliJ IDEA</h5><p>下载完成后，就开始安装了</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-001.png" alt="image"></p><p>Next到下面的界面，可以自行选择</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-002.png" alt="image"></p><p>然后一直下一步，到可以运行IDEA，然后你应该会遇到需要购买的提示，破解的教程请看：</p><p><a href="https://blog.csdn.net/yangying496875002/article/details/73603303" target="_blank" rel="noopener">Windows7下安装与破解IntelliJ IDEA2017</a></p><p>win10也是适用的。</p><h4 id="1-2-MySQL的安装"><a href="#1-2-MySQL的安装" class="headerlink" title="1.2 MySQL的安装"></a>1.2 MySQL的安装</h4><h5 id="下载MySQL"><a href="#下载MySQL" class="headerlink" title="下载MySQL"></a>下载MySQL</h5><p>这里使用的是mysql-5.7.17.msi，下载地址是：</p><p><a href="https://downloads.mysql.com/archives/installer/" target="_blank" rel="noopener">MYSQL下载地址</a></p><h5 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h5><p>下载完成后进行安装：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-006.png" alt="image"></p><p>这里只选择了Server</p><p>然后一直下一步</p><p>到了设置密码这里，我设置的密码是【oldchen】,后面项目配置的密码也是这个，这里你可以随便设置自己的密码，不过后面配置的时候要保证密码输入一致就是：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-007.png" alt="image"></p><p>然后一直下一步，直到安装成功，接下来就是如何去操作数据库。</p><h4 id="1-3-Navicat的安装"><a href="#1-3-Navicat的安装" class="headerlink" title="1.3 Navicat的安装"></a>1.3 Navicat的安装</h4><p>Navicat用来对数据库进行操作，也是需要付费购买的，破解地址：<br><a href="https://blog.csdn.net/wypersist/article/details/79834490" target="_blank" rel="noopener">Navicat for MySQL 安装和破解（完美）</a></p><p>可以使用之后，来到如下界面：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-008.png" alt="image"></p><p>然后创建MYSQL连接：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-009.png" alt="image"></p><p>输入相关信息：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-010.png" alt="image"></p><p>然后就可以看到创建的连接了，右键→新建数据库：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-011.png" alt="image"></p><p>新建的数据库名字设置为oldchen,接下来双击这个数据库，新建一个user表,表中包含account,password,username以及自增主键id，具体操作如图所示：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/gif/001.gif" alt="image"></p><p>创建这个表后，我们可以添加一条数据：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-012.png" alt="image"></p><p>然后，开始配置IntelliJ IDEA</p><h4 id="1-4-IntelliJ-IDEA的配置"><a href="#1-4-IntelliJ-IDEA的配置" class="headerlink" title="1.4 IntelliJ IDEA的配置"></a>1.4 IntelliJ IDEA的配置</h4><h5 id="搭建SpringBoot项目"><a href="#搭建SpringBoot项目" class="headerlink" title="搭建SpringBoot项目"></a>搭建SpringBoot项目</h5><p>打开IntelliJ，左上角 File → New → Project，创建新项目：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-013.png" alt="image"></p><p>然后</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-004.png" alt="image"></p><p>接下来是选择依赖的界面，选中图中的全部依赖</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-005.png" alt="image"></p><p>下一步<br><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-019.png" alt="image"></p><p>开始项目构建，需要等待一定的时间，构建完成后的项目结构是这样的：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-015.png" alt="image"></p><p>结合之前新建的数据库，在resources目录下的application.properties中进行配置：</p><pre><code>#oldchen为创建的数据库名字spring.datasource.url =jdbc:mysql://localhost:3306/oldchenmybatis.type-aliases-package = com.example.demo# 数据库用户名spring.datasource.username = root# 数据库密码spring.datasource.password = oldchenspring.datasource.driver-class-name=com.mysql.jdbc.Driver#端口号spring.session.store-type=nonespring.http.encoding.charset=UTF-8</code></pre><p>接下来就开始写接口啦</p><h4 id="1-5-接口的编写"><a href="#1-5-接口的编写" class="headerlink" title="1.5 接口的编写"></a>1.5 接口的编写</h4><p>由于我们之前在操作名为【oldchen】的数据库时，还新建了一个【user】表，所以这里先创建一个User类：</p><pre><code>public class User {    private Integer id;    private String account;    private String password;    private String userName;    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getAccount() {        return account;    }    public void setAccount(String account) {        this.account = account;    }    public String getPassword() {        return password;    }    public void setPassword(String password) {        this.password = password;    }    public String getUserName() {        return userName;    }    public void setUserName(String userName) {        this.userName = userName;    }}</code></pre><p>然后创建UserMapper，用于查询（根据字段account查询）</p><pre><code>@Mapperpublic interface UserMapper {    @Select(&quot;select * from user where account = #{account}&quot;)    User findByAccount(String account);}</code></pre><p>接着创建UserController，用于对数据的处理：</p><pre><code>@RestController@RequestMapping({&quot;/user&quot;})public class UserController {    @Autowired    private UserMapper userMapper;    @RequestMapping(value=&quot;/user&quot;)    @ResponseBody    public String getUserInfoByName(String account) {        User user = userMapper.findByAccount(account);        if (user == null){            return &quot;用户名保不存在&quot;;        } else {            return &quot;用户名存在——&quot; + user.getUserName();        }    }}</code></pre><p>最后项目结构如下：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-016.png" alt="image"></p><h3 id="二、测试接口"><a href="#二、测试接口" class="headerlink" title="二、测试接口"></a>二、测试接口</h3><p>首先，运行项目</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-017.png" alt="image"></p><p>当项目正常运行后，测试下面的地址：</p><p><a href="http://localhost:8080/user/user?account=oldchen" target="_blank" rel="noopener">http://localhost:8080/user/user?account=oldchen</a></p><p>结果：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-018.png" alt="image"></p><p>测试成功啦！</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>关于Api接口的学习，先到这里。</p><p>后面还会写关于如何将项目放在TomCat上，最后放在云服务器上，通过外网地址访问接口</p><p>那么，未完待续…</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/%E8%A1%A8%E6%83%85%E5%8C%85/%E5%91%8A%E8%BE%9E.jpg" alt="image"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Old Chen&#39;s Wish List</title>
      <link href="undefined2018/07/29/Old%20Chen&#39;s%20Wish%20List/"/>
      <url>2018/07/29/Old%20Chen&#39;s%20Wish%20List/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Old-Chen的愿望"><a href="#一、Old-Chen的愿望" class="headerlink" title="一、Old Chen的愿望"></a>一、Old Chen的愿望</h2><h4 id="1-、have-a-good-feel"><a href="#1-、have-a-good-feel" class="headerlink" title="(1)、have a good feel"></a>(1)、have a good feel</h4><h4 id="2-、看完所有买的文学书"><a href="#2-、看完所有买的文学书" class="headerlink" title="(2)、看完所有买的文学书"></a>(2)、看完所有买的文学书</h4><ul><li style="list-style: none"><input type="checkbox"> 1：东野硅谷系列</li><li style="list-style: none"><input type="checkbox"> 2：三体系列             （✔××）<a id="more"></a> </li><li style="list-style: none"><input type="checkbox"> 3：《时间简史》</li><li style="list-style: none"><input type="checkbox"> 4：《边城》</li><li style="list-style: none"><input type="checkbox"> 5：《百年孤独》</li><li style="list-style: none"><input type="checkbox"> 6：《茶馆》</li></ul><h4 id="3-、买一些想买的东西"><a href="#3-、买一些想买的东西" class="headerlink" title="(3)、买一些想买的东西"></a>(3)、买一些想买的东西</h4><ul><li style="list-style: none"><input type="checkbox"> 1：《矮大紧指北》</li><li style="list-style: none"><input type="checkbox" checked> 2：《老梁的四大名著情商课》     </li><li style="list-style: none"><input type="checkbox" checked> 3：一个新的手机                </li><li style="list-style: none"><input type="checkbox"> 4：预购游戏</li><li style="list-style: none"><input type="checkbox" checked> 5：好吃的零食</li><li style="list-style: none"><input type="checkbox"> 6：一个天文望远镜</li><li style="list-style: none"><input type="checkbox" checked> 7：一个游戏机(switch)</li></ul><h4 id="4-、玩完已经买了的游戏"><a href="#4-、玩完已经买了的游戏" class="headerlink" title="(4)、玩完已经买了的游戏"></a>(4)、玩完已经买了的游戏</h4><ul><li style="list-style: none"><input type="checkbox"> 1：《巫师3》</li><li style="list-style: none"><input type="checkbox" checked> 2：《黑魂3》                 （全成就）</li><li style="list-style: none"><input type="checkbox"> 3：刺客信条系列</li><li style="list-style: none"><input type="checkbox"> 4：《古墓丽影：崛起》</li><li style="list-style: none"><input type="checkbox" checked> 5:《杀戮尖塔》 （全成就）</li><li style="list-style: none"><input type="checkbox" checked> 5:《塞尔达传说：旷野之息》 （救出公主）</li></ul><h4 id="5-、写APP"><a href="#5-、写APP" class="headerlink" title="(5)、写APP"></a>(5)、写APP</h4><ul><li style="list-style: none"><input type="checkbox"> 写一个日记本APP    (Wringting)</li><li style="list-style: none"><input type="checkbox"> 写一个单词生词本APP</li></ul><h4 id="6-、养宠物-Hard"><a href="#6-、养宠物-Hard" class="headerlink" title="(6)、养宠物(Hard)"></a>(6)、养宠物(Hard)</h4><ul><li style="list-style: none"><input type="checkbox"> 养一只猫  </li></ul><h2 id="二、Old-Chen的长期愿望-Hard"><a href="#二、Old-Chen的长期愿望-Hard" class="headerlink" title="二、Old Chen的长期愿望(Hard)"></a>二、Old Chen的长期愿望(Hard)</h2><h4 id="1-、学习啦"><a href="#1-、学习啦" class="headerlink" title="(1)、学习啦"></a>(1)、学习啦</h4><h4 id="2-、充实自己"><a href="#2-、充实自己" class="headerlink" title="(2)、充实自己"></a>(2)、充实自己</h4><h4 id="3-、自得其乐"><a href="#3-、自得其乐" class="headerlink" title="(3)、自得其乐"></a>(3)、自得其乐</h4><h2 id="三、老晨子的终极愿望"><a href="#三、老晨子的终极愿望" class="headerlink" title="三、老晨子的终极愿望"></a>三、老晨子的终极愿望</h2><p><strong>莫春者，春服既成，冠者五六人，童子六七人，浴乎沂，风乎舞雩，咏而归</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 愿望清单 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>