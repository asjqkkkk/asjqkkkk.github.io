<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>老晨子の博客</title>
  
  <subtitle>想写的时候写一些</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-16T15:56:29.782Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Old Chen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>杂谈-gun&amp;legal</title>
    <link href="http://yoursite.com/2019/04/16/%E6%9D%82%E8%B0%88-gun-legal/"/>
    <id>http://yoursite.com/2019/04/16/杂谈-gun-legal/</id>
    <published>2019-04-16T15:55:40.000Z</published>
    <updated>2019-04-16T15:56:29.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sequence"><a href="#sequence" class="headerlink" title="sequence"></a>sequence</h1><p>好久都没有写博客了，久到我几乎要忘了markdown的写作格式。</p><p>当初给自己的目标是每个月至少一篇技术博客，如今看来这个目标因为种种原因而被搁置，好在我每周锻炼三次的习惯一直持续了半年之久。</p><a id="more"></a> <p>停写博客的这段时间，我又学了许多新的东西，我的技术旅途上也多了一个新的伙伴——Flutter,相较于原来的Android而言，我实在是太喜欢Flutter了，从这种喜新厌旧的表现上来看，也许我是一个渣男吧？<br><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E6%9D%82%E8%B0%88/001.jpg" alt="image"></p><h1 id="leave"><a href="#leave" class="headerlink" title="leave"></a>leave</h1><p>这一个月里，我经历了离职、(因为离职)请朋友吃饭、面试、朋友(后脚离职)请我们吃饭等各种事情。</p><p>关于这群朋友，我感触颇深，和他们在公司的这段日子里我成长了不少，而我特别感谢的就是他们曾经热情地带领一个刚毕业的大学生融入了公司的环境，不然以那个涉世未深且又颇为内向的大学生的能力，想要达到这种效果可得费好大一番功夫。</p><p>也是因为这群朋友，我比以前优秀了！</p><p>在这里再次默默祝你们——前程似锦，万事可期！</p><h1 id="recent"><a href="#recent" class="headerlink" title="recent"></a>recent</h1><p>上周，面试了整整一个星期，除了周一外，每天两场面试。最赶一次，上午面试完回家刚吃完饭，就要开始下一家的面试，而下一家光是往返就花了我近五个小时。这样的奔波劳碌，直接导致我这周不想再去投递简历，除了上周约了今天下午的面试，这周我再没投过简历。</p><p>我打算休息一下。</p><p>写博客对我而言是一种爱好，也是休息方式之一。不过写这篇博客的主要目的还是想写下我心中的一个想法，一个早已根植心底的想法。</p><h1 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h1><p>这个想法，很久之前就有过了，只是最近社会上又发生的一些事情，导致我的想法更加清晰、具象。</p><p>这段日子里，发生了好多人尽皆知的社会新闻，比如：</p><p><a href="https://news.163.com/19/0414/20/ECOGCK760001899O.html" target="_blank" rel="noopener">【女车主称被迫交纳1.5万金融服务费 奔驰发声明回应】</a></p><p><a href="https://news.163.com/19/0413/04/ECK70O1L0001899N.html" target="_blank" rel="noopener">【一张图赔2万!视觉中国年赚3亿背后每天15.6起官司】</a></p><p>以及和我们程序员相关的996事件：</p><p><a href="https://github.com/996icu/996.ICU/blob/master/README_CN.md" target="_blank" rel="noopener">【996.ICU】</a></p><p><a href="https://tech.163.com/19/0412/18/ECJ6M1PE00097U7R.html" target="_blank" rel="noopener">【刘强东朋友圈回应996：”混日子的人不是我的兄弟”】</a></p><p><a href="https://news.163.com/19/0412/18/ECJ56LP00001875P.html" target="_blank" rel="noopener">【马云谈”996”:能做是一种巨大福气 很多人都没机会】</a></p><p>在我看来，这些新闻都说明了一个问题：我们离“<strong>法制社会</strong>”还有着很长一段距离！</p><p>而我的想法，就是和这相关的。</p><h1 id="idea-origin"><a href="#idea-origin" class="headerlink" title="idea_origin"></a>idea_origin</h1><p>在正式说明这个想法之前，我还是想写一下我是怎么产生这样的想法的。</p><p><strong>大概是有过一段中二且愤世嫉俗的时期吧。</strong></p><p>当时经常看到XXX村的干部又对XXX村民做了强取豪夺之事这类的新闻,比如这样：</p><p><a href="https://news.163.com/19/0415/11/ECQ4K3SH0001899O.html" target="_blank" rel="noopener">【村支书因货车刮到遮阳棚将司机打死 之后继续打牌】</a></p><p>又或者这样：</p><p><a href="http://money.163.com/18/0927/11/DSN633T4002580T4.html" target="_blank" rel="noopener">【”劫后”谭秦东称今生绝不入蒙 曾吐槽鸿茅药酒被抓】</a></p><p>那时我是这么想的：</p><pre><code>如果这种事情发生在美国，会是这样的结果吗？不会，美国人的持枪率导致他们的自卫能力远远强于其他国家没有武器的人们。</code></pre><p>现在看来，当初的想法过于简单粗暴，因为它会造成许多新的问题，在不持有枪支的情况下，你都能看到类似下面这样的新闻：</p><p><a href="http://news.163.com/19/0221/10/E8HJIL0B0001899O.html" target="_blank" rel="noopener">【江西一男子在校门口持刀伤人 砍伤学生辅警等11人】</a></p><p>而如果全民持枪的话，不知道又会出现多少起类似美国的枪支伤人事件。这个想法除了简单粗暴以外，还有一点就是天方夜谭，除了小说里面，现实是不可能出现全民持枪的情况的，永远都不会。</p><h1 id="idea-transform"><a href="#idea-transform" class="headerlink" title="idea_transform"></a>idea_transform</h1><p>如果有可以替代枪支用于自卫的武器，那么它一定是 <strong>法律</strong> 。</p><p>同时，法律公正、具备执行力、不带有任何情感，相较于枪支而言，它安全的多。</p><p>不过就如同我之前所说，真正意义上的 <strong>法制社会</strong> 我们还是难以企及。脱离了现实基础去谈论法律的使用无异于建造一所空中楼阁。</p><p>目前的法律显然不具备这些特点：普及性、易用性、服务性。</p><p>普通人想去使用法律，成本与难度还是很高的，就连我这种把技术作为代号的程序员，对法律也是一窍不通。</p><p>所以写到这里，我就要说出我真实的想法了。</p><h1 id="I-have-an-idea"><a href="#I-have-an-idea" class="headerlink" title="I have an idea"></a>I have an idea</h1><p><strong>我希望未来有一家公司，可以实现让人们低成本、便捷的去使用法律</strong></p><p>对，不是一家机构，是一个公司。就像阿里巴巴一样，本来应该交给银行去做的无现金社会，最后还需要靠马云去实现。而真正的无障碍使用法律的实现，也许只能由非官方非机构的某家公司去做。</p><p>我希望未来不管是谁，一定要出现一家这样的公司，实现这样的目的。</p><p>虽然我很想亲自去做这件事，但是目前而言我没有这个胆量，也没有这么坚定的信念，不过目前关于公司的一些构想，已经在我脑海里有了初步的雏形。</p><h1 id="idea-blueprint"><a href="#idea-blueprint" class="headerlink" title="idea blueprint"></a>idea blueprint</h1><!--公司的终极目的：实现 **法治社会** --><!--公司的主要目的：普及法律知识、降低法律使用成本、提高法律作为武器与防具的力量--><p>下面是我脑海中一个模糊的结构：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E6%9D%82%E8%B0%88/002.png" alt="image"></p><p>项目的名字就叫 <strong>民律</strong></p><p>虽然我不知道这样对不对，但是我希望未来我或者其他人可以去完成这个事业。</p><p>而我对于它的发展与结局是这样看待的，最理想的情况就是：生于乱世，匿于盛世。</p><p>当真正处于 <strong>法治社会</strong> 的时候，这样的产品自然也就销声匿迹了，这也是我乐于见到的场景。</p><p><strong>那么，我心中的想法就此写下，以后我睡觉的时候再不用去花时间考虑这个问题了  :D</strong></p><h1 id="about-996"><a href="#about-996" class="headerlink" title="about 996"></a>about 996</h1><p>最后，关于996谈一下我的看法。</p><p>本来马云在我心中是99分的第一类钦佩的存在，现在因为他的996言论，他只有95分了，第一类目前还有雷军、任正非，都是99分。</p><p>关于996这个问题，我觉得它一定是不适合技术人员的，特别是程序员这个种族。</p><p>因为技术人员的技术是会随着自身的积累慢慢增加的，技术越高的人会越讨厌毫无意义的重复性劳动，也会越追崇高效率的工作，同时他们思考的质量也会逐渐上升。</p><p>拿我自身的经历来说，如果让我全神贯注去敲代码，四个小时后我就会宕机，之后再进行这样高强度的脑力活动，我的效率会大幅度下降，并且工作积极性也会因为脑力下降而跌落。这时候加班反而不能起到正面促进的效果，只是把人带入了一个恶循环当中。</p><p>虽然我不提倡996，但是就像人有三急一样，有的时候项目确实会出现很赶的情况，这时候适当的加班也是没问题的。但我理想的情况应该是这样：项目规划的好，任务安排合理，基本上用不着加班，每天在工作时限内就可以很好的完成任务。如果需要加班，一定不能是长期的，并且加班需要有加班费，而这个加班费，我希望永远不会有拿的机会。</p><p>那关于996就是这样了，人们工作是为了更好的生活，就像人们健身也是为了生活而服务的。现在许多人因为健身耽误了正常的生活状态，反而是本末倒置，就像现在的996一样，得不偿失。</p><p>最后，关于我之前的想法，如果有朝一日我能实现这个想法，我一定推己及人，从自身的行业开始，让955成为常态，如果影响力够大的话，甚至是可以去实行10，5，5的。然而这也只是实现想法后的冰山一角，能改善的东西，还有更多！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;sequence&quot;&gt;&lt;a href=&quot;#sequence&quot; class=&quot;headerlink&quot; title=&quot;sequence&quot;&gt;&lt;/a&gt;sequence&lt;/h1&gt;&lt;p&gt;好久都没有写博客了，久到我几乎要忘了markdown的写作格式。&lt;/p&gt;
&lt;p&gt;当初给自己的目标是每个月至少一篇技术博客，如今看来这个目标因为种种原因而被搁置，好在我每周锻炼三次的习惯一直持续了半年之久。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android Studio自定义模板实现一键创建MVP结构</title>
    <link href="http://yoursite.com/2018/12/02/Android-Studio%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2018/12/02/Android-Studio自定义模板实现一键创建MVP结构/</id>
    <published>2018-12-02T04:32:54.000Z</published>
    <updated>2018-12-02T04:43:28.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前有写过关于如何使用 DataBinding 的两篇文章，不仅仅是为了消灭掉一部分重复代码，更是为了提高开发效率。详情可以点击下方的传送门<br><a href="https://oldchen.top/2018/10/17/DataBinding%E2%80%94%E2%80%94%E4%BB%8E%E8%B7%AF%E4%BA%BA%E5%88%B0%E5%A5%BD%E5%8F%8B%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%88%9D%E9%81%87/" target="_blank" rel="noopener">DataBinding——从路人到好友（一）：初遇</a><br><a href="https://oldchen.top/2018/10/20/DataBinding%E2%80%94%E2%80%94%E4%BB%8E%E7%9B%B8%E8%AF%86%E5%88%B0%E7%9B%B8%E7%9F%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BA%92%E9%85%8C/" target="_blank" rel="noopener">DataBinding——从相识到相知（二）：互酌</a></p><a id="more"></a> <p>而这篇文章主要介绍的就是如何通过 Android Studio 提供的模版功能去自定义模版结构，从而实现类似于一键创建整个MVP代码的功能。可以说在提高效率的道路上，又向前走了一大步<br><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/001.jpg" alt="image"></p><p>下面可以来看一看具体效果：<br><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/002.gif" alt="image"></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>在 Android Studio 中，创建一个 Activity 可以直接通过 <strong>File -&gt; New -&gt; Activity</strong> 来进行选择创建</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/003.png" alt="image"></p><p>通过这种方式创建的 Activity 会自动在 AndroidManifest.xml 中完成注册，创建其他组件也可以通过这种方式。</p><p>不过，如果你正在使用某种开发模式，譬如 <strong>MVP、MVVM</strong> 等，你每创建一个 Activity 就意味着需要同时创建一系列其他相关的类。</p><p>为了避免这种毫无意义的重复性劳动，我们可以编写模板代码去实现一键创建重复代码。</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>下面我们就来开始模版的编写吧。</p><p>首先，找到你的 <strong>Android Studio</strong> 的安装目录，然后根据这个目录找到 <strong>…\templates</strong> 目录：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/004.png" alt="image"></p><p>然后进入 <strong>activityes</strong> 目录，我们将要编写的各种模版就在这个目录内：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/005.png" alt="image"></p><p>要说如何去编写模版代码，一开始我也是一无所知的，不过好在 Android Studio 已经为我们提供了这些例子，我们直接参考例子去写。</p><p>就拿最简单的 <strong>Empty Activity</strong> 来开始吧</p><p>进入到 <strong>EmptyActivity</strong> 目录</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/006.png" alt="image"></p><h2 id="globals-xml-ftl"><a href="#globals-xml-ftl" class="headerlink" title="globals.xml.ftl"></a>globals.xml.ftl</h2><p>打开 <strong>globals.xml.ftl</strong> 文件，下面是它的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;globals&gt;</span><br><span class="line">    &lt;global id=&quot;hasNoActionBar&quot; type=&quot;boolean&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">    &lt;global id=&quot;parentActivityClass&quot; value=&quot;&quot; /&gt;</span><br><span class="line">    &lt;global id=&quot;simpleLayoutName&quot; value=&quot;$&#123;layoutName&#125;&quot; /&gt;</span><br><span class="line">    &lt;global id=&quot;excludeMenu&quot; type=&quot;boolean&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">    &lt;global id=&quot;generateActivityTitle&quot; type=&quot;boolean&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">    &lt;#include &quot;../common/common_globals.xml.ftl&quot; /&gt;</span><br><span class="line">&lt;/globals&gt;</span><br></pre></td></tr></table></figure><p>根据文件名来看， <strong>globals.xml.ftl</strong> 的作用是用来控制一些全局变量，比如是否显示 <strong>ActionBar</strong> 等，暂且先不用管它</p><h2 id="recipe-xml-ftl"><a href="#recipe-xml-ftl" class="headerlink" title="recipe.xml.ftl"></a>recipe.xml.ftl</h2><p> <strong>recipe.xml.ftl</strong> 文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;#import &quot;root://activities/common/kotlin_macros.ftl&quot; as kt&gt;</span><br><span class="line">&lt;recipe&gt;</span><br><span class="line">    &lt;#include &quot;../common/recipe_manifest.xml.ftl&quot; /&gt;</span><br><span class="line">    &lt;@kt.addAllKotlinDependencies /&gt;</span><br><span class="line"></span><br><span class="line">&lt;#if generateLayout&gt;</span><br><span class="line">    &lt;#include &quot;../common/recipe_simple.xml.ftl&quot; /&gt;</span><br><span class="line">    &lt;open file=&quot;$&#123;escapeXmlAttribute(resOut)&#125;/layout/$&#123;layoutName&#125;.xml&quot; /&gt;</span><br><span class="line">&lt;/#if&gt;</span><br><span class="line"></span><br><span class="line">    &lt;instantiate from=&quot;root/src/app_package/SimpleActivity.$&#123;ktOrJavaExt&#125;.ftl&quot;</span><br><span class="line">                   to=&quot;$&#123;escapeXmlAttribute(srcOut)&#125;/$&#123;activityClass&#125;.$&#123;ktOrJavaExt&#125;&quot; /&gt;</span><br><span class="line">    &lt;open file=&quot;$&#123;escapeXmlAttribute(srcOut)&#125;/$&#123;activityClass&#125;.$&#123;ktOrJavaExt&#125;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/recipe&gt;</span><br></pre></td></tr></table></figure><p>第一段</p><pre><code>&lt;#import &quot;root://activities/common/kotlin_macros.ftl&quot; as kt&gt;</code></pre><p>就是用于导入Kotlin的相关命令，同时它的别名为 <strong>kt</strong></p><p>主要还是注意 <strong>instantiate</strong> 代码块中的相关信息， 其中 <strong>${ktOrJavaExt}</strong> 表示当你创建模版的时候，创建的 <strong>.java</strong> 文件还是 <strong>.kt</strong> 文件，而相对应的，你需要在编写模版例子的时候分别写上对应的两份 <strong>Java</strong> 与 <strong>Kotlin</strong> 代码</p><p><strong>open</strong> 代码块就是创建模版后，默认打开的文件</p><h1 id="template-xml"><a href="#template-xml" class="headerlink" title="template.xml"></a>template.xml</h1><p><strong>template.xml</strong> 代码略长，这里只是贴出了大致代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;template</span><br><span class="line">    format=&quot;5&quot;</span><br><span class="line">    revision=&quot;5&quot;</span><br><span class="line">    name=&quot;Empty Activity&quot;</span><br><span class="line">    minApi=&quot;9&quot;</span><br><span class="line">    minBuildApi=&quot;14&quot;</span><br><span class="line">    description=&quot;Creates a new empty activity&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;category value=&quot;Activity&quot; /&gt;</span><br><span class="line">    &lt;formfactor value=&quot;Mobile&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;parameter</span><br><span class="line">        id=&quot;activityClass&quot;</span><br><span class="line">        name=&quot;Activity Name&quot;</span><br><span class="line">        type=&quot;string&quot;</span><br><span class="line">        constraints=&quot;class|unique|nonempty&quot;</span><br><span class="line">        suggest=&quot;$&#123;layoutToActivity(layoutName)&#125;&quot;</span><br><span class="line">        default=&quot;MainActivity&quot;</span><br><span class="line">        help=&quot;The name of the activity class to create&quot; /&gt;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    &lt;!-- 128x128 thumbnails relative to template.xml --&gt;</span><br><span class="line">    &lt;thumbs&gt;</span><br><span class="line">        &lt;!-- default thumbnail is required --&gt;</span><br><span class="line">        &lt;thumb&gt;template_blank_activity.png&lt;/thumb&gt;</span><br><span class="line">    &lt;/thumbs&gt;</span><br><span class="line"></span><br><span class="line">    &lt;globals file=&quot;globals.xml.ftl&quot; /&gt;</span><br><span class="line">    &lt;execute file=&quot;recipe.xml.ftl&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>我们挑出其中的重点来说</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;category value=&quot;Activity&quot; /&gt;</span><br></pre></td></tr></table></figure><p>表示当前的这个模版的分类，当前的 <strong>Value</strong> 是 <strong>Activity</strong> ，就表示它会出现在 <strong>File -&gt; New -&gt; Activity</strong> 中，这个是可以自定义的.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;thumbs&gt;</span><br><span class="line">&lt;!-- default thumbnail is required --&gt;</span><br><span class="line">&lt;thumb&gt;template_blank_activity.png&lt;/thumb&gt;</span><br><span class="line">&lt;/thumbs&gt;</span><br></pre></td></tr></table></figure><p><strong>thumbs</strong> 用于指定创建模版时所展示出来的图片</p><p>而最重要的，还是 <strong>parameter</strong> 代码块的内容了，在这之中，我们只需要关注以下几个，其他的顾名思义即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;parameter</span><br><span class="line">    id=&quot;activityClass&quot;</span><br><span class="line">    name=&quot;Activity Name&quot;</span><br><span class="line">    type=&quot;string&quot;</span><br><span class="line">    constraints=&quot;class|unique|nonempty&quot;</span><br><span class="line">    suggest=&quot;$&#123;layoutToActivity(layoutName)&#125;&quot;</span><br><span class="line">    default=&quot;MainActivity&quot;</span><br><span class="line">    help=&quot;The name of the activity class to create&quot; /&gt;</span><br></pre></td></tr></table></figure><p><strong>activityClass</strong> 表示所要创建的 Activity ，其中 <strong>default</strong> 为默认名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;parameter</span><br><span class="line">    id=&quot;generateLayout&quot;</span><br><span class="line">    name=&quot;Generate Layout File&quot;</span><br><span class="line">    type=&quot;boolean&quot;</span><br><span class="line">    default=&quot;true&quot;</span><br><span class="line">    help=&quot;If true, a layout file will be generated&quot; /&gt;</span><br></pre></td></tr></table></figure><p>上面的代码块表示是否同时自动创建一个Activity对应的布局</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;parameter</span><br><span class="line">      id=&quot;layoutName&quot;</span><br><span class="line">      name=&quot;Layout Name&quot;</span><br><span class="line">      type=&quot;string&quot;</span><br><span class="line">      constraints=&quot;layout|unique|nonempty&quot;</span><br><span class="line">      suggest=&quot;$&#123;activityToLayout(activityClass)&#125;&quot;</span><br><span class="line">      default=&quot;activity_main&quot;</span><br><span class="line">      visibility=&quot;generateLayout&quot;</span><br><span class="line">      help=&quot;The name of the layout to create for the activity&quot; /&gt;</span><br></pre></td></tr></table></figure><p> <strong>layoutName</strong> 则表示布局的名字，这里的 <strong>suggest</strong> 属性所填写的内容即为布局名，<strong>${activityToLayout(activityClass)}</strong>则为跟随Activity的名字，其中 <strong>activityClass</strong> 是Activity名字的引用</p><p> 剩下的不用再作说明，基本上可以见名知意。</p><h1 id="模版代码"><a href="#模版代码" class="headerlink" title="模版代码"></a>模版代码</h1><p>接下来我们从 <strong>EmptyActivity</strong> 中的 <strong>root</strong> 目录一直进入，直到看到下面两个文件</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/007.png" alt="image"></p><p>可以看到，一个后缀是 <strong>java.ftl</strong> 另外一个后缀是 <strong>kt.ftl</strong>，他们分别用于创建 Java模版与Kotlin模版，如果你暂时不使用Kotlin的话，可以不用去关心 Kotlin模版，当你完成了Java模版的编写，也可以使用 Android Studio自带的转换功能，还是蛮方便的。</p><p>下面来看一下Java的模版代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package $&#123;packageName&#125;;</span><br><span class="line"></span><br><span class="line">import $&#123;superClassFqcn&#125;;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">&lt;#if (includeCppSupport!false) &amp;&amp; generateLayout&gt;</span><br><span class="line">import android.widget.TextView;</span><br><span class="line">&lt;/#if&gt;</span><br><span class="line"></span><br><span class="line">public class $&#123;activityClass&#125; extends $&#123;superClass&#125; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">&lt;#if generateLayout&gt;</span><br><span class="line">        setContentView(R.layout.$&#123;layoutName&#125;);</span><br><span class="line">       &lt;#include &quot;../../../../common/jni_code_usage.java.ftl&quot;&gt;</span><br><span class="line">&lt;#elseif includeCppSupport!false&gt;</span><br><span class="line"></span><br><span class="line">        // Example of a call to a native method</span><br><span class="line">        android.util.Log.d(&quot;$&#123;activityClass&#125;&quot;, stringFromJNI());</span><br><span class="line">&lt;/#if&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;#include &quot;../../../../common/jni_code_snippet.java.ftl&quot;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>${packageName}：表示当前包名</li><li>${activityClass}：表示当前的Activity名字</li><li>${superClass}：表示继承的Activity，同时为了让这个父类生效，需要在import中加入${superClassFqcn}</li><li>${layoutName}：当前Activity所对应的布局名</li></ul><p>目前我们只需要关注上面这部分，接下来可以看一下我们实际想要创建的MVP结构：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/008.png" alt="image"></p><p>编写模版代码前，最好的方式是先写一遍例子，然后对照例子去替换关键名部分，这样做是最轻松的。</p><p>下面就来看一看具体的实现吧：</p><h1 id="样例代码"><a href="#样例代码" class="headerlink" title="样例代码"></a>样例代码</h1><h2 id="接口部分：TestActivityContact"><a href="#接口部分：TestActivityContact" class="headerlink" title="接口部分：TestActivityContact"></a>接口部分：TestActivityContact</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.example.testcustomtemplates.contact;</span><br><span class="line"></span><br><span class="line">public interface TestActivityContact &#123;</span><br><span class="line">    interface Presenter&lt;T&gt; &#123;</span><br><span class="line">        void succeed(T t);</span><br><span class="line">        void failed(T t);</span><br><span class="line">        void error(Throwable e);</span><br><span class="line">        void subscribe();</span><br><span class="line">        void unSubscribe();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface View&lt;T&gt; &#123;</span><br><span class="line">        void setPresenter(Presenter presenter);</span><br><span class="line">        void succeed(T t);</span><br><span class="line">        void failed(T t);</span><br><span class="line">        void error(Throwable e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    interface Model &#123;</span><br><span class="line">        void setPresenter(Presenter presenter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便测试，这里并没有另外创建一些基类接口，可以看到上面代码中分别对应 MVP 结构中三个模块的接口，写的是最基本的需求方法，不过 MVP 也不都是完全一样的，这里你可以定义自己想写的方法。</p><h2 id="Model层：TestActivityModel"><a href="#Model层：TestActivityModel" class="headerlink" title="Model层：TestActivityModel"></a>Model层：TestActivityModel</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.example.testcustomtemplates.model;</span><br><span class="line"></span><br><span class="line">import android.content.Context;</span><br><span class="line">import com.example.testcustomtemplates.contact.TestActivityContact;</span><br><span class="line"></span><br><span class="line">public class TestActivityModel implements TestActivityContact.Model &#123;</span><br><span class="line"></span><br><span class="line">    private Context context;</span><br><span class="line">    private TestActivityContact.Presenter mPresenter;</span><br><span class="line"></span><br><span class="line">    public TestActivityModel(Context context) &#123;</span><br><span class="line">        this.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setPresenter(TestActivityContact.Presenter presenter) &#123;</span><br><span class="line">        this.mPresenter = presenter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Model层主要就是做一些网络请求，存储之类的数据相关操作，不可以持有对View的引用，他是通过Presenter去和View进行交互的。</p><h2 id="Presenter层：TestActivityPresenter"><a href="#Presenter层：TestActivityPresenter" class="headerlink" title="Presenter层：TestActivityPresenter"></a>Presenter层：TestActivityPresenter</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package com.example.testcustomtemplates.presenter;</span><br><span class="line"></span><br><span class="line">import android.content.Context;</span><br><span class="line">import com.example.testcustomtemplates.contact.TestActivityContact;</span><br><span class="line">import com.example.testcustomtemplates.model.TestActivityModel;</span><br><span class="line"></span><br><span class="line">public class TestActivityPresenter&lt;T&gt; implements TestActivityContact.Presenter&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private TestActivityContact.View mView;</span><br><span class="line">    private TestActivityModel mModel;</span><br><span class="line">    private Context context;</span><br><span class="line"></span><br><span class="line">    public TestActivityPresenter(TestActivityContact.View mView, Context context) &#123;</span><br><span class="line">        this.mView = mView;</span><br><span class="line">        this.context = context;</span><br><span class="line">        mModel = new TestActivityModel(context);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void succeed(T t) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void failed(T t) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void error(Throwable e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void unSubscribe() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Presenter层自然不必多说，他最好是不要持有View控件的引用，大部分的逻辑操作需要他来完成，不过不可避免的，如果业务逻辑复杂了，Presenter层也会变得臃肿，这也是MVP结构的一个短处。</p><h2 id="View层：TestActivity"><a href="#View层：TestActivity" class="headerlink" title="View层：TestActivity"></a>View层：TestActivity</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package com.example.testcustomtemplates.activity;</span><br><span class="line"></span><br><span class="line">import android.support.v7.app.AppCompatActivity;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import com.example.testcustomtemplates.R;</span><br><span class="line">import com.example.testcustomtemplates.contact.TestActivityContact;</span><br><span class="line">import com.example.testcustomtemplates.presenter.TestActivityPresenter;</span><br><span class="line"></span><br><span class="line">public class TestActivity&lt;T&gt; extends AppCompatActivity implements TestActivityContact.View&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private TestActivityContact.Presenter mPresenter;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_test);</span><br><span class="line">        new TestActivityPresenter&lt;T&gt;(this, this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setPresenter(TestActivityContact.Presenter presenter) &#123;</span><br><span class="line">        this.mPresenter = presenter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void succeed(T t) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void failed(T t) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void error(Throwable e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Activity或者Fragment都可以用作View层，这层主要是对一些视图控件的状态进行切换，不做复杂的逻辑操作。</p><p>看完上面的这些代码后，其实就可以开始直接编写我们的模版代码了。</p><h1 id="模版编写"><a href="#模版编写" class="headerlink" title="模版编写"></a>模版编写</h1><p>首先，可以Copy一份 <strong>EmptyActivity</strong> 整个模版的文件，然后改一下名字，随便什么都可以，这里我将其改成 <strong>MvpDemoActivity</strong></p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/009.png" alt="image"></p><p>然后我们首先对 <strong>template.xml</strong> 文件进行修改，主要修改下面这个部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;category value=&quot;Activity&quot; /&gt;</span><br></pre></td></tr></table></figure><p>然后是对 <strong>recipe.xml.ftl</strong> 文件进行修改，修改后如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;#import &quot;root://activities/common/kotlin_macros.ftl&quot; as kt&gt;</span><br><span class="line">&lt;recipe&gt;</span><br><span class="line">    &lt;#include &quot;../common/recipe_manifest.xml.ftl&quot; /&gt;</span><br><span class="line">    &lt;@kt.addAllKotlinDependencies /&gt;</span><br><span class="line"></span><br><span class="line">&lt;#if generateLayout&gt;</span><br><span class="line">    &lt;#include &quot;../common/recipe_simple.xml.ftl&quot; /&gt;</span><br><span class="line">    &lt;open file=&quot;$&#123;escapeXmlAttribute(resOut)&#125;/layout/$&#123;layoutName&#125;.xml&quot; /&gt;</span><br><span class="line">&lt;/#if&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--View-activity--&gt;</span><br><span class="line">    &lt;instantiate from=&quot;root/src/app_package/MvpActivity.java.ftl&quot;</span><br><span class="line">                   to=&quot;$&#123;escapeXmlAttribute(srcOut)&#125;/activity/$&#123;activityClass&#125;.java&quot; /&gt;</span><br><span class="line">&lt;!--Model--&gt;</span><br><span class="line">&lt;instantiate from=&quot;root/src/app_package/MvpModel.java.ftl&quot;</span><br><span class="line">                   to=&quot;$&#123;escapeXmlAttribute(srcOut)&#125;/model/$&#123;activityClass&#125;Model.java&quot; /&gt;</span><br><span class="line">&lt;!--Contact--&gt;</span><br><span class="line">&lt;instantiate from=&quot;root/src/app_package/MvpContact.java.ftl&quot;</span><br><span class="line">                   to=&quot;$&#123;escapeXmlAttribute(srcOut)&#125;/contact/$&#123;activityClass&#125;Contact.java&quot; /&gt;</span><br><span class="line">&lt;!--Presenter--&gt;</span><br><span class="line">&lt;instantiate from=&quot;root/src/app_package/MvpPresenter.java.ftl&quot;</span><br><span class="line">                   to=&quot;$&#123;escapeXmlAttribute(srcOut)&#125;/presenter/$&#123;activityClass&#125;Presenter.java&quot; /&gt;   </span><br><span class="line">    &lt;open file=&quot;$&#123;escapeXmlAttribute(srcOut)&#125;/activity/$&#123;activityClass&#125;.java&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/recipe&gt;</span><br></pre></td></tr></table></figure><p>上面的代码表示只编写了Java版，当然你在修改这个文件之前还是需要创建相对应的几个类的模版代码的。这里出于篇幅考虑暂时就不贴出实际的模版代码了，下面会给出github地址，编写了Java版和Kotlin版的，大家可以拿去参考</p><p><a href="https://github.com/asjqkkkk/TemplatesTest" target="_blank" rel="noopener">Github项目链接</a></p><p>当然，有好的模版也可以一起分享一下</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/010.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前有写过关于如何使用 DataBinding 的两篇文章，不仅仅是为了消灭掉一部分重复代码，更是为了提高开发效率。详情可以点击下方的传送门&lt;br&gt;&lt;a href=&quot;https://oldchen.top/2018/10/17/DataBinding%E2%80%94%E2%80%94%E4%BB%8E%E8%B7%AF%E4%BA%BA%E5%88%B0%E5%A5%BD%E5%8F%8B%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%88%9D%E9%81%87/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;DataBinding——从路人到好友（一）：初遇&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://oldchen.top/2018/10/20/DataBinding%E2%80%94%E2%80%94%E4%BB%8E%E7%9B%B8%E8%AF%86%E5%88%B0%E7%9B%B8%E7%9F%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BA%92%E9%85%8C/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;DataBinding——从相识到相知（二）：互酌&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Room Database入门指南</title>
    <link href="http://yoursite.com/2018/10/30/Room-Database%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2018/10/30/Room-Database入门指南/</id>
    <published>2018-10-30T11:12:38.000Z</published>
    <updated>2018-10-30T11:13:28.519Z</updated>
    
    <content type="html"><![CDATA[<p>说到Android端有哪些可以使用的数据库，大家首先想到的自然是SQLite这种带有官方属性加持的轻型的数据库。</p><p>不过对于像我这种基本上没有接触过SQL数据库语言编写的人来说，要通过去写难以查错且又毫不熟悉的数据库代码才能操作数据库的话，那就太令人头大了。</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/001-001.jpg" alt="image"></p><p>于是乎，便于Android开发者操作数据库的框架也就多了起来，其中人气较高的就有GreenDao、Realm，ObjectBox等，而Room则是谷歌官方十分推荐的，可以代替SQlite的不二之选。<br><a id="more"></a><br>本篇的主要介绍对象也是Room数据库，不过在此之前，还得简单介绍一下上面提到过的其他几位，同时做个小小的对比。</p><h1 id="一、介绍与比较"><a href="#一、介绍与比较" class="headerlink" title="一、介绍与比较"></a>一、介绍与比较</h1><p>由于我用过的数据库框架并不多，所以对于用过的可以说一下感受，没用过的就简单带过了。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="GreenDao-和-ObjectBox"><a href="#GreenDao-和-ObjectBox" class="headerlink" title="GreenDao 和 ObjectBox"></a>GreenDao 和 ObjectBox</h3><p>在这些数据库中， <strong>GreenDao</strong> 算是早闻其名，不过一直没有用过，后来它的作者又出了个 <strong>ObjectBox</strong> ，而且你可以在 <a href="https://github.com/greenrobot/greenDAO" target="_blank" rel="noopener"><strong>GreenDao</strong>的GitHub页面</a> 找到推荐使用 <strong>ObjectBox</strong> 的 <a href="https://objectbox.io/" target="_blank" rel="noopener">ObjectBox地址</a> .</p><h3 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h3><p>我真正使用过的还只有 <strong>Realm</strong> 数据库，这里要提一下，<strong>Realm</strong> 数据库对于中国的开发者非常的友好，就像大名鼎鼎的Glide一样， <strong>Realm</strong> 也有中文的介绍文档，文档地址在此：<br><a href="https://realm.io/cn/docs/java/latest/" target="_blank" rel="noopener">开始使用Realm</a><br>虽然这份文档对应的版本不是最新的. 不过对于初次接触 <strong>Realm</strong> 人来说，看这份文档就可以上手了</p><p>最开始使用Realm的时候也是碰过不少坑，不过最主要的是所有数据库对象需要继承 <strong>RealmObject</strong> 这个类(也可以通过接口实现)，这样对项目已有的数据结构不太友好，同时我还发现继承了 <strong>RealmObject</strong> 的对象并不能与 <strong>Gson</strong> 完美结合，如果需要转换的话，还是得费一番周折的。<br>种种原因，导致我最后从项目中抽去了Realm这个数据库.</p><h3 id="Room"><a href="#Room" class="headerlink" title="Room"></a>Room</h3><p>与 Realm 分手后的日子里，我并没有放弃对新的数据库的寻找，后来在浏览 Google官方文档的时候才发现了 <strong>Room</strong> 这个新的数据库，经过我一番使用后，就决定是它了！<br><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/001-002.jpg" alt="image"></p><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>因为懒惰的原因，我并没有做过深入的测试，下面会给出从网上找到的关于这些数据库的对比，原文地址如下：</p><p><a href="https://notes.devlabs.bg/realm-objectbox-or-room-which-one-is-for-you-3a552234fd6e" target="_blank" rel="noopener"><strong>Realm, ObjectBox or Room. Which one is for you?</strong></a></p><p>然后是数据量达到 <strong>100k/10k</strong> 的时候，进行增删改查等操作消耗的时间对比：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/001.jpeg" alt="image"><br><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/002.jpeg" alt="image"></p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/003.jpeg" alt="image"><br><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/004.jpeg" alt="image"></p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/005.jpeg" alt="image"><br><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/006.jpeg" alt="image"></p><p>可以看到，在各个方面，统统都是 <strong>ObjectBox</strong> 傲视群雄。<br>那这篇文章为什么还是要写介绍关于 <strong>Room Database</strong> 呢？</p><p>首先是官方Buff加持，和介绍文档里的一句话：<br><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/007.png" alt="image"><br><a href="https://developer.android.google.cn/training/data-storage/room/" target="_blank" rel="noopener">这里是Room的官方介绍文档地址</a></p><p>大致意思就是：<strong>我们强烈建议你用Roon去代替SQLite，不过如果你是个铁头娃非得用SQLite，那我们也没有办法。</strong></p><p>除了上面这段话，还有一点也可以作为选择Room的原因，就是对于Apk的“增量”是多少。据别人的测试</p><blockquote><p>ObjectBox和Realm分别占用1-1.5MB和3-4MB（大小取决于手机架构），而作为SQL封装的Room只占用大约50KB。在方法的增量上，Room只有300多个，ObjectBox和Realm则分别是1300和2000个</p></blockquote><p>当然，如果你的数据量很大的话，我觉得还是 <strong>ObjectBox</strong> 更加适合你，因为就从上面的操作数据对比来看， <strong>ObjectBox</strong> 太牛逼了！我以后肯定也会花时间去对 <strong>ObjectBox</strong> 做一番研究，不过目前还是先来介绍介绍 <strong>Room</strong> 吧。</p><h1 id="二、Room的结构"><a href="#二、Room的结构" class="headerlink" title="二、Room的结构"></a>二、Room的结构</h1><p>之前有说过，<strong>Room</strong> 是可以代替 <strong>SQLite</strong> 的，不过我觉得Google推出它更多的是为了搭配 <strong>DataBinding</strong> 使用，如果你对于 <strong>DataBinding</strong> 不太熟悉，可以看一看我前面的关于 <strong>DataBinding</strong> 的文章，这里就不再赘述了。下面就开始说说 <strong>Room</strong> 的结构。</p><p>Room主要分为三个部分，分别是 <strong>Database</strong>(数据库) 、<strong>Entity</strong>(实体) 、<strong>DAO</strong>(数据访问对象) </p><h2 id="Database-数据库"><a href="#Database-数据库" class="headerlink" title="Database(数据库)"></a>Database(数据库)</h2><p>数据库指的就是一个数据库对象，它继承于 <strong>RoomDataBase</strong> 这个类，并且需要用 <strong>@DataBase</strong> 注解，获取这个数据库对象的方法是通过调用 <strong>Room.databaseBuilder()</strong> 或者 <strong>Room.inMemoryDatabaseBuilder()</strong> ，后者表示在内存中存储数据，如果程序结束了数据也就消失了，所以一般还是使用前者。</p><h2 id="Entity-实体"><a href="#Entity-实体" class="headerlink" title="Entity(实体)"></a>Entity(实体)</h2><p>实体的概念就比较简单了，就类似于MySQL数据库里面的表，一个实体类相当于一个表，而一个实体类有多个属性，就相当于表的多个字段，这个看一看接下来关于 <strong>Entity</strong> 的代码便一目了然。</p><h2 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h2><p>关于 <strong>DAO</strong> ，抽象的概念就表示<strong>数据访问对象</strong>，在这里简单的解释一下就是数据操作接口，可以通过编写 <strong>DAO接口</strong> 对数据库进行增删改查等一系列操作。  </p><blockquote><p>PS:这些接口可以支持RxJava的哦！</p></blockquote><p>下面是图片说明：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/009.png" alt="image"></p><h1 id="三、开始使用"><a href="#三、开始使用" class="headerlink" title="三、开始使用"></a>三、开始使用</h1><p>在 <strong>Room</strong> 的使用过程中，也是遇到一些坑的，不过都已经解决掉了。如果你也遇到过某些问题，不妨对照一下我的接入流程，说不定就找到了问题所在。</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/008.png" alt="image"></p><h2 id="接入Gradle"><a href="#接入Gradle" class="headerlink" title="接入Gradle"></a>接入Gradle</h2><p>为了避免之后的单元测试出现 <font color="#DC143C">java.lang.RuntimeException: Method e in android.util.Log not mocked. See <a href="http://g.co/androidstudio/not-mocked" target="_blank" rel="noopener">http://g.co/androidstudio/not-mocked</a> for details.</font> 的错误，除了 <strong>Room</strong> 相关的依赖需要添加外，这里还需要再引用一下 <strong>robolectric单元测试库</strong> 解决问题！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    //room数据库</span><br><span class="line">    def room_version = &quot;1.1.1&quot;</span><br><span class="line">    implementation &quot;android.arch.persistence.room:runtime:$room_version&quot;</span><br><span class="line">    annotationProcessor &quot;android.arch.persistence.room:compiler:$room_version&quot;</span><br><span class="line">    kapt &quot;android.arch.persistence.room:compiler:$room_version&quot;      // 由于要使用Kotlin,这里使用了kapt</span><br><span class="line">    implementation &quot;android.arch.persistence.room:rxjava2:$room_version&quot;        //之后会用到rxjava，所以这里也可以有</span><br><span class="line">//    implementation &quot;android.arch.persistence.room:guava:$room_version&quot;        //由于我们不用guava，这行注释掉</span><br><span class="line">    testImplementation &quot;android.arch.persistence.room:testing:$room_version&quot; </span><br><span class="line">    </span><br><span class="line">    //robolectric测试</span><br><span class="line">    testImplementation &apos;org.robolectric:shadows-multidex:3.8&apos;</span><br><span class="line">    testImplementation &quot;org.robolectric:robolectric:3.8&quot;</span><br><span class="line">    //这样就资瓷单元测试咯！</span><br></pre></td></tr></table></figure><p>和我一样使用Kotlin的童鞋别忘了下面这行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;kotlin-kapt&apos;</span><br></pre></td></tr></table></figure><p>还有，需要做如下更改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">androidTestImplementation &apos;com.android.support.test:runner:1.0.2&apos;</span><br><span class="line"></span><br><span class="line">//更改为</span><br><span class="line">implementation &apos;com.android.support.test:runner:1.0.2&apos;</span><br></pre></td></tr></table></figure><p>这点一定要改哦！不然会出现一些莫名其妙的问题</p><p>相关库的依赖成功添加后就可以开始动手了！</p><h2 id="创建-Entity、Dao-与-DataBase"><a href="#创建-Entity、Dao-与-DataBase" class="headerlink" title="创建 Entity、Dao 与 DataBase"></a>创建 Entity、Dao 与 DataBase</h2><h3 id="创建Entity"><a href="#创建Entity" class="headerlink" title="创建Entity"></a>创建Entity</h3><p>首先，创建一个 <strong>Entity</strong> 对象，就把它命名为 <strong>Book</strong> 吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">class Book(@field:ColumnInfo(name = &quot;book_name&quot;)</span><br><span class="line">           var bookName: String?, var author: String?, var type: String?) &#123;</span><br><span class="line"></span><br><span class="line">    @PrimaryKey(autoGenerate = true)</span><br><span class="line">    var id: Int = 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Book</strong> 有三个属性，分别表示书名、作者、类型。其中有三点需要注意：</p><ul><li>每个 <strong>Entity对象</strong> 都需要使用 <strong>@Entity</strong> 注释声明</li><li><strong>@PrimaryKey</strong> 注释用于声明主键，这里还添加了 autoGenerate = true，表示它是自增的</li><li><strong>@ColumnInfo</strong> 注释用来给属性设置别名，如果 <strong>bookName</strong> 属性不设置别名的话，查询的时候可以通过 “<strong>bookName</strong>”进行查询，设置别名后就可以通过设置的“<strong>book_name</strong>” 进行查询了，看 <strong>DAO接口</strong> 便知</li></ul><h3 id="创建-DAO"><a href="#创建-DAO" class="headerlink" title="创建 DAO"></a>创建 DAO</h3><p>这里，通过 <strong>DAO接口</strong> 来对 <strong>Book</strong> 这个对象进行增删改查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@Dao</span><br><span class="line">interface BookDao &#123;</span><br><span class="line"></span><br><span class="line">    @get:Query(&quot;SELECT * FROM book&quot;)</span><br><span class="line">    val all: List&lt;Book&gt;</span><br><span class="line"></span><br><span class="line">    @Query(&quot;SELECT * FROM book WHERE author LIKE :author&quot;)</span><br><span class="line">    fun getBookByAuthor(author: String): List&lt;Book&gt;</span><br><span class="line"></span><br><span class="line">    @Query(&quot;SELECT * FROM book WHERE book_name LIKE :name&quot;)</span><br><span class="line">    fun getBookByNamer(name: String): List&lt;Book&gt;</span><br><span class="line"></span><br><span class="line">    @Insert</span><br><span class="line">    fun insert(book: Book): Long?</span><br><span class="line"></span><br><span class="line">    @Insert</span><br><span class="line">    fun insert(vararg books: Book): List&lt;Long&gt;</span><br><span class="line"></span><br><span class="line">    @Insert</span><br><span class="line">    fun insert(books: List&lt;Book&gt;): List&lt;Long&gt;</span><br><span class="line"></span><br><span class="line">    @Update</span><br><span class="line">    fun update(book: Book): Int</span><br><span class="line"></span><br><span class="line">    @Update</span><br><span class="line">    fun update(vararg books: Book): Int</span><br><span class="line"></span><br><span class="line">    @Update</span><br><span class="line">    fun update(books: List&lt;Book&gt;): Int</span><br><span class="line"></span><br><span class="line">    @Delete</span><br><span class="line">    fun delete(book: Book): Int</span><br><span class="line"></span><br><span class="line">    @Delete</span><br><span class="line">    fun delete(vararg books: Book): Int</span><br><span class="line"></span><br><span class="line">    @Delete</span><br><span class="line">    fun delete(books: List&lt;Book&gt;): Int</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <strong>DAO接口</strong>，同样需要进行几点说明：</p><ul><li><strong>DAO接口</strong> 需要使用 <strong>@Dao</strong> 注释进行声明</li><li><strong>Insert</strong> 操作可以使用 <strong>Long</strong> 作为返回值的类型，表示插入操作前的对象数量</li><li><strong>Update</strong> 和 <strong>Delete</strong> 操作可以使用 Int 作为返回值，表示更新或者删除的行数</li><li>返回类型还可以是 <strong>void</strong> ，如果结合 <strong>Rxjava</strong> 使用的话还可以是 <strong>Completable、Single、 Maybe、Flowable</strong>等，具体可以参见这篇文章：<a href="https://medium.com/androiddevelopers/room-rxjava-acb0cd4f3757" target="_blank" rel="noopener">Room 🔗 RxJava</a>(需要备好梯子，不过后续有时间的话我也会介绍一下Room搭配Rxjava的使用)</li></ul><p><strong>Dao接口</strong> 编写完成后，还剩下最重要的 <strong>DataBase</strong></p><h3 id="创建-DataBase"><a href="#创建-DataBase" class="headerlink" title="创建 DataBase"></a>创建 DataBase</h3><blockquote><p>由于实例化一个 <strong>RoomDatabase</strong> 对象的开销是比较大的，所以 <strong>DataBase</strong> 的使用需要遵循单例模式，只在全局创建一个实例即可。</p></blockquote><p>这里为了方便理解，还是使用java代码去创建一个 <strong>BookDataBase类</strong>，当然，转换成Kotlin只需要Shift + Alt + Ctrl + K 即可</p><p>如果你使用的是饿汉式的单例模式，在Kotlin中通过object修饰可达到同样效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Database(entities = &#123;Book.class&#125;, version = 1)</span><br><span class="line">public abstract class BookDataBase extends RoomDatabase &#123;</span><br><span class="line">    public abstract BookDao bookDao();</span><br><span class="line">    private static BookDataBase instance;</span><br><span class="line"></span><br><span class="line">    public static BookDataBase getInstance(Context context)&#123;</span><br><span class="line">        if (instance == null)&#123;</span><br><span class="line">            synchronized (BookDataBase.class)&#123;</span><br><span class="line">                if (instance == null)&#123;</span><br><span class="line">                    instance = create(context);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static BookDataBase create(Context context) &#123;</span><br><span class="line">        return Room.databaseBuilder( context,BookDataBase.class,&quot;book-db&quot;).allowMainThreadQueries().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的例子中有一些需要特别注意：</p><ul><li><strong>@Database</strong> 注释用于进行声明，同时还需要有相关的 <strong>entity对象</strong>，其中 <strong>version</strong> 是当前数据库的版本号，如果你对数据相关的<strong>实体类结构</strong>进行了更改，这里的 <strong>version</strong> 就需要<strong>加一</strong></li><li><strong>BookDataBase</strong> 除了继承于 <strong>RoomDatabase</strong> ，还需要实例出相关的 <strong>DAO接口</strong></li><li>create()方法中的”<strong>book-db</strong>“是数据库的名字，这里随意，不过需要注意的是 <strong>allowMainThreadQueries()</strong> 方法，这里由于我们会用到单元测试，所以加上这行代码是为了防止 【<em>Cannot access database on the main thread since it may potentially lock the UI for a long period of time.</em>】 的报错。正式使用时，请务必去掉这行代码，因为它会让所有耗时操作运行在主线程！</li></ul><p>到这里，我们就可以先愉快的进行测试了.</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="初级测试"><a href="#初级测试" class="headerlink" title="初级测试"></a>初级测试</h3><p>找到 <strong>src</strong> 下的 <strong>test</strong> 目录，然后可以像我这样创建一个 <strong>RoomTest</strong> 类进行测试</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/010.png" alt="image"></p><p>说到这里，可能会有童鞋尚未了解过单元测试，这时候你可以先去看看相关博客，比如这篇</p><p><a href="https://juejin.im/post/5b57e3fbf265da0f47352618" target="_blank" rel="noopener">Android 单元测试只看这一篇就够了</a></p><p>不过这里使用的单元测试是 Android Studio 自带的，也没有用到太复杂的东西，同时我会做一些说明，不够了解的童鞋也可以继续往下看，看完你也就了解了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(AndroidJUnit4::class)</span><br><span class="line">class RoomTest &#123;</span><br><span class="line"></span><br><span class="line">    private var bookDao: BookDao? = null</span><br><span class="line">    private var bookDataBase: BookDataBase? = null</span><br><span class="line"></span><br><span class="line">    @Before</span><br><span class="line">    @Throws(Exception::class)</span><br><span class="line">    fun setUp() &#123;</span><br><span class="line">        ShadowLog.stream = System.out      //这样方便打印日志</span><br><span class="line">        val context = InstrumentationRegistry.getTargetContext()</span><br><span class="line">        bookDataBase = BookDataBase.getInstance(context)</span><br><span class="line">        bookDao = bookDataBase!!.bookDao()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    fun insert() &#123;</span><br><span class="line">        val book1 = Book(&quot;时间简史&quot;, &quot;斯蒂芬·威廉·霍金&quot;, &quot;科学&quot;)</span><br><span class="line">        val book2 = Book(&quot;百年孤独&quot;, &quot;西亚·马尔克斯&quot;, &quot;文学&quot;)</span><br><span class="line">        val list = bookDao!!.insert(book1, book2)</span><br><span class="line"></span><br><span class="line">        assert(list.size == 2)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    fun query()&#123;</span><br><span class="line">        val books = bookDao!!.all</span><br><span class="line">        for (book in books) &#123;</span><br><span class="line">            Log.e(javaClass.name, &quot;获取的书籍数据: $&#123;Gson().toJson(book)&#125;&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @After</span><br><span class="line">    @Throws(Exception::class)</span><br><span class="line">    fun cloaseDb() &#123;</span><br><span class="line">        bookDataBase?.close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里的单元测试使用的是 <strong>AndroidJUnit4</strong>，通过 <strong>@Before</strong> 注释的方法，表示用于<strong>相关资源的初始化</strong>，类似于Activity的onCreate()方法；而通过 <strong>@After</strong> 注释的方法，则是用于<strong>相关资源的销毁</strong>，类似于Activity的onDestroy()方法。</p><p>剩下的，通过 <strong>@Test</strong> 注释的方法就表示用于测试的单元，每个测试类里面可以有多个测试单元，这里目前只写了插入和查询两个单元，在 <strong>RoomTest</strong> 类上通过右键运行，然后看一下结果：<br><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/011.png" alt="image"></p><p>在测试代码中的 <strong>insert()单元 </strong> 里，有这样一行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert(list.size == 2)</span><br></pre></td></tr></table></figure><p>而测试的结果是一片绿色，就表示这个断言是正确的，list列表长度刚好为2，这里为了验证返回的list是整个数据库长度还是仅仅表示此次进行插入操作的长度，我们修改一下 insert()测试单元：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"> fun insert() &#123;</span><br><span class="line">     val book1 = Book(&quot;时间简史&quot;, &quot;斯蒂芬·威廉·霍金&quot;, &quot;科学&quot;)</span><br><span class="line">     val book2 = Book(&quot;百年孤独&quot;, &quot;西亚·马尔克斯&quot;, &quot;文学&quot;)</span><br><span class="line">     val list = bookDao!!.insert(book1, book2)</span><br><span class="line">     assert(list.size == 2)</span><br><span class="line"></span><br><span class="line">     val list2 = bookDao!!.insert(book1, book2)</span><br><span class="line">     assert(list2.size == 4)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这时候在 <strong>insert()单元测试区域</strong> 右键运行，就只测试这一个单元，然后结果如下：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/012.png" alt="image"></p><p>我们在 insert()单元 中进行了两次插入操作，所以数据库的总长度应该为 4 ，而这里第39行的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert(list2.size == 4)</span><br></pre></td></tr></table></figure><p>返回的cede 是 -1，就表示实际上每次插入操作返回的列表长度应该为插入的数量，而非数据库总量。其他操作亦是如此。</p><p>在单元测试中，我们的测试并不能直接用于正式的项目中，因为数据库操作属于耗时操作，所以一定不能把这些操作放在主线程里，而最方便的线程切换，莫过于 <strong>Rxjava</strong> 啦！</p><p>现在开始使用 <strong>Rxjava</strong> 进行测试吧</p><h3 id="结合Rxjava的测试"><a href="#结合Rxjava的测试" class="headerlink" title="结合Rxjava的测试"></a>结合Rxjava的测试</h3><p>首先，要在项目中添加 <strong>Rxjava</strong> 的依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//rxJava2+rxAndroid</span><br><span class="line">implementation &quot;io.reactivex.rxjava2:rxjava:2.x.y&quot;</span><br><span class="line">implementation &apos;io.reactivex.rxjava2:rxandroid:2.1.0&apos;</span><br></pre></td></tr></table></figure><p>在单元测试中，RxJava 如果做 <strong>IO线程</strong> 到 <strong>UI线程</strong> 的切换操作，结果是无法获取的，所以需要将这些线程进行合并，方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Before</span><br><span class="line">@Throws(Exception::class)</span><br><span class="line">fun setUp() &#123;</span><br><span class="line">    val context = InstrumentationRegistry.getTargetContext()</span><br><span class="line">    bookDataBase = BookDataBase.getInstance(context)</span><br><span class="line">    bookDao = bookDataBase!!.bookDao()</span><br><span class="line">    ShadowLog.stream = System.out</span><br><span class="line"></span><br><span class="line">    initRxJava2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private fun initRxJava2() &#123;</span><br><span class="line">    RxJavaPlugins.reset()</span><br><span class="line">    RxJavaPlugins.setIoSchedulerHandler &#123; Schedulers.trampoline() &#125;</span><br><span class="line">    RxAndroidPlugins.reset()</span><br><span class="line">    RxAndroidPlugins.setMainThreadSchedulerHandler &#123; Schedulers.trampoline() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <strong>@Before注解</strong> 下的 <strong>setUp()</strong> 方法中进行RxJava的配置，然后我们可以把RxJava常用的线程切换写在一个方法里，方便复用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private fun&lt;T&gt; doWithRxJava(t: T): Observable&lt;T&gt;&#123;</span><br><span class="line">    return Observable.create&lt;T&gt;&#123;it.onNext(t)&#125;</span><br><span class="line">            .subscribeOn(Schedulers.io())</span><br><span class="line">            .unsubscribeOn(Schedulers.io())</span><br><span class="line">            .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，对 <strong>insert单元</strong> 和 <strong>query单元</strong> 进行修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">fun insert() &#123;</span><br><span class="line">    val book1 = Book(&quot;时间简史&quot;, &quot;斯蒂芬·威廉·霍金&quot;, &quot;科学&quot;)</span><br><span class="line">    val book2 = Book(&quot;百年孤独&quot;, &quot;西亚·马尔克斯&quot;, &quot;文学&quot;)</span><br><span class="line">    doWithRxJava(bookDao!!.insert(book1, book2))</span><br><span class="line">            .subscribe (&#123;</span><br><span class="line">                Log.e(&quot;insert长度：&quot; , &quot;$&#123;it.size&#125;&quot;)</span><br><span class="line">                assert(it.size == 2)</span><br><span class="line">            &#125;,&#123;</span><br><span class="line">                Log.e(&quot;insert出错：&quot; , &quot;$&#123;it.stackTrace&#125;-$&#123;it.message&#125;&quot;)</span><br><span class="line">            &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">fun query()&#123;</span><br><span class="line">    doWithRxJava(bookDao?.all)</span><br><span class="line">            .subscribe(&#123;</span><br><span class="line">                for(book in it?: emptyList())&#123;</span><br><span class="line">                    Log.e(javaClass.name, &quot;获取的书籍数据: $&#123;Gson().toJson(book)&#125;&quot;)</span><br><span class="line">                    assert(it?.size == 2)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,&#123;</span><br><span class="line">                Log.e(&quot;query出错：&quot; , &quot;$&#123;it.stackTrace&#125;-$&#123;it.message&#125;&quot;)</span><br><span class="line">            &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后看一下测试的结果：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/013.png" alt="image"></p><p>那么， <strong>Room DataBase</strong> 的入门指南，就写到这里啦！</p><p>后续我可能会再写一篇进阶版的文章，涵盖了真实使用的场景，然后看能不能写一个简单的Demo出来，这样更方便学习吧！</p><p><del><em>不过我发现我现在的懒癌是越来越严重了，也不知道下一篇是什么时候</em></del></p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/014.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说到Android端有哪些可以使用的数据库，大家首先想到的自然是SQLite这种带有官方属性加持的轻型的数据库。&lt;/p&gt;
&lt;p&gt;不过对于像我这种基本上没有接触过SQL数据库语言编写的人来说，要通过去写难以查错且又毫不熟悉的数据库代码才能操作数据库的话，那就太令人头大了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/001-001.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;于是乎，便于Android开发者操作数据库的框架也就多了起来，其中人气较高的就有GreenDao、Realm，ObjectBox等，而Room则是谷歌官方十分推荐的，可以代替SQlite的不二之选。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DataBinding——从相识到相知（二）：互酌</title>
    <link href="http://yoursite.com/2018/10/20/DataBinding%E2%80%94%E2%80%94%E4%BB%8E%E7%9B%B8%E8%AF%86%E5%88%B0%E7%9B%B8%E7%9F%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BA%92%E9%85%8C/"/>
    <id>http://yoursite.com/2018/10/20/DataBinding——从相识到相知（二）：互酌/</id>
    <published>2018-10-20T04:55:32.000Z</published>
    <updated>2018-10-20T04:56:35.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇里，主要讲了关于Databinding的以下几点：</p><ul><li>接入与使用</li><li>简单的数据绑定</li><li>点击事件的绑定</li></ul><p>这一篇将会继续上一篇的步伐，对DataBinding的使用更深几分.首先依旧是从数据绑定开始<br><a id="more"></a> </p><blockquote><p>之前所介绍的，虽然UI与数据进行了绑定，但是修改数据对象的时候并不会同时更新 <strong>UI</strong> .<br>现在有三种不同类型的 <strong>observable</strong> 类：<strong>objects</strong>, <strong>fields</strong>, 还有 <strong>collections</strong>.<br>当其中某个 <strong>observable</strong> 数据对象绑定到 <strong>UI</strong> 并且数据对象的属性发生更改时， UI 将自动更新，下面开始介绍.</p></blockquote><h1 id="Observable数据"><a href="#Observable数据" class="headerlink" title="Observable数据"></a>Observable数据</h1><p>如果你的数据类只有几个属性，那么没必要去实现 <strong>Observable</strong> 接口来监听数据的改变，可以使用下面这些字段：</p><ul><li><a href="https://developer.android.google.cn/reference/android/databinding/ObservableBoolean.html" target="_blank" rel="noopener"><strong>ObservableBoolean</strong></a></li><li><a href="https://developer.android.google.cn/reference/android/databinding/ObservableByte.html" target="_blank" rel="noopener"><strong>ObservableByte</strong></a></li><li><a href="https://developer.android.google.cn/reference/android/databinding/ObservableChar.html" target="_blank" rel="noopener"><strong>ObservableChar</strong></a></li><li><a href="https://developer.android.google.cn/reference/android/databinding/ObservableShort.html" target="_blank" rel="noopener"><strong>ObservableShort</strong></a></li><li><a href="https://developer.android.google.cn/reference/android/databinding/ObservableInt.html" target="_blank" rel="noopener"><strong>ObservableInt</strong></a></li><li><a href="https://developer.android.google.cn/reference/android/databinding/ObservableLong.html" target="_blank" rel="noopener"><strong>ObservableLong</strong></a></li><li><a href="https://developer.android.google.cn/reference/android/databinding/ObservableFloat.html" target="_blank" rel="noopener"><strong>ObservableFloat</strong></a></li><li><a href="https://developer.android.google.cn/reference/android/databinding/ObservableDouble.html" target="_blank" rel="noopener"><strong>ObservableDouble</strong></a></li><li><a href="https://developer.android.google.cn/reference/android/databinding/ObservableParcelable.html" target="_blank" rel="noopener"><strong>ObservableParcelable</strong></a></li></ul><p>现在，我们再创建一个类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class ObservableBean &#123;</span><br><span class="line">    val text = ObservableField&lt;String&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>布局文件改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;data&gt;</span><br><span class="line">        &lt;variable name=&quot;model&quot; type=&quot;com.test.project.testdatabinding.MVP.DataBinding.Bean.ObservableBean&quot;/&gt;</span><br><span class="line">    &lt;/data&gt;</span><br><span class="line"></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:orientation=&quot;vertical&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;EditText</span><br><span class="line">            android:id=&quot;@+id/et_test&quot;</span><br><span class="line">            android:text=&quot;@=&#123;model.text&#125;&quot;</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id=&quot;@+id/tv_test&quot;</span><br><span class="line">            android:text=&quot;@&#123;model.text&#125;&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;/&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line">&lt;/layout&gt;</span><br></pre></td></tr></table></figure><p>需要注意的是，上面的 <strong>EditText</strong> 的 <strong>text</strong> 属性使用的是 <strong>@={}</strong> 而 <strong>TextView</strong> 使用的是 <strong>@{}</strong> 。当你想要使用双向绑定的时候，可别忘了这个 <strong>=</strong> 号</p><p>Activity的代码只改变了绑定对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class DataBindingActivity&lt;T&gt; : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">//        setContentView(R.layout.activity_data_binding)</span><br><span class="line">        val bindingBinding : ActivityDataBindingBinding = DataBindingUtil.setContentView(this, R.layout.activity_data_binding)</span><br><span class="line">        bindingBinding.model = ObservableBean()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/DataBinding/two/databinding-001.gif" alt="image"></p><p>可以看到，直接使用 <strong>Observable</strong> 字段去实现双向数据绑定是很轻松的，不过实际项目里面需求各不相同，要将数据都换成 <strong>Observable</strong> 字段还是很麻烦的，所以自定义双向数据绑定非常有必要！</p><p>这时对 <strong>ObservableBean</strong> 进行修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class ObservableBean : BaseObservable() &#123;</span><br><span class="line">    @get:Bindable</span><br><span class="line">    var text: String = &quot;&quot;</span><br><span class="line">    set(value) &#123;</span><br><span class="line">        field = value</span><br><span class="line">        notifyPropertyChanged(BR.text)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//相较于Kotlin写法，这里我觉得Java写法更有助于理解：</span><br><span class="line">public  class ObservableBean extends BaseObservable &#123;</span><br><span class="line">    private String text;</span><br><span class="line"></span><br><span class="line">    @Bindable</span><br><span class="line">    public String getText() &#123;</span><br><span class="line">        return text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ObservableBean setText(String text) &#123;</span><br><span class="line">        this.text = text;</span><br><span class="line">        notifyPropertyChanged(BR.text);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改过后的效果与之前使用 <strong>Observable</strong> 字段的效果一样，上面需要注意的两点：</p><ul><li>使用了 <strong>@Bindable</strong> 注解，进行绑定声明</li><li>使用了 <strong>notifyPropertyChanged()</strong> 方法为数据刷新做准备</li></ul><p>不过在我看来，通过这种继承的方法对于我们原有的数据结构并不过友好，尤其是继承了 <strong>BaseObservable</strong> 类的数据类不能通过  <strong>Gson</strong> 去与 <strong>Json</strong> 相互转换。</p><p>所以使用的时候，我们可以考虑通过某个中介类的方式去进行转换.</p><h1 id="布局的绑定"><a href="#布局的绑定" class="headerlink" title="布局的绑定"></a>布局的绑定</h1><p>第第一篇中，有写到Activity中如何获取自动生成的布局绑定类——xxxBinding，这种类的命名与使用数据绑定的布局文件xml有关，比如说 <strong>activity_main.xml</strong> 就会生成 <strong>ActivityMainBinding</strong> </p><p>这里再详细说明一下，不同类型的布局，应该怎么获取生成的 <strong>Binding绑定类</strong> </p><blockquote><p>事先并不知道绑定类型的对象可以使用 <strong>DataBindingUtil</strong> 去创建绑定</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val rootView = LayoutInflater.from(this).inflate(layoutId, parent, attachToParent)</span><br><span class="line">val binding: ViewDataBinding? = DataBindingUtil.bind(viewRoot)</span><br></pre></td></tr></table></figure><h2 id="获取带-ID-的-View对象"><a href="#获取带-ID-的-View对象" class="headerlink" title="获取带 ID 的 View对象"></a>获取带 ID 的 View对象</h2><p>如果使用的是Kotlin，可以直接在Activity里很方便的使用id获取View对象，不过使用DataBinding后，就有另外一种获取View对象的方式了</p><p>布局里面的 Id 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    &lt;EditText</span><br><span class="line">        android:id=&quot;@+id/et_test&quot;</span><br><span class="line">        android:text=&quot;@=&#123;model.text&#125;&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot; /&gt;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>通过 Id 获取 EditText 的方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">super.onCreate(savedInstanceState)</span><br><span class="line">val bindingBinding : ActivityDataBindingBinding = DataBindingUtil.setContentView(this, R.layout.activity_data_binding)</span><br><span class="line">bindingBinding.model = ObservableBean()</span><br><span class="line">val editText = bindingBinding.root.rootView.findViewById&lt;EditText&gt;(R.id.et_test)</span><br></pre></td></tr></table></figure><blockquote><p><strong>立即绑定</strong>  </p><p>当变量或可观察对象发生更改时，绑定会在下一帧之前更改。 不过有的时候需要立刻执行绑定.  </p><p>若要强制执行，可以使用 <strong>executePendingBindings()</strong> 方法。</p></blockquote><h2 id="高级绑定"><a href="#高级绑定" class="headerlink" title="高级绑定"></a>高级绑定</h2><p>有时候，特定的绑定类是未知的.  </p><p>例如，针对任意布局操作的 <strong>RecyclerView.Adapter</strong> 不知道特定的绑定类.它仍然必须在调用 <strong>onBindViewHolder()</strong> 方法时分配绑定值.</p><p>在 <strong>RecyclerView</strong> 的  <strong>onBindViewHolder()</strong> 方法里，可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">override fun onBindViewHolder(holder: BindingHolder, position: Int) &#123;</span><br><span class="line">    item: T = mItems.get(position)</span><br><span class="line">    holder.binding.setVariable(BR.item, item);</span><br><span class="line">    holder.binding.executePendingBindings();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-BindingAdapter自定义绑定逻辑"><a href="#使用-BindingAdapter自定义绑定逻辑" class="headerlink" title="使用@BindingAdapter自定义绑定逻辑"></a>使用@BindingAdapter自定义绑定逻辑</h2><p>DataBinding为我们提供了一种可以对绑定逻辑进行自定义的方法，比如说我想在xml中对一个ImageView控件加载图片，并且是使用的Glide加载框架，这时候可以这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//随便创建一个类，然后在类中定义如下方法</span><br><span class="line">@BindingAdapter(&quot;imageUrl&quot;)</span><br><span class="line">fun loadImage(view: ImageView, url: String) &#123;</span><br><span class="line">    GlideApp.with(view.getContext())</span><br><span class="line">   .load(url)</span><br><span class="line">   .fitCenter()</span><br><span class="line">   .into(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候编译器会自动生成对应属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;ImageView </span><br><span class="line">app:imageUrl=&quot;@&#123;model.imageUrl&#125;&quot;  /&gt;</span><br></pre></td></tr></table></figure><p>使用 <strong>@BindAdapter</strong> 几乎可以完成你想要的各种逻辑，不过我觉得，只有那种使用率特别高的代码，才最适合这个属性.</p><h2 id="使用-BindingConversion完成转换功能"><a href="#使用-BindingConversion完成转换功能" class="headerlink" title="使用@BindingConversion完成转换功能"></a>使用@BindingConversion完成转换功能</h2><p>在某些情况下，特定类型之间需要自定义转换。 例如，视图的android:background属性需要Drawable，但指定的颜色值是整数。 </p><p>官方例子中，转换功能的具体用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@BindingConversion</span><br><span class="line">fun convertColorToDrawable(color: Int) = ColorDrawable(color)</span><br></pre></td></tr></table></figure><p>使用的时候可以这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;View</span><br><span class="line">   android:background=&quot;@&#123;isError ? @drawable/error : @color/white&#125;&quot;</span><br><span class="line">   android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">   android:layout_height=&quot;wrap_content&quot;/&gt;</span><br></pre></td></tr></table></figure><h1 id="暂歇"><a href="#暂歇" class="headerlink" title="暂歇"></a>暂歇</h1><p>本篇关于DataBindin的介绍也就到此结束，不过DataBinding的使用还没有到头，下一篇将会侧重实际上的操作以及DataBinding还可以为我们带来哪些便捷.</p><hr><h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上一篇里，主要讲了关于Databinding的以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接入与使用&lt;/li&gt;
&lt;li&gt;简单的数据绑定&lt;/li&gt;
&lt;li&gt;点击事件的绑定&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这一篇将会继续上一篇的步伐，对DataBinding的使用更深几分.首先依旧是从数据绑定开始&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DataBinding——从路人到好友（一）：初遇</title>
    <link href="http://yoursite.com/2018/10/17/DataBinding%E2%80%94%E2%80%94%E4%BB%8E%E8%B7%AF%E4%BA%BA%E5%88%B0%E5%A5%BD%E5%8F%8B%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%88%9D%E9%81%87/"/>
    <id>http://yoursite.com/2018/10/17/DataBinding——从路人到好友（一）：初遇/</id>
    <published>2018-10-17T13:15:39.000Z</published>
    <updated>2018-10-17T13:16:40.058Z</updated>
    
    <content type="html"><![CDATA[<h1 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h1><blockquote><p>在编程领域，对于一名初学者而言，最开始的进阶方式都是不断重复的练习，然后在练习中遇到各种困难，同时也在这个过程里积累了不少的经验。</p><p>一般情况下，我们获取的经验可以有效的减少我们的失误，也可以为我们预防掉许多“隐藏”的Bug。</p><p>但是，随着我们能力的提升，我们逐渐的对于那些重复性非常高、而且意义并不大的代码产生了厌倦感。首当其冲的就是像 <strong>findViewById</strong> 这样的代码！</p></blockquote><a id="more"></a> <p>大量的 <strong>findViewById</strong> 与全局变量想必是许多初学者都会经历的阶段，不过学的东西越多，对于这类代码的接受力也就越低。所以许多人选择用了 <strong>ButterKnife</strong> 去解决这个问题。</p><p>然鹅当 <strong>Kotlin</strong> 出现后，<strong>ButterKnife</strong> 也可以随之抛弃了，这时候 <strong>DataBinding</strong> 的用处却和 <strong>Kotlin</strong> 并不冲突，相反二者结合使用，反而会让你有意想不到的、久违的、可圈可点的、眼前一亮的、拍手称赞的体验！</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>使用 <strong>Data-Binding</strong> ，首先需要在 <strong>app moudle</strong> 下的 <strong>build.gradle</strong> 中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    dataBinding &#123;</span><br><span class="line">        enabled = true</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以正常使用了，不过需要注意，最低支持的Android版本是4.0（反正几乎没有比这更低的android设备了），gradle插件版本是1.5.0 （都2018年了，android开发者们肯定不能用比这更低的版本了吧！）</p><p>接下来，举个最简单的栗子，我们创建一个 <strong>Cartoon</strong> 类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Cartoon(var name:String = &quot;JOJO的奇妙冒险&quot; , var series :String = &quot;黄金之风&quot;,</span><br><span class="line">              var leader : String = &quot;乔鲁诺·乔巴纳&quot;, var feature : String = &quot;黄金体验&quot;) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后新建一个Activity，在这个Activity的xml中的根布局下，通过Alt+Enter快捷键创建databinding的布局，同时，导入 <strong>Cartoon</strong> 类：<br><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/DataBinding/one/databinding-001.png" alt="image"></p><p>这时候，编译器会自动根据这个布局生成相应的绑定类，这里会生成一个 <strong>ActivityDataBindingBinding</strong> 的类 ，暂时先不用管，我们继续在xml上工作，修改一下布局样式：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/DataBinding/one/databinding-002.png" alt="image"></p><p>然后，在对应的Activity内对生成的 <strong>ActivityDataBindingBinding</strong> 类进行操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class DataBindingActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">//        setContentView(R.layout.activity_data_binding)</span><br><span class="line">        val bindingBinding : ActivityDataBindingBinding = DataBindingUtil.setContentView(this, R.layout.activity_data_binding)</span><br><span class="line">        bindingBinding.cartoon = Cartoon()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于Kotlin创建的Cartoon实体类已经给每个字段都赋予了初始值，这里不用再进行赋值，然后看一下效果：<br><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/DataBinding/one/databinding-003.png" alt="image"></p><blockquote><p>如果你使用的是 items 去进行的绑定，例如Fragment、RecyclerView的adapter，可以使用 inflate() 的方法去绑定或者 DataBindingUtil 类，就像下面这样</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val listItemBinding = ListItemBinding.inflate(layoutInflater, viewGroup, false)</span><br><span class="line">// or</span><br><span class="line">val listItemBinding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, false)</span><br></pre></td></tr></table></figure><p>如果这时候你想使用字符串拼接，可以在 <strong>string.xml</strong> 中创建，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;string name=&quot;cartoon_name&quot;&gt;动漫名:%s&lt;/string&gt;</span><br><span class="line">&lt;string name=&quot;cartoon_series&quot;&gt;系列:%s&lt;/string&gt;</span><br><span class="line">&lt;string name=&quot;cartoon_leader&quot;&gt;主角:&lt;/string&gt;</span><br><span class="line">&lt;string name=&quot;cartoon_bodyDouble&quot;&gt;替身:&lt;/string&gt;</span><br></pre></td></tr></table></figure><p>使用的时候可以是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;data&gt;</span><br><span class="line">        &lt;variable name=&quot;cartoon&quot; type=&quot;com.test.project.testdatabinding.DataBinding.Cartoon&quot;/&gt;</span><br><span class="line">    &lt;/data&gt;</span><br><span class="line"></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:orientation=&quot;vertical&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:layout_gravity=&quot;center&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:text=&quot;@&#123;@string/cartoon_name(cartoon.name)&#125;&quot;/&gt;</span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:layout_gravity=&quot;center&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:text=&quot;@&#123;@string/cartoon_series(cartoon.series)&#125;&quot;/&gt;</span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:layout_gravity=&quot;center&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:text=&quot;@&#123;@string/cartoon_leader + cartoon.leader&#125;&quot;/&gt;</span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:layout_gravity=&quot;center&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:text=&quot;@&#123;@string/cartoon_bodyDouble + cartoon.feature&#125;&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line">&lt;/layout&gt;</span><br></pre></td></tr></table></figure><p>效果如下：<br><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/DataBinding/one/databinding-004.png" alt="image"></p><p>至此，我们完成了与DataBinding的初次接触！</p><p>可以看到，相较于往常的通过findViewById去获取控件实例，然后给控件设置数据的方法，这样显然去掉了Activity内许多不必要的代码。</p><p>不过以上只是比较简单的DataBinding用法，下面将会介绍DataBinding的其他功能，这样才能应更复杂的需求。</p><h2 id="集合的使用"><a href="#集合的使用" class="headerlink" title="集合的使用"></a>集合的使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;import type=&quot;android.util.SparseArray&quot;/&gt;</span><br><span class="line">    &lt;import type=&quot;java.util.Map&quot;/&gt;</span><br><span class="line">    &lt;import type=&quot;java.util.List&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;list&quot; type=&quot;List&lt;String&gt;&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;sparse&quot; type=&quot;SparseArray&lt;String&gt;&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;map&quot; type=&quot;Map&lt;String, String&gt;&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;index&quot; type=&quot;int&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;key&quot; type=&quot;String&quot;/&gt;</span><br><span class="line">&lt;/data&gt;</span><br><span class="line">…</span><br><span class="line">android:text=&quot;@&#123;list[index]&#125;&quot;</span><br><span class="line">…</span><br><span class="line">android:text=&quot;@&#123;sparse[index]&#125;&quot;</span><br><span class="line">…</span><br><span class="line">android:text=&quot;@&#123;map[key]&#125;&quot;  //这里也可以使用 @&#123;map.key&#125;代替</span><br></pre></td></tr></table></figure><h2 id="点击事件"><a href="#点击事件" class="headerlink" title="点击事件"></a>点击事件</h2><p>点击事件也是可以在xml中绑定的，在 DataBindingActivity 中添加如下方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun doClick(view: View)&#123;</span><br><span class="line">    Toast.makeText(this, &quot;点击测试&quot;, Toast.LENGTH_SHORT).show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不要忘了在括号中传入View</p><p>然后再xml中写一个button的点击事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">           android:text=&quot;DataBinding-点击测试&quot;</span><br><span class="line">           android:onClick=&quot;doClick&quot;</span><br><span class="line">           android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">           android:layout_height=&quot;wrap_content&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>如果想通过点击事件传入参数的话，可以通过下面这种方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;variable name=&quot;handler&quot; type=&quot;com.test.project.testdatabinding.DataBinding.DataBindingActivity&quot;/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;Button</span><br><span class="line">            android:text=&quot;DataBinding-点击测试&quot;</span><br><span class="line">            android:onClick=&quot;@&#123;() -&gt; handler.doClick(cartoon.name)&#125;&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot; /&gt;</span><br></pre></td></tr></table></figure><p>从xml中导入 DataBindingActivity 后，再修改代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class DataBindingActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">//        setContentView(R.layout.activity_data_binding)</span><br><span class="line">        val bindingBinding : ActivityDataBindingBinding = DataBindingUtil.setContentView(this, R.layout.activity_data_binding)</span><br><span class="line">        bindingBinding.cartoon = Cartoon()</span><br><span class="line">        bindingBinding.handler = this</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun doClick(message: String)&#123;</span><br><span class="line">        Toast.makeText(this, message, Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击效果如下：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/DataBinding/one/databinding-005.png" alt="image"></p><p>如果有更加复杂的点击事件，可以参考官介绍中的，如带View参数的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Presenter &#123;</span><br><span class="line">    fun onSaveClick(view: View, task: Task)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">android:onClick=&quot;@&#123;(theView) -&gt; presenter.onSaveClick(theView, task)&#125;&quot;</span><br></pre></td></tr></table></figure></p><h2 id="import-与-include"><a href="#import-与-include" class="headerlink" title="import 与 include"></a>import 与 include</h2><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>在xml中，可以通过导入一些工具类进行简单地操作，比如说导入View类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;import type=&quot;android.view.View&quot;/&gt;</span><br><span class="line">&lt;/data&gt;</span><br></pre></td></tr></table></figure><p>这样你就可以直接在xml中使用它的一些静态方法或者变量,官方的例子中简单地用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">   android:text=&quot;@&#123;user.lastName&#125;&quot;</span><br><span class="line">   android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">   android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">   android:visibility=&quot;@&#123;user.isAdult ? View.VISIBLE : View.GONE&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure><p>不过我觉得xml中不适合做太多逻辑判断的操作，所以使用的时候应该考虑一下某些操作是否真的合适</p><h3 id="include"><a href="#include" class="headerlink" title="include"></a>include</h3><p>如果你有在xml中使用到 include ，通过下面例子中的方法就行绑定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;</span><br><span class="line">    &lt;data&gt;</span><br><span class="line">        &lt;variable name=&quot;cartoon&quot; type=&quot;com.test.project.testdatabinding.DataBinding.Cartoon&quot;/&gt;</span><br><span class="line">    &lt;/data&gt;</span><br><span class="line"></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:orientation=&quot;vertical&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">        </span><br><span class="line">       &lt;include layout=&quot;@layout/layout_test&quot;</span><br><span class="line">           bind:cartoon=&quot;@&#123;cartoon&#125;&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line">&lt;/layout&gt;</span><br></pre></td></tr></table></figure></p><p>layout_test 布局：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;data&gt;</span><br><span class="line">        &lt;variable name=&quot;cartoon&quot; type=&quot;com.test.project.testdatabinding.DataBinding.Cartoon&quot;/&gt;</span><br><span class="line">    &lt;/data&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.constraint.ConstraintLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:text=&quot;@&#123;cartoon.name&#125;&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/android.support.constraint.ConstraintLayout&gt;</span><br><span class="line">&lt;/layout&gt;</span><br></pre></td></tr></table></figure><p>注意，要使用 bind 属性，可别忘了下面的这行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br></pre></td></tr></table></figure><h1 id="暂歇"><a href="#暂歇" class="headerlink" title="暂歇"></a>暂歇</h1><p>出于篇幅考虑，关于 <strong>DataBinding</strong> 的使用，暂且就讲到这里，关于它更详尽的用法，后续再作介绍。</p><hr><h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;杂谈&quot;&gt;&lt;a href=&quot;#杂谈&quot; class=&quot;headerlink&quot; title=&quot;杂谈&quot;&gt;&lt;/a&gt;杂谈&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;在编程领域，对于一名初学者而言，最开始的进阶方式都是不断重复的练习，然后在练习中遇到各种困难，同时也在这个过程里积累了不少的经验。&lt;/p&gt;
&lt;p&gt;一般情况下，我们获取的经验可以有效的减少我们的失误，也可以为我们预防掉许多“隐藏”的Bug。&lt;/p&gt;
&lt;p&gt;但是，随着我们能力的提升，我们逐渐的对于那些重复性非常高、而且意义并不大的代码产生了厌倦感。首当其冲的就是像 &lt;strong&gt;findViewById&lt;/strong&gt; 这样的代码！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>手把手教你接入android端微信支付</title>
    <link href="http://yoursite.com/2018/10/08/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E6%8E%A5%E5%85%A5android%E7%AB%AF%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/"/>
    <id>http://yoursite.com/2018/10/08/手把手教你接入android端微信支付/</id>
    <published>2018-10-08T12:19:09.000Z</published>
    <updated>2018-10-08T12:20:56.307Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android端接入微信支付，蛮简单的"><a href="#Android端接入微信支付，蛮简单的" class="headerlink" title="Android端接入微信支付，蛮简单的"></a>Android端接入微信支付，蛮简单的</h2><h3 id="一、添加gradle依赖："><a href="#一、添加gradle依赖：" class="headerlink" title="一、添加gradle依赖："></a>一、添加gradle依赖：</h3><p>在app module目录下的build.gralde中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    //微信SDK接入</span><br><span class="line">    implementation &apos;com.tencent.mm.opensdk:wechat-sdk-android-with-mta:+&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a> <p>gralde构建完成之后，再做下一步的操作。</p><h3 id="二、在AndroidManifest-xml中添加相关权限："><a href="#二、在AndroidManifest-xml中添加相关权限：" class="headerlink" title="二、在AndroidManifest.xml中添加相关权限："></a>二、在AndroidManifest.xml中添加相关权限：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--微信支付权限--&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.MODIFY_AUDIO_SETTINGS&quot;/&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;</span><br></pre></td></tr></table></figure><h3 id="三、创建wxapi目录，并创建WXPayEntryActivity"><a href="#三、创建wxapi目录，并创建WXPayEntryActivity" class="headerlink" title="三、创建wxapi目录，并创建WXPayEntryActivity"></a>三、创建wxapi目录，并创建WXPayEntryActivity</h3><p>在你的package目录下，创建<strong>wxapi</strong>目录，比如说我使用的demo项目，<strong>wxapi</strong>就在目录<strong>net.sourceforge.simcpux</strong>目录下</p><p>同时，在<strong>wxapi</strong>目录下创建<strong>WXPayEntryActivity</strong></p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/wxpay-001.png" alt="image"></p><p><strong>WXPayEntryActivity</strong>实现<strong>IWXAPIEventHandler</strong>接口，这个Activity页面就是支付结果的回调页面，下面是它最简单地实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class WXPayEntryActivity extends Activity implements IWXAPIEventHandler&#123;</span><br><span class="line"></span><br><span class="line">private static final String TAG = &quot;MicroMsg.SDKSample.WXPayEntryActivity&quot;;</span><br><span class="line"></span><br><span class="line">    private IWXAPI api;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.pay_result);</span><br><span class="line">        </span><br><span class="line">    api = WXAPIFactory.createWXAPI(this, &quot;你的appid&quot;);</span><br><span class="line">        api.handleIntent(getIntent(), this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onNewIntent(Intent intent) &#123;</span><br><span class="line">super.onNewIntent(intent);</span><br><span class="line">setIntent(intent);</span><br><span class="line">        api.handleIntent(intent, this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onReq(BaseReq req) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onResp(BaseResp resp) &#123;</span><br><span class="line">Log.d(TAG, &quot;onPayFinish, errCode = &quot; + resp.errCode);</span><br><span class="line"></span><br><span class="line">if (resp.getType() == ConstantsAPI.COMMAND_PAY_BY_WX) &#123;</span><br><span class="line">AlertDialog.Builder builder = new AlertDialog.Builder(this);</span><br><span class="line">builder.setTitle(&quot;支付结果&quot;);</span><br><span class="line">builder.setMessage(getString(R.string.pay_result_callback_msg, String.valueOf(resp.errCode)));</span><br><span class="line">builder.show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同时，别忘了在<strong>AndroidManifest.xml</strong>中声名<strong>WXPayEntryActivity</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;.wxapi.WXPayEntryActivity&quot;</span><br><span class="line">    android:exported=&quot;true&quot;</span><br><span class="line">    android:launchMode=&quot;singleTop&quot;&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;</span><br><span class="line">        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;</span><br><span class="line">        &lt;data android:scheme=&quot;你的appid&quot;/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><p>当这些准备工作都做好之后，就可以准备使用了。</p><h3 id="四、使用"><a href="#四、使用" class="headerlink" title="四、使用"></a>四、使用</h3><p>当你从服务端获取到订单的相关信息后，就可以调用支付接口了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">                IWXAPI api = WXAPIFactory.createWXAPI(context, null);</span><br><span class="line">                api.registerApp(IntentKey.WX_APP_ID);</span><br><span class="line">                PayReq req = new PayReq();</span><br><span class="line">                req.appId= &quot;wx8888888888888888&quot;;//你的微信appid</span><br><span class="line">                req.partnerId= &quot;1900000109&quot;;//商户号</span><br><span class="line">                req.prepayId= &quot;WX1217752501201407033233368018&quot;;//预支付交易会话ID</span><br><span class="line">                req.nonceStr= &quot;5K8264ILTKCH16CQ2502SI8ZNMTM67VS&quot;;//随机字符串</span><br><span class="line">                req.timeStamp= &quot;1412000000&quot;;//时间戳</span><br><span class="line">                req.packageValue= &quot;Sign=WXPay&quot;;扩展字段,这里固定填写Sign=WXPay</span><br><span class="line">                req.sign= &quot;C380BEC2BFD727A4B6845133519F3AD6&quot;;//签名</span><br><span class="line">//req.extData= &quot;app data&quot;; // optional</span><br><span class="line">                // 在支付之前，如果应用没有注册到微信，应该先调用IWXMsg.registerApp将应用注册到微信</span><br><span class="line">                api.sendReq(req);</span><br></pre></td></tr></table></figure></p><p>这里需要注意的是，上面的这些信息，都应该从服务器去获取，比如说随机字符串之类的长短也不一定和上面例子中的一致。具体是什么，得看你们的后端给的是什么。</p><p>不出意外的话，通过上面接口的调用，你就可以正常使用微信提供的APP支付了。</p><p>是不是非常简单？！</p><p><strong><em>然鹅。。。</em></strong></p><p>事情哪儿有这么顺利，到了真正使用的时候，遇到的问题可不少，下面会列举出遇到过的问题，然后说明解决办法。</p><h2 id="Android端接入微信支付，坑蛮多的"><a href="#Android端接入微信支付，坑蛮多的" class="headerlink" title="Android端接入微信支付，坑蛮多的"></a>Android端接入微信支付，坑蛮多的</h2><p><strong>微信支付app的接入，要我来说，对初次尝试的人非常不友好</strong></p><p>一般情况下，开发者使用新的工具都需要先看一看它的说明文档，如果说明文档写的够好，直接用就是了；如果文档介绍的不够全面，还需要有Demo提供参考。微信的App支付就属于后者。<br>下面是它的接入文档页面：</p><p><a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=1417751808&amp;token=&amp;lang=zh_CN" target="_blank" rel="noopener">Android接入指南</a>（还有其他相关信息也可以通过这个页面接入）</p><p>由于仅仅靠着文档的说明不足以让我掌握对微信支付的使用，所以自然而然的，Demo就成了初次接触微信支付者的学习教材啦！</p><p><a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=11_1" target="_blank" rel="noopener">Demo下载</a></p><p>当你接入Demo后，一系列的问题将会接踵而至，下面来看一看具体是什么问题</p><h3 id="接入Demo"><a href="#接入Demo" class="headerlink" title="接入Demo"></a>接入Demo</h3><p>将下载后的Demo按照Import moudule的方式接入到某个项目中：<br><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/wxpay-002.png" alt="image"></p><p>然后选中这个项目，进行编译：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/wxpay-003.png" alt="image"></p><p>接下来，编译器就开始报错了，找到报错的位置，发现是如下问题：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/wxpay-004.png" alt="image"></p><p><strong>到这里开始，我就要吐槽了</strong></p><p>这种问题一看就是找不到包了，于是我们看一下这个项目中的build.gralde中的依赖，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile files(&apos;libs/libammsdk.jar&apos;)</span><br><span class="line">    compile files(&apos;libs/wechat-sdk-android-with-mta-1.0.2.jar&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>很显然，是导入的本地jar包，为了方便起见，我们将这里的依赖修改成之前配置时的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    //微信SDK接入</span><br><span class="line">    implementation &apos;com.tencent.mm.opensdk:wechat-sdk-android-with-mta:+&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，我们还可以发现，重新构建完项目后，上面的问题并没有解决。</p><p>这时候我们在Android studio的中的<strong>External Libraries</strong>去看一看新构建的库:</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/wxpay-005.png" alt="image"></p><p>可以看到，正确的引用路径应该是把<strong>sdk</strong>换成<strong>opensdk</strong></p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/wxpay-006.png" alt="image"></p><p>当你将所有的路径都修改过来后，还会有如下问题：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/wxpay-007.png" alt="image"></p><p>将上面的 <strong>imgObj.imageUrl = url</strong> 修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imgObj.setImagePath(url);</span><br></pre></td></tr></table></figure><p>这个错误出现的地方有两处吧，当你把这些错误都解决后，再次进行编译，就可以正常运行啦！</p><p>Demo运行后的界面是这样的：</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/wxpay-008.png" alt="image"></p><p>到了这里，基本上就可以进行测试了，剩下的东西无需再多说，过程差不多和上面直接接入的流程一样，不过要demo里面的更加详细，只需多多观摩即可。</p><p>那么，最后还是说一下需要注意的点吧。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在微信开放平台上面设置app相关参数的时候，需要<strong>应用包名</strong>以及<strong>应用签名</strong></p><p><img src="https://pay.weixin.qq.com/wiki/doc/api/img/chapter8_5_2.png" alt="image"></p><p>获取应用签名的工具地址是：<a href="https://open.weixin.qq.com/zh_CN/htmledition/res/dev/download/sdk/Gen_Signature_Android.apk" target="_blank" rel="noopener">签名工具下载地址</a></p><blockquote><p>这里又要吐槽一下，签名工具就是一个apk，装到手机上后，输入包名，然后生成签名，最关键的是这个签名无法复制，使用下来就一个感受，不方便啊！！！！</p></blockquote><p>签名工具里面输入的包名就是之前提到过的，可以直接在Androidmanifest.xml中复制。</p><p><strong>但是</strong></p><pre><code>尽管包名一样，release版的项目和debug版的项目最后生成的签名都是不一样的，这点很重要！</code></pre><p><strong>所以如果你是用的debug进行测试，那么网站里面的签名一定要填写debug版下获取到的签名，正式发布的时候，要把它换成release版的！如果签名不一致，你是无法通过那个“-1”返回值获取到任何有效的错误信息的!切记！</strong></p><font face="STCAIYUN"><del>~</del><del>~</del><del>~</del><del>~</del><del>~</del>~~~~那么</font><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/wxpay-009.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Android端接入微信支付，蛮简单的&quot;&gt;&lt;a href=&quot;#Android端接入微信支付，蛮简单的&quot; class=&quot;headerlink&quot; title=&quot;Android端接入微信支付，蛮简单的&quot;&gt;&lt;/a&gt;Android端接入微信支付，蛮简单的&lt;/h2&gt;&lt;h3 id=&quot;一、添加gradle依赖：&quot;&gt;&lt;a href=&quot;#一、添加gradle依赖：&quot; class=&quot;headerlink&quot; title=&quot;一、添加gradle依赖：&quot;&gt;&lt;/a&gt;一、添加gradle依赖：&lt;/h3&gt;&lt;p&gt;在app module目录下的build.gralde中添加&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dependencies &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //微信SDK接入&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    implementation &amp;apos;com.tencent.mm.opensdk:wechat-sdk-android-with-mta:+&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kotlin笔记(五):基础篇latest</title>
    <link href="http://yoursite.com/2018/10/05/Kotlin%E7%AC%94%E8%AE%B0-%E4%BA%94-%E5%9F%BA%E7%A1%80%E7%AF%87latest/"/>
    <id>http://yoursite.com/2018/10/05/Kotlin笔记-五-基础篇latest/</id>
    <published>2018-10-05T05:04:28.000Z</published>
    <updated>2018-10-08T12:22:12.396Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-可空类型"><a href="#1-可空类型" class="headerlink" title="1.可空类型"></a>1.可空类型</h3><p>问号可以加在任何类型的后面来表示这个类型的变量可以存储 null 引用 ： String?、 Int?、 MyCustomType? ，等等</p><p>一旦你有一个可空类型的值，能对它进行的操作也会受到限制。例如，不能再调用它的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; fun strLenSafe(s: String?) = s.length() </span><br><span class="line">ERROR: only safe (?.) or non null asserted (!!.) calls are allowed on a nullable receiver of type kotlin.String?</span><br></pre></td></tr></table></figure></p><a id="more"></a> <p>也不能把它赋值给非空类型的变量 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; val x: String? = null </span><br><span class="line">&gt;&gt; var y: String = x </span><br><span class="line">ERROR: Type mismatch: inferred type is String? but String was expected </span><br><span class="line">``` </span><br><span class="line">也不能把可空类型的值传给拥有非空类型参数的函数 ：</span><br></pre></td></tr></table></figure></p><blockquote><blockquote><p>strLen(x)<br>ERROR: Type mismatch: inferred type is String? but String was expected<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">那么你可以对它做什么呢？最重要的操作就是和 null 进行比较。 而且一旦你 进行了比较操作，编译器就会记住，并且在这次比较发生的作用域内把这个值当作非空来对待</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 2.安全调用运算符：&quot;?.&quot;</span><br><span class="line"></span><br><span class="line">&gt; Kotlin的弹药库中最有效的一种工具就是安全调用运算符：?.，它允许你把一 次null检查和一次方法调用合并成一个操作。</span><br><span class="line"></span><br><span class="line">例如，表达式 s?.toUpperCase() 等同于下面这种烦琐的写法：if(s!=null) s.toUpperCase() else null。 </span><br><span class="line"></span><br><span class="line">### 3.Elvis运算符：&quot;?:&quot; </span><br><span class="line"></span><br><span class="line">Kotlin 有方便的运算符来提供代替null的默认值。它被称作**Elvis运算符**（或者 null合并运算符，如果你喜欢听起来更严肃的名称）。下面展示了它是如何使用的：</span><br></pre></td></tr></table></figure></p></blockquote></blockquote><p>fun foo(s: String?) {<br>    val t: String= s?:””<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*Elvis 运算符接收两个运算数，如果第一个运算数不为null，运算结果就是第 一个运算数；如果第一个运算数为null，运算结果就是第二个运算数。*</span><br><span class="line"></span><br><span class="line">### 4.安全转换：&quot;as?&quot;</span><br><span class="line"></span><br><span class="line">&gt; as? 运算符尝试把值转换成指定的类型，如果值不是合适的类型就返回 null</span><br><span class="line"></span><br><span class="line">一种常见的模式是把安全转换和 Elvis 运算符结合使用。例如，实现 equals 方法的时候这样的用法非常方便。</span><br></pre></td></tr></table></figure></p><p>class Person(val firstNarne: String, val lastNarne: String){<br>    override fun equals(o: Any?): Boolean {<br>        val otherPerson = o as? Person?: return false<br>        return otherPerson.firstNarne == firstNarne &amp;&amp; otherPerson.lastNarne == lastNarne<br>    }</p><pre><code>override fun hashCode(): Int = firstNarne.hashCode() * 37 + lastNarne.hashCode() </code></pre><p>}</p><blockquote><blockquote><p>val pl = Person ( “Drnitry”,”Jernerov”)<br>val p2 = Person ( “Drnitry”,”Jernerov”)<br>println (pl == p2)<br>true<br>println(pl.equals(42))<br>false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 5.非空断言：&quot;!!&quot;</span><br><span class="line"></span><br><span class="line">&gt; 非空断言是 Kotlin 提供给你的最简单直率的处理可空类型值的工具。它使用双感叹号表示，可以把任何值转换成非空类型。如果对 null 值做非空断言，则会抛出异常。</span><br><span class="line"></span><br><span class="line">某些问题适合用非空断言来解决。当你在一个函数中检查一个值是否为null，而在另一个函数中使用这个值时，这种情况下编译器无法识别这种用法是否安全。如果你确信这样的检查一定在其他某个函数中存在，你可能不想在使用这个值之前重复检查，这时你就可以使用非空断言。</span><br><span class="line"></span><br><span class="line"> 当你使用 !! 并且它的结果是异常时， 异常调用械的跟踪信息只表明异常发生在哪一行代码，而不会表明异常发生在哪一个表达 式。 为了让跟踪信息更清晰精确地表示哪个值为 null，最好避免在同一行中使用多个!!断言</span><br><span class="line"></span><br><span class="line">### 6.&quot;let&quot;函数</span><br><span class="line"></span><br><span class="line">&gt; let 函数让处理可空表达式变得更容易。 和安全调用运算符一起，它允许你对表达式求值，检查求值结果是否为 null，并把结果保存为一个变量。 所有这些动作都在同一个简洁的表达式中。 </span><br><span class="line"></span><br><span class="line">下面举个栗子：</span><br></pre></td></tr></table></figure></p></blockquote></blockquote><p>fun sendEmailTo(email: String) { /<em> … </em>/ }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不能把可空类型的值传上面给这个函数：</span><br></pre></td></tr></table></figure></p><blockquote><blockquote><p>val email: String? = …<br>sendEmailTo(email)<br>ERROR: Type mismatch: inferred type is String? but String was expected<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">必须显式地检查这个值不为 null:</span><br></pre></td></tr></table></figure></p></blockquote></blockquote><p>if (email != null) sendEmailTo(email)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果使用了let函数，会是下面这样子的：</span><br></pre></td></tr></table></figure></p><p>email?.let { email -&gt; sendEmailTo(email) }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">**let** 函数只在 email 的值非空时才被调用，所以你就能在 lambda 中把 email 当作非空的实参使用。</span><br><span class="line">使用自动生成的名字 it 这种简明语法之后，上面的代码就更短了 ：</span><br></pre></td></tr></table></figure></p><p> email?.let{ sendEmailTo(it) ｝<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 7.延迟初始化的属性</span><br><span class="line"></span><br><span class="line">Kotlin 通常要求你在构造方法中初始化所有属性，如果某个属性是 非空类型，你就必须提供非空的初始化值。否则，你就必须使用可空类型。否则， 你就必须使用可空类型。如果你这样做，该属性的每一次访问都需要 null 检查或者 !! 运算符。</span><br></pre></td></tr></table></figure></p><p>class MyService {<br>    fun performAction() : String = “foo”<br>}</p><p>class MyTest{<br>    private var myService: MyService? = null </p><pre><code>@Before fun setUp(){    myService = MyService() }@Test fun testAction(){    //必须注意可空性：要么 用!!， 要么用?.    Assert.assertEquals( &quot;foo&quot; ， myService!!.performAction() ) }</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这段代码很难看，尤其是你要反复使用这个属性的时候。 </span><br><span class="line">为了解决这个问题， 使用 **lateinit** 修饰符来完成这样的声明。</span><br></pre></td></tr></table></figure></p><p>class MyService {<br>    fun performAction() : String = “foo”<br>}</p><p>class MyTest{<br>    //声明一个不需要初始化 器的非空类型的属性<br>    private lateinit var myService: MyService</p><pre><code>@Before fun setUp(){    myService = MyService() }@Test fun testAction(){    //不需要 null 检查直接访问属性    Assert.assertEquals( &quot;foo&quot; ， myService!!.performAction() ) }</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*注意， 延迟初始化的属性都是 var，因为需要在构造方法外修改它的值*</span><br><span class="line"></span><br><span class="line">### 8.&quot;Any&quot;和&quot;Any?&quot;：根类型</span><br><span class="line"></span><br><span class="line">&gt; 和 Object 作为 Java 类层级结构的根差不多， **Any** 类型是 Kotlin 所有非空类型的超类型（非空类型的根）。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 但是在 Java 中， Object 只是所有引用类型的超类 型（引用类型的根），而基本数据类型并不是类层级结构的一部分。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 这意味着当你 需要 Object 的时候，不得不使用像 java.lang.Integer 这样的包装类型来表示基本数据类型的值。 **而在 Kotlin 中， Any 是所有类型的超类型（所有类型的根）**， 包括像 Int 这样的基本数据类型。 </span><br><span class="line"></span><br><span class="line">和 Java 一样，把基本数据类型的值赋给 **Any** 类型的变量时会自动装箱：</span><br></pre></td></tr></table></figure></p><p>val answer: Any = 42<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*注意 **Any** 是非空类型，所以 **Any** 类型的变量不可以持有 null 值*</span><br><span class="line"></span><br><span class="line">### 9.Unit 类型 ： Kotlin 的&quot;void&quot;</span><br><span class="line"></span><br><span class="line">Kotlin 中的 **Unit** 类型完成了 Java 中的 void 一样的功能。当函数没什么有意思的结果要返回时，它可以用作函数的返回类型：</span><br></pre></td></tr></table></figure></p><p>fun f () : Unit { . . . }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法上，这和写一个带有代码块体但不带类型声明的函数没有什么不同：</span><br></pre></td></tr></table></figure></p><p>fun f () { .. }         //缩写版<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; Unit 是一个完备的类型，可以作为类型参数，而 void 却不行。</span><br><span class="line"></span><br><span class="line">在函数式编程语言中， Unit 这个名字习惯上被用来表示“只有一个实例”，这正是 Kotlin 的 Unit 和 Java 的 void 的区别。</span><br><span class="line"></span><br><span class="line">### 10.Nothing类型：“这个函数永不返回”</span><br><span class="line"></span><br><span class="line">对某些 Kotlin 函数来说，&quot;返回类型&quot;的概念没有任何意义，因为它们从来不会成功地结束</span><br><span class="line">,Kotlin 使用一种特殊的返回类型 Nothing 来表示：</span><br></pre></td></tr></table></figure></p><p>fun fail(message: String): Nothing {<br>    throw IllegalStateException (message)<br>}</p><blockquote><blockquote><p>fail (“Error occurred”)<br>java.lang.IllegalStateException: Error occurred<br><code>`</code><br>Nothing 类型没有任何值， 只有被当作函数返回值使用，或者被当作泛型函数 返回值的类型参数使用才会有意义。在其他所有情况下，声明一个不能存储任何值 的变量没有任何意义。 </p></blockquote></blockquote><h3 id="11-可空性和集合"><a href="#11-可空性和集合" class="headerlink" title="11.可空性和集合"></a>11.可空性和集合</h3><p>遍历一个包含可空值的集合并过滤掉 null 是一个非常常见的操作，因此 Kotlin 提供了一个标准库函数 <strong>filterNotNull</strong> 来完成它。 </p><h3 id="12-只读集合与可变集合"><a href="#12-只读集合与可变集合" class="headerlink" title="12.只读集合与可变集合"></a>12.只读集合与可变集合</h3><p>Kotlin 的集合设计和 Java 不同的另一项重要特质是，它把访问集合数据的接口和修改集合数据的接口分开了。这种区别存在于最基础的使用集合的接口之中:kotlin.collections.Collection。</p><p>使用 kotlin.collections.MutableCollection 接口可以修改集合中的数据。它继承了普通的 kotlin.collections.Collection 接口,还提供了方法来添加和移除元素、清空集合等。 </p><p>一般的规则是在代码的任何地方都应该使用只读接口，只在代码需要修改集合的地方使用可变接口的变体</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-可空类型&quot;&gt;&lt;a href=&quot;#1-可空类型&quot; class=&quot;headerlink&quot; title=&quot;1.可空类型&quot;&gt;&lt;/a&gt;1.可空类型&lt;/h3&gt;&lt;p&gt;问号可以加在任何类型的后面来表示这个类型的变量可以存储 null 引用 ： String?、 Int?、 MyCustomType? ，等等&lt;/p&gt;
&lt;p&gt;一旦你有一个可空类型的值，能对它进行的操作也会受到限制。例如，不能再调用它的方法&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt; fun strLenSafe(s: String?) = s.length() &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ERROR: only safe (?.) or non null asserted (!!.) calls are allowed on a nullable receiver of type kotlin.String?&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kotlin笔记(四):基础篇most plus</title>
    <link href="http://yoursite.com/2018/10/03/Kotlin%E7%AC%94%E8%AE%B0-%E5%9B%9B-%E5%9F%BA%E7%A1%80%E7%AF%87most-plus/"/>
    <id>http://yoursite.com/2018/10/03/Kotlin笔记-四-基础篇most-plus/</id>
    <published>2018-10-03T01:48:16.000Z</published>
    <updated>2018-10-03T01:48:58.682Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-成员引用"><a href="#1-成员引用" class="headerlink" title="1.成员引用"></a>1.成员引用</h3><p>Kotlin和Java8一样，如果把函数转换成一个值，你就可以传递它。  </p><blockquote><p>使用:: 运算符来转换 ：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val getAge = Person::age</span><br></pre></td></tr></table></figure><p>这种表达式称为成员引用，它提供了简明语法，来创建一个调用单个方法或者 访问单个属性的函数值。双冒号把类名称与你要引用的成员（一个方法或者一个属性）名称隔开<br><a id="more"></a> </p><h3 id="2-集合的函数式API"><a href="#2-集合的函数式API" class="headerlink" title="2.集合的函数式API"></a>2.集合的函数式API</h3><p><strong>filter</strong> 函数遍历集合并选出应用给定 <strong>lambda</strong> 后会返回 <strong>true</strong> 的那些元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; val list= listOf(l, 2, 3, 4) </span><br><span class="line">&gt;&gt; println(list.filter&#123;it % 2 == 0&#125;)</span><br></pre></td></tr></table></figure><p><strong>filter</strong> 函数可以从集合中移除你不想要的元素，但是它并不会改变这些元素。 元素的变换是 <strong>map</strong> 的用武之地。 </p><p><strong>map</strong> 函数对集合中的每一个元素应用给定的函数并把结果收集到一个新集合。可以把数字列表变换成它们平方的列表，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; val list= listOf(l, 2, 3, 4) </span><br><span class="line">&gt;&gt; println(list.map &#123; it * it &#125;</span><br><span class="line">&#123;1, 4, 9, 16&#125;</span><br></pre></td></tr></table></figure><h3 id="3-”all””any””count”和”find”：对集合应用判断式"><a href="#3-”all””any””count”和”find”：对集合应用判断式" class="headerlink" title="3.”all””any””count”和”find”：对集合应用判断式"></a>3.”all””any””count”和”find”：对集合应用判断式</h3><p>检查集合中的所有元素是否都符合某个条件（或者它的变种，是否存在符合的元素）。Kotlin中，它们是通过 <strong>all</strong> 和 <strong>any</strong> 函数表达的。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val canBeinClub27 = &#123; p: Person - &gt; p.age &lt;= 27 &#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果你对是否所有元素都满足判断式感兴趣，应该使用 <strong>all</strong> 函数：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; val people= listOf(Person (&quot;Alice&quot;, 27), Person(&quot;Bob&quot;, 31))</span><br><span class="line">&gt;&gt; println( people.all(canBeinClub27) ) </span><br><span class="line">false</span><br></pre></td></tr></table></figure><blockquote><p>如果你需要检查集合中是否至少存在一个匹配的元素，那就用 <strong>any</strong> :</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; println(people any(canBeinClub27)) </span><br><span class="line">true</span><br></pre></td></tr></table></figure><blockquote><p>如果你想知道有多少个元素满足了判断式，使用 <strong>count</strong> : </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; val people= listOf(Person(&quot;Alice&quot;, 27) , Person (&quot;Bob&quot;, 31)) </span><br><span class="line">&gt;&gt; println(people.count(canBeinClub27))</span><br><span class="line">1</span><br></pre></td></tr></table></figure><blockquote><p>要找到一个满足判断式的元素，使用 <strong>find</strong> 函数 ：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; val people= listOf(Person(&quot;Alice&quot;， 27) , Person(&quot;Bob&quot;, 31)) </span><br><span class="line">&gt;&gt; println(people.find(canBeinClub27)) </span><br><span class="line">Person(name=Alice, age=27)</span><br></pre></td></tr></table></figure><h3 id="4-groupBy-：把列表转换成分组的-map"><a href="#4-groupBy-：把列表转换成分组的-map" class="headerlink" title="4.groupBy ：把列表转换成分组的 map"></a>4.groupBy ：把列表转换成分组的 map</h3><p>假设你需要把所有元素按照不同的特征划分成不同的分组。例如，你想把人按年龄分组，相同年龄的人放在一组。把这个特征直接当作参数传递十分方便。<strong>groupBy</strong> 函数可以帮你做到这一点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; val people= listOf(Person(&quot;Alice&quot;, 31), Person(&quot;Bob&quot;, 29), Person (&quot;Carol&quot;, 31))</span><br><span class="line">&gt;&gt; println(people.groupBy &#123;it.age&#125;)</span><br></pre></td></tr></table></figure><p>这次操作的结果是一个 <strong>map</strong>，是元素分组依据的键（这个例子中是age）和元素分组（persons）之间的映射</p><h3 id="5-flatMap-和-flatten-：处理嵌套集合中的元素"><a href="#5-flatMap-和-flatten-：处理嵌套集合中的元素" class="headerlink" title="5.flatMap 和 flatten ：处理嵌套集合中的元素"></a>5.flatMap 和 flatten ：处理嵌套集合中的元素</h3><p>假设你有一堆藏书，使用 Book 类表示 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Book (val title: String, val authors: List&lt;String&gt;)</span><br></pre></td></tr></table></figure><p>每本书都可能有一个或者多个作者，可以统计出图书馆中的所有作者的 set : </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">books.flatMap &#123; it.authors &#125; toSet()</span><br></pre></td></tr></table></figure><p><strong>flatMap</strong> 函数做了两件事情：首先根据作为实参给定的函数对集合中的每个元素做变换（或者说映射），然后把多个列表合并（或者说平铺）成一个列表。 </p><blockquote><p><strong>注意，如果你不需要做任何变换，只是需要平铺一个集合，可以使用flatten函数：listOfLists.flatten() 。</strong></p></blockquote><p>Kotlin 标准库参考文档有说明，<strong>filter</strong> 和 <strong>map</strong> 都会返回一个列表。这意味着元素过多的时候，（链式）调用就会变得十分低效。为了提高效率，可以把操作变成使用序列，而不是直接使用集合，下面是对比的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">people.map(Person: :name) .filter &#123; it.startsWith(&quot;A&quot;)｝</span><br></pre></td></tr></table></figure><p>转化为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">people.asSequence()</span><br><span class="line">    .map (Person: : name)</span><br><span class="line">    .filter&#123;it.startsWith(&quot;A&quot;)&#125;</span><br><span class="line">    .tolist</span><br></pre></td></tr></table></figure></p><p>Kotlin惰性集合操作的入口就是 <strong>Sequence</strong> 接口。这个接口表示的就是一个可以逐个列举元素的元素序列。 </p><p>可以调用扩展函数 <strong>asSequence</strong> 把任意集合转换成序列，调用  <strong>toList</strong> 来做反向的转换。 </p><h3 id="6-使用Java函数式接口"><a href="#6-使用Java函数式接口" class="headerlink" title="6.使用Java函数式接口"></a>6.使用Java函数式接口</h3><p> <strong>OnClickListener</strong> 接口只有一个抽象方法。这种接口被称为 <strong>函数式接口</strong>，或者 <strong>SAM接口</strong>，<strong>SAM</strong> 代表抽象方法。JavaAPI中随处可见像<strong>Runnable</strong>和<strong>Callable</strong>这样的函数式接口，以及支持它们<br> 的方法。 Kotlin 允许你在调用接收函数式接口作为参数的方法时使用 <strong>lambda</strong>，来保证你的 Kotlin代码既整洁又符合习惯。</p><p>可以把 <strong>lambda</strong> 传给任何期望函数式接口的方法。例如，下面这个方法，它有一个 <strong>Runnable</strong> 类型的参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Java */ </span><br><span class="line">void postponeComputation(int delay, Runnable computation);</span><br></pre></td></tr></table></figure><p>下面是显式地创建一个实现了 <strong>Runnable</strong> 的匿名对象的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">post postponeComputation(1OOO, object : Runnable &#123; </span><br><span class="line">    override fun run() &#123;</span><br><span class="line">    println(42) </span><br><span class="line">    &#125;</span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure><p>在 Kotlin 中，可以调用它并把一个 <strong>lambda</strong> 作为实参传给它。编译器会自动把它转换成一个 <strong>Runnable</strong> 的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">postponeComputation(lOOO) &#123; println(42) &#125;</span><br></pre></td></tr></table></figure><p>完全等价的实现应该是下面这段代码中的显式<strong>object</strong>声明，它把<strong>Runnable</strong>实例存储在一个变量中，并且每次调用的时候都使用这个变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val runnable = Runnable &#123; println(42) &#125; </span><br><span class="line">fun handleComputation()&#123; postponeComputation(1OOO, runnable)&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-成员引用&quot;&gt;&lt;a href=&quot;#1-成员引用&quot; class=&quot;headerlink&quot; title=&quot;1.成员引用&quot;&gt;&lt;/a&gt;1.成员引用&lt;/h3&gt;&lt;p&gt;Kotlin和Java8一样，如果把函数转换成一个值，你就可以传递它。  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用:: 运算符来转换 ：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;val getAge = Person::age&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种表达式称为成员引用，它提供了简明语法，来创建一个调用单个方法或者 访问单个属性的函数值。双冒号把类名称与你要引用的成员（一个方法或者一个属性）名称隔开&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kotlin笔记(三):基础篇more plus</title>
    <link href="http://yoursite.com/2018/10/02/Kotlin%E7%AC%94%E8%AE%B0-%E4%B8%89-%E5%9F%BA%E7%A1%80%E7%AF%87more-plus/"/>
    <id>http://yoursite.com/2018/10/02/Kotlin笔记-三-基础篇more-plus/</id>
    <published>2018-10-02T02:21:45.000Z</published>
    <updated>2018-10-08T12:22:50.017Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-接口的默认实现"><a href="#1-接口的默认实现" class="headerlink" title="1.接口的默认实现"></a>1.接口的默认实现</h3><p>接口的方法可以有一个默认实现。与Java8不同的是，Java8中需要你在这样的实现上标注default关键字，对于这样的方法，Kotlin没有特殊的注解 ：只需要提供一个方法体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Clickable&#123;</span><br><span class="line">    fun click()</span><br><span class="line">    fun showOff = println(&quot;I&apos;m clickable&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a> <p>在实现接口的地方如果要显式地实现方法，在Kotlin中需要把 基类的名字放在尖括号中 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">super&lt;Clickable&gt;.showOff()</span><br></pre></td></tr></table></figure></p><h3 id="2-定义类的继承结构"><a href="#2-定义类的继承结构" class="headerlink" title="2.定义类的继承结构"></a>2.定义类的继承结构</h3><pre><code>Java的类和方法默认是open的，而Kotlin中默认都是final的。 </code></pre><p>如果你想允许创建一个类的子类，需要使用 <strong>open</strong> 修饰符来标示这个类。此外，需要给每一个可以被重写的属性或方法添加open修饰符。</p><blockquote><p><em>注意，如果你重写了一个基类或者接口的成员，重写了的成员同样默认是 open的。如果你想改变这一行为，阻止你的类的子类重写你的实现，可以显式地将重写的成员标注为 <strong>final</strong> 。</em></p></blockquote><h3 id="3-嵌套类与内部类"><a href="#3-嵌套类与内部类" class="headerlink" title="3.嵌套类与内部类"></a>3.嵌套类与内部类</h3><p>Kotlin中没有显式修饰符的嵌套类与Java中的static嵌套类是一样的。要把它变成一个内部类来持有一个外部类的引用的话需要使用 <strong>inner</strong> 修饰符。</p><p>在Kotlin中引用外部类实例的语法也与Java不同。需要使用 <strong>this@Outer</strong> 从 <strong>Inner</strong> 类去访问 <strong>Outer</strong> 类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Outer&#123;</span><br><span class="line">    inner class Inner&#123;</span><br><span class="line">        fun getOuterReference() : Outer = this@Outer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-密封类：定义受限的类继承结构"><a href="#4-密封类：定义受限的类继承结构" class="headerlink" title="4.密封类：定义受限的类继承结构"></a>4.密封类：定义受限的类继承结构</h3><p>为父类添加一个 <strong>sealed</strong> 修饰符，对可能创建的子类做出严格的限制。</p><p>如果你在 when 表达式中处理所有 <strong>sealed</strong> 类的子类，你就不再需要提供默认分支。注意， <strong>sealed</strong> 修饰符隐含的这个类是一个 <strong>open</strong> 类， 你不再需要显式地添加 <strong>open</strong> 修饰符。</p><h3 id="5-声明一个带非默认构造方法或属性的类"><a href="#5-声明一个带非默认构造方法或属性的类" class="headerlink" title="5.声明一个带非默认构造方法或属性的类"></a>5.声明一个带非默认构造方法或属性的类</h3><p>举个栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class User constructor(_nickname: String) &#123;</span><br><span class="line">    val nickname : String</span><br><span class="line">    </span><br><span class="line">    init&#123;</span><br><span class="line">        nickname = _nickname</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，可以看到两个新的Kotlin关键宇：<strong>constructor</strong> 和 <strong>init</strong> 。 <strong>constructor</strong> 关键字用来开始一个主构造方法或从构造方法的声明。 <strong>init</strong> 关键字用来引入一个初始化语句块。这种语句块包含了在类被创建时执行的代码， 并会与主构造方法一起使用。</p><blockquote><p>如果你想要确保你的类不被其他代码实例化，必须把构造方法标记为 private：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Secretive private constructor() &#123;&#125;</span><br><span class="line">//一般这么做表示这个类是一个静态实用工具成员的容器或者是单例的</span><br></pre></td></tr></table></figure><h3 id="6-通过-getter-或-setter-访问支持字段"><a href="#6-通过-getter-或-setter-访问支持字段" class="headerlink" title="6.通过 getter 或 setter 访问支持字段"></a>6.通过 getter 或 setter 访问支持字段</h3><p>假设你想在任何对存储在属性中的数据进行修改时输出日志，你声明了一个可变属性并且在每次 setter 访问时执行额外的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class ·user (val name: String) &#123; </span><br><span class="line">    var address: String =&quot;unspecified&quot; </span><br><span class="line">        set(value: String) &#123; </span><br><span class="line">            println (””“ A Address was changed for $name:</span><br><span class="line">            &quot;$field&quot; -&gt; &quot;value&quot;.&quot;&quot;&quot;&quot;.trimIndent())</span><br><span class="line">            field = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以像平常一样通过使用 user.address ＝ “new value”， 来修改一个属性的值，这其实在底层调用了 setter。</p><p>在 setter 的函数体中，使用了特殊的标识符 <strong>field</strong> 来访问支持字段的值。</p><p>如果你想修改访问器的可见性，可以像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class LengthCounter &#123;</span><br><span class="line">    var counter: Int = 0 </span><br><span class="line">    private set     //这下就不能在类外部修改这个属性了</span><br><span class="line">    </span><br><span class="line">    fun addWord(word: String)&#123;</span><br><span class="line">        counter += word.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-数据类：自动生成通用方法的实现"><a href="#7-数据类：自动生成通用方法的实现" class="headerlink" title="7.数据类：自动生成通用方法的实现"></a>7.数据类：自动生成通用方法的实现</h3><p>如果想要你的类是一个方便的数据容器，你需要重写这些方法 ： <strong>toString</strong>、 <strong>equals</strong> 和 <strong>hashCode</strong> 。在Kotlin中你不必再去生成这些方法了 。如果为你的类添加 <strong>data</strong> 修饰符，必要的方法将会自动生成好。</p><p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data class Client(val name: String, val postalCode: Int)</span><br></pre></td></tr></table></figure></p><h3 id="8-数据类和不可变性：-copy-方法"><a href="#8-数据类和不可变性：-copy-方法" class="headerlink" title="8.数据类和不可变性： copy()方法"></a>8.数据类和不可变性： copy()方法</h3><p>为了让使用不可变对象的数据类变得更容易，Kotlin编译器为它们多生成了一个方法：一个允许 <strong>copy</strong> 类的实例的方法，并在 <strong>copy</strong> 的同时修改某些属性的值:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Client (val name: String, val postalCode: Int) &#123;</span><br><span class="line">    fun copy(name: String = this.name, postalCode: Int = </span><br><span class="line">    this.postalCode) = Client(name, postalCode)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//使用</span><br><span class="line">&gt;&gt;&gt; val bob = Client(&quot;Bob”, 973293) </span><br><span class="line">&gt;&gt;&gt; println(bob.copy(postalCode = 382555))</span><br></pre></td></tr></table></figure><h3 id="9-类委托：使用“by”关键字"><a href="#9-类委托：使用“by”关键字" class="headerlink" title="9.类委托：使用“by”关键字"></a>9.类委托：使用“by”关键字</h3><p>(装饰模式我还不是太了解，了解以后再记录)</p><h3 id="10-对象声明：创建单例易如反掌"><a href="#10-对象声明：创建单例易如反掌" class="headerlink" title="10.对象声明：创建单例易如反掌"></a>10.对象声明：创建单例易如反掌</h3><p>在面向对象系统设计中一个相当常见的情形就是只需要一个实例的类。在Java中，这通常通过单例模式来实现 </p><p>Kotlin 通过使用对象声明功能为这一切提供了最高级的语言支持。对象声明将类声明与该类的单一实例声明结合到了一起。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">object Payroll &#123; </span><br><span class="line">    val allErnployees = arrayListOf&lt;Person&gt;()</span><br><span class="line"></span><br><span class="line">    fun calculateSalary() &#123; </span><br><span class="line">        for &#123;person in allErnployees) &#123; </span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对象声明通过object关键宇引入。一个对象声明可以非常高效地以一句话来定义一个类和一个该类的变量。 </p></blockquote><h3 id="11-伴生对象：工厂方法和静态成员的地盘"><a href="#11-伴生对象：工厂方法和静态成员的地盘" class="headerlink" title="11.伴生对象：工厂方法和静态成员的地盘"></a>11.伴生对象：工厂方法和静态成员的地盘</h3><p>在类中定义的对象之一可以使用一个特殊的关键字来标记：<strong>companion</strong>。如果这样做，就获得了直接通过容器类名称来访问这个对象的方法和属性的能力，不再需要显式地指明对象的名称。最终的语法看起来非常像 Java 中的静态方法调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class A &#123; </span><br><span class="line">    companion object &#123; </span><br><span class="line">        fun bar() &#123; </span><br><span class="line">        println (&quot;Companion object called&quot;) </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt; A.bar() </span><br><span class="line">Companion object called</span><br></pre></td></tr></table></figure><p>伴生对象可以访问类中的所有private成员，包括private构造方法，它是实现工厂模式的理想选择。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class User private constructor(val nickname: String) &#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        fun newSubscribingUser(email: String) =</span><br><span class="line">        User(email.substringBefore (&apos;@&apos;)) </span><br><span class="line">        </span><br><span class="line">        fun newFacebookUser(accountld: Int) = </span><br><span class="line">        User(getFacebookName(accountld)) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt; val subscribingUser = User.newSubscribingUser (&quot;bob@gmail.com&quot;) </span><br><span class="line">&gt;&gt; val facebookUser = User.newFacebookUser(4) </span><br><span class="line">&gt;&gt; println(subscribingUser.nickname)</span><br><span class="line">bob</span><br></pre></td></tr></table></figure><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><ul><li>Kotlin 的接口与 Java 的相似，但是可以包含默认实现 (Java 从第8版才开始支持)和属性。</li><li>所有的声明默认都是 final 和 public 的。</li><li>要想使声明不是 final 的，将其标记为 open。</li><li>internal 声明在同一模块中可见。</li><li>嵌套类默认不是内部类。使用inner关键字来存储外部类的引用。</li><li>sealed 类的子类只能嵌套在自身的声明中（Kotlin 1.1 允许将子类放置在同一文件的任意地方）。</li><li>初始化语句块和从构造方法为初始化类实例提供了灵活性。 </li><li>使用 field 标识符在访问器方法体中引用属性的支持字段。</li><li>数据类提供了编译器生成的 equals、 hashCode、 toString、 copy 和其他方法。 </li><li>类委托帮助避免在代码中出现许多相似的委托方法。 </li><li>对象声明是 Kotlin 中定义单例类的方法。</li><li>伴生对象（与包级别函数和属性一起）替代了Java静态方法和字段定义。 </li><li>伴生对象与其他对象一样，可以实现接口，也可以拥有有扩展函数和属性。</li><li>对象表达式是 Kotlin中针对Java匿名内部类的替代品，并增加了诸如实现多个接口的能力和修改在创建对象的作用域中定义的变量的能力等功能。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-接口的默认实现&quot;&gt;&lt;a href=&quot;#1-接口的默认实现&quot; class=&quot;headerlink&quot; title=&quot;1.接口的默认实现&quot;&gt;&lt;/a&gt;1.接口的默认实现&lt;/h3&gt;&lt;p&gt;接口的方法可以有一个默认实现。与Java8不同的是，Java8中需要你在这样的实现上标注default关键字，对于这样的方法，Kotlin没有特殊的注解 ：只需要提供一个方法体&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;interface Clickable&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fun click()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fun showOff = println(&amp;quot;I&amp;apos;m clickable&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kotlin笔记(二):基础篇plus</title>
    <link href="http://yoursite.com/2018/10/01/Kotlin%E7%AC%94%E8%AE%B0-%E4%BA%8C-%E5%9F%BA%E7%A1%80%E7%AF%87plus/"/>
    <id>http://yoursite.com/2018/10/01/Kotlin笔记-二-基础篇plus/</id>
    <published>2018-10-01T08:15:48.000Z</published>
    <updated>2018-10-01T08:16:18.797Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-顶层函数和属性"><a href="#1-顶层函数和属性" class="headerlink" title="1.顶层函数和属性"></a>1.顶层函数和属性</h3><p>在Kotlin中，可以把那些工具类里的函数直接放到代码文件的顶层，不用从属于任何的类。这些放在文件顶层的函数依然是包内的成员，如果你需要从包外访问它，则需要import，但不再需要额外包一层</p><h3 id="2-给别人的类添加方法：扩展函数和属性"><a href="#2-给别人的类添加方法：扩展函数和属性" class="headerlink" title="2.给别人的类添加方法：扩展函数和属性"></a>2.给别人的类添加方法：扩展函数和属性</h3><p>扩展函数非常简单，它就是一个类的成员函数，不过定义在类的外面。举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">package strings </span><br><span class="line">fun String.lastChar(): Char = this.get(this.length - 1) //this可以省略</span><br></pre></td></tr></table></figure><a id="more"></a> <p>从某种意义上说，你已经为String类添加了自己的方法。即使字符串不是代码的一部分，也没有类的源代码，你仍然可以在自己的项目中根据需要去扩展方法。</p><blockquote><p>注意，扩展函数并不允许你打破它的封装性。和在类内部定义的方法不同的是，扩展函数不能访私有的或者是受保护的成员。 </p><p>对于你定义的一个扩展函数，它不会自动地在整个目范围内生效。相反，如果你要使用它，需要进行导入</p><p>扩展函数并不存在重写，因为Kotiin会把它们当作静态函数对待</p></blockquote><p>下面是声明一个扩展属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val String.lastChar: Char get() = get(length - 1)</span><br></pre></td></tr></table></figure><p>可以看到，和扩展函数一样，扩展属性也像接收者的一个普通的成员属性一样。这里，必须定义getter函数，因为没有支持字段，因此没有默认getter的实现。同理，初始化也不可以：因为没有地方存储初始值。</p><pre><code>注意，当你需要从Java中访问扩展属性的时候，应该显式地调用它的getter函数</code></pre><h3 id="3-可变参数：让函数支持任意数量的参数"><a href="#3-可变参数：让函数支持任意数量的参数" class="headerlink" title="3.可变参数：让函数支持任意数量的参数"></a>3.可变参数：让函数支持任意数量的参数</h3><p>当你在调用一个函数来创建列表的时候，可以传递任意个数的参数给它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val list= list0f(2, 3, 5, 7, 11)</span><br></pre></td></tr></table></figure><p>Kotlin的可变参数与Java类似，但语法略有不同：Kotlin在该类型之后不会再使用三个点，而是在参数上使用vararg修饰符。</p><p>Kotlin和Java 之间的另一个区别是，当需要传递的参数己经包装在数组中时，调用该函数的语法。在Java中，可以按原样传递数组，而Kotlin 则要求你显式地解包数组，以便每个数组元素在函数中能作为单独的参数来调用。从技术的角度来讲，这个功能被称为展开运算符，而使用的时候，不过是在对应的参数前面放一个*：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;）&#123;</span><br><span class="line">val list = listOf(&quot;args:”,*args) </span><br><span class="line">println(list) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-键值对的处理：中缀调用和解构声明"><a href="#4-键值对的处理：中缀调用和解构声明" class="headerlink" title="4.键值对的处理：中缀调用和解构声明"></a>4.键值对的处理：中缀调用和解构声明</h3><p>可以使用 mapOf 函数来创建 map:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val map= mapOf(l to &quot;one&quot;， 7 to &quot;seven&quot;， 53 to &quot;fifty-three&quot;)</span><br></pre></td></tr></table></figure><p>这行代码中的单词to不是内置的结构，而是一种特殊的函数调用，被称为中缀调用。 </p><p>在中缀调用中，没有添加额外的分隔符，函数名称是直接放在目标对象名称和 参数之间的。以下两种调用方式是等价的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.to(&quot;one&quot;)</span><br><span class="line">1 to &quot;one&quot;</span><br></pre></td></tr></table></figure><p>中缀调用可以与只有一个参数的函数一起使用，无论是普通的函数还是扩展函 数。要允许使用中缀符号调用函数，需要使用 infix 修饰符来标记它。下面是一个 简单的 to 函数的声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">infix fun Any.to(other: Any) = Pair(this, other)</span><br></pre></td></tr></table></figure><p>to 函数是一个扩展函数，可以创建一对任何元素，这意味着它是泛型接收者的 扩展：可以使用 1 to “one” 、”one” to 1、list to list.size()等写法。 </p><h3 id="5-让你的代码更整洁：局部函数和扩展"><a href="#5-让你的代码更整洁：局部函数和扩展" class="headerlink" title="5.让你的代码更整洁：局部函数和扩展"></a>5.让你的代码更整洁：局部函数和扩展</h3><p>Kotlin可以在函数中嵌套类中提取的函数。这样，既可以获得所需的结构，也无须额外的语法开销。</p><p>举个栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class User(val id: Int, val name: String, val address: String) </span><br><span class="line"></span><br><span class="line">fun saveUser(user : User)&#123;</span><br><span class="line">    if(user.name.isEmpty())&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    if(user.address.isEmpty())&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    //保存...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果将验证代码放到局部函数中，可以摆脱重复，并保持清晰的代码结构，可以这样做 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class User(val id: Int, val name: String, val address: String) </span><br><span class="line"></span><br><span class="line">fun saveUser(user : User)&#123;</span><br><span class="line">    fun validate(user: User, value: String, fieldName: String)&#123;</span><br><span class="line">        if(value.isEmpty())&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    validate (user, user.name, &quot;Name&quot;)</span><br><span class="line">    validate (user, user.address, &quot;Address&quot;)</span><br><span class="line">    //保存...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码看起来好多了，而且局部函数可以访问所在函数中的所有参数和变量。 我们可以利用这一点，去掉冗余的User参数，这里就不再演示了</p><p>我们可以继续改进，把验证逻辑放到 User 类的扩展函数中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class User(val id: Int, val name: String, val address: String) </span><br><span class="line"></span><br><span class="line">fun User.validateBeforeSave()&#123;</span><br><span class="line">    fun validate(value: String, fieldName: String)&#123;</span><br><span class="line">        if(value.isEmpty())&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    validate (user.name, &quot;Name&quot;)</span><br><span class="line">    validate (user.address, &quot;Address&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fun saveUser(user : User)&#123;</span><br><span class="line">    user.validateBeforeSave()</span><br><span class="line">    //保存...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小结：</strong></p><ul><li><p>Kotlin没有定义自己的集合类，而是在Java集合类的基础上提供了更丰富的API。</p></li><li><p>Kotlin可以给函数参数定义默认值，这样大大降低了重载函数的必要性，而且命名参数让多参数函数的调用更加易读。</p></li><li><p>Kotlin允许更灵活的代码结构：函数和属性都可以直接在文件中声明，而不仅仅是在类中作为成员。</p></li><li><p>Kotlin可以用扩展函数和属性来扩展任何类的API，包括在外部库中定义的类，而不需要修改其源代码，也没有运行时开销。 </p></li><li><p>中缀调用提供了处理单个参数的，类似调用运算符方法的简明语法。</p></li><li><p>Kotlin为普通字符串和正则表达式都提供了大量的方便字符串处理的函数。 </p></li><li><p>三重引号的字符串提供了一种简洁的方式，解决了原本在Java中需要进行大量啰嗦的转义和宇符串连接的问题。</p></li><li><p>局部函数帮助你保持代码整洁的同时，避免重复。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-顶层函数和属性&quot;&gt;&lt;a href=&quot;#1-顶层函数和属性&quot; class=&quot;headerlink&quot; title=&quot;1.顶层函数和属性&quot;&gt;&lt;/a&gt;1.顶层函数和属性&lt;/h3&gt;&lt;p&gt;在Kotlin中，可以把那些工具类里的函数直接放到代码文件的顶层，不用从属于任何的类。这些放在文件顶层的函数依然是包内的成员，如果你需要从包外访问它，则需要import，但不再需要额外包一层&lt;/p&gt;
&lt;h3 id=&quot;2-给别人的类添加方法：扩展函数和属性&quot;&gt;&lt;a href=&quot;#2-给别人的类添加方法：扩展函数和属性&quot; class=&quot;headerlink&quot; title=&quot;2.给别人的类添加方法：扩展函数和属性&quot;&gt;&lt;/a&gt;2.给别人的类添加方法：扩展函数和属性&lt;/h3&gt;&lt;p&gt;扩展函数非常简单，它就是一个类的成员函数，不过定义在类的外面。举个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;package strings &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fun String.lastChar(): Char = this.get(this.length - 1) //this可以省略&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>论国庆节的几种过法</title>
    <link href="http://yoursite.com/2018/10/01/%E8%AE%BA%E5%9B%BD%E5%BA%86%E8%8A%82%E7%9A%84%E5%87%A0%E7%A7%8D%E8%BF%87%E6%B3%95/"/>
    <id>http://yoursite.com/2018/10/01/论国庆节的几种过法/</id>
    <published>2018-10-01T07:49:16.000Z</published>
    <updated>2018-10-01T07:50:54.126Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 中秋刚过才一个星期，国庆就来了。这七天小长假可不能就这样寥寥草草，得好好准备准备看看怎么过才行！</p></blockquote><p><strong>下面就介绍一下国庆节的几种过法</strong></p><a id="more"></a> <h2 id="一、干粮"><a href="#一、干粮" class="headerlink" title="一、干粮"></a>一、干粮</h2><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%AE%BA%E5%9B%BD%E5%BA%86%E8%8A%82%E7%9A%84%E5%A5%BD%E5%87%A0%E7%A7%8D%E8%BF%87%E6%B3%95/%E5%B9%B2%E7%B2%AE.jpg" alt="image"></p><p>干粮是必不可少的一部分，有了这个，你就不必担心饿死了！</p><h2 id="二、游戏"><a href="#二、游戏" class="headerlink" title="二、游戏"></a>二、游戏</h2><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%AE%BA%E5%9B%BD%E5%BA%86%E8%8A%82%E7%9A%84%E5%A5%BD%E5%87%A0%E7%A7%8D%E8%BF%87%E6%B3%95/%E6%B8%B8%E6%88%8F.jpg" alt="image"></p><p>所谓饱暖思淫欲，当你不必为了食物而犯愁之后，你就可以思考自身的娱乐需求了。无论是召唤师峡谷，还是艾泽拉斯大陆，都有承载你欢乐的地方，如果这些地方你不满意，还剩下索尼微软任天堂好些游戏平台呢！</p><h2 id="三、阅读"><a href="#三、阅读" class="headerlink" title="三、阅读"></a>三、阅读</h2><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%AE%BA%E5%9B%BD%E5%BA%86%E8%8A%82%E7%9A%84%E5%A5%BD%E5%87%A0%E7%A7%8D%E8%BF%87%E6%B3%95/%E9%98%85%E8%AF%BB.jpg" alt="image"></p><p>劳逸结合一直是一种非常良好的生活方式，游戏玩过头了反而会荒废你的大脑，这时候应该静下心来看看书，文学类、科学类、教材类，各式各样，应有尽有。</p><h2 id="四、运动"><a href="#四、运动" class="headerlink" title="四、运动"></a>四、运动</h2><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%AE%BA%E5%9B%BD%E5%BA%86%E8%8A%82%E7%9A%84%E5%A5%BD%E5%87%A0%E7%A7%8D%E8%BF%87%E6%B3%95/%E8%BF%90%E5%8A%A8.jpg" alt="image"></p><p>一个人身体要是不好，那多少事情都干不了，学习、娱乐之余，可别忘了运动，毕竟90后的年轻人没几个希望中年发福吧！</p><h2 id="五、出行"><a href="#五、出行" class="headerlink" title="五、出行"></a>五、出行</h2><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%AE%BA%E5%9B%BD%E5%BA%86%E8%8A%82%E7%9A%84%E5%A5%BD%E5%87%A0%E7%A7%8D%E8%BF%87%E6%B3%95/%E9%AA%91%E8%A1%8C.jpg" alt="image"></p><p>在家待久了会生霉的，所以出去转转还能让自己保持新鲜！</p><p>而且节日出行也是蛮合理的一件事，如果你真有一颗不安分的心，外面的人山人海又怎能拦得住你？</p><hr><p><strong>那么，国庆节的过法就谈到这里！我要开始享受国庆了！</strong></p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%AE%BA%E5%9B%BD%E5%BA%86%E8%8A%82%E7%9A%84%E5%A5%BD%E5%87%A0%E7%A7%8D%E8%BF%87%E6%B3%95/001.jpeg" alt="image"></p><hr><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%AE%BA%E5%9B%BD%E5%BA%86%E8%8A%82%E7%9A%84%E5%A5%BD%E5%87%A0%E7%A7%8D%E8%BF%87%E6%B3%95/002.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; 中秋刚过才一个星期，国庆就来了。这七天小长假可不能就这样寥寥草草，得好好准备准备看看怎么过才行！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;下面就介绍一下国庆节的几种过法&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kotlin笔记(一):基础篇</title>
    <link href="http://yoursite.com/2018/09/30/Kotlin%E7%AC%94%E8%AE%B0-%E4%B8%80-%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>http://yoursite.com/2018/09/30/Kotlin笔记-一-基础篇/</id>
    <published>2018-09-30T07:45:18.000Z</published>
    <updated>2018-09-30T07:46:31.866Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 在2017年的Google开发者大会上，Kotlin正式作为Android的官方开发语言闪亮登场。而现在已经到了2018年的下半年末，身为一名Android开发者，如果不会一点Kotlin，总感觉少了什么。  </p><p>于是乎，我准备动手学一学这门“年轻”的新语言了。不过新学一些东西往往会因为知识的消化需要时间而导致知识接收的效率不高，所以这时候好记性不如烂笔头的优势才得以体现嘛！  </p><p>所以，初学阶段，我还是准备记一记笔记，这样也许会对我学这门语言有所帮助吧？!</p></blockquote><p>关于Kotlin的官方文档，地址如下：</p><p><a href="https://www.kotlincn.net/docs/reference/" target="_blank" rel="noopener">Kotlin学习</a><br><a id="more"></a> </p><h3 id="1-在-Kotlin-中，if是表达式，而不是语句。"><a href="#1-在-Kotlin-中，if是表达式，而不是语句。" class="headerlink" title="1.在 Kotlin 中，if是表达式，而不是语句。"></a>1.在 Kotlin 中，if是表达式，而不是语句。</h3><p> 语句和表达式的区别在于，表达式有值，并且能作为另一个表达式的一部分使用；而语句总是包围着它的代码块中的顶层元素，并且没有自己的值。</p><ul><li>在Java中，所有的控制结构都是语句。而在Kotlin中，除了循环（ for, do 和 do/while ）以外大多数控制结构都是 表达式。<br>这种结合控制结构和其他表达式的能力让你可以简明扼要地表示许多 常见的模式，稍后你会在本书中看到这些内容。</li><li>另一方面，Java中的赋值操作是表达式，在Kotlin中反而变成了语句。这有助于避免比较和赋值之间的混淆，而这种混淆是常见的错误来源。</li></ul><h3 id="2-声明变量的关键字有两个-："><a href="#2-声明变量的关键字有两个-：" class="headerlink" title="2.声明变量的关键字有两个 ："></a>2.声明变量的关键字有两个 ：</h3><ul><li>val （来自 value） 一一不可变引用。使用 val 声明的变量不能在初始化之 后再次赋值。它对应的是 Java 的 final 变量。  </li><li>var （来自 variable） 一一可变引用。这种变量的值可以被改变。这种声明对 应的是普通（非 final）的 Java 变量。</li></ul><h3 id="3-局部变量的引用"><a href="#3-局部变量的引用" class="headerlink" title="3.局部变量的引用"></a>3.局部变量的引用</h3><p>和许多脚本语言一样， Kotlin 让你可 以在字符串字面值中引用局部变量，只需要在变量名称前面加上字符$。</p><p>这等价于 Java 中的字符串连接（ “Hello,”+ name ＋”！”），效率一样但是更紧凑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val name = if(args.size &gt; 0) args[0] else &quot;Kotlin&quot;</span><br><span class="line">    println(&quot;Hello, $name !&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以引用更复杂的表达式，而不是仅限于简单的变量名称，只需要把表达式 用花括号括起来.</p><h3 id="4-在Java中可以用switch语句完成的，而Kotlin-对应的结构是when"><a href="#4-在Java中可以用switch语句完成的，而Kotlin-对应的结构是when" class="headerlink" title="4.在Java中可以用switch语句完成的，而Kotlin 对应的结构是when"></a>4.在Java中可以用switch语句完成的，而Kotlin 对应的结构是when</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun getMnemonic(color: Color) = </span><br><span class="line">when (color) &#123; </span><br><span class="line">Color . RED -&gt;”Richard&quot; </span><br><span class="line">Color.ORANGE -&gt;”Of” </span><br><span class="line">Color.YELLOW -&gt;”York&quot; </span><br><span class="line">Color .GREEN -&gt;”Gave” </span><br><span class="line">Color.BLUE -&gt;”Battle&quot; </span><br><span class="line">Color ．工NDIGO -&gt;”In” </span><br><span class="line">Color.VIOLET -&gt;”Vain </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在一个 when 分支上合并多个选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun getWarmth(color: Color) = when(color) &#123;</span><br><span class="line">Color.RED, Color.ORANGE, Color.YELLOW - &gt; ”warm”</span><br><span class="line">Color.GREEN -&gt; ”neutral”</span><br><span class="line">Color.BLUE, Color.INDIGO, Color.VIOLET -&gt;”cold”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，也可以导入枚举常量后不用限定词就可以访问。比如去掉花括号里的Color也是可以的。</p><blockquote><p>Kotlin中的when结构比Java中的switch强大得多。switch要求必须使用常量（枚举常量、字符串或者数字字面值）作为分支条件，和它不一样， when允许使用任何对象。</p></blockquote><h3 id="5-类型判断"><a href="#5-类型判断" class="headerlink" title="5.类型判断"></a>5.类型判断</h3><p>在Kotlin中，你要使用is检查来判断一个变量是否是某种类型。is检查和Java中的instanceOf相似，不过在instanceOf检查之后还需要显式地加上类型转换。</p><p>在Kotlin中，编译器帮你完成了这些工作。如果你检查过一个变量是某种类型，后面就不再需要转换它，可以就把它当作你检查过的类型使用。</p><p>使用as关键字来表示到特定类型的显式转换；</p><h3 id="6-循环中的”in”关键字"><a href="#6-循环中的”in”关键字" class="headerlink" title="6.循环中的”in”关键字"></a>6.循环中的”in”关键字</h3><p>Kotlin里面关键字“in”有许多作用，比如检查区间的成员；作为when的分支；在for循环中使用等。关于in如何在list中使用，下章再介绍</p><h3 id="7-关于”try”"><a href="#7-关于”try”" class="headerlink" title="7.关于”try”"></a>7.关于”try”</h3><p>Kotlin中的try关键字就像if和when一样,引入了一个表达式，可以把它的值赋给一个变量。不同于if，你总是需要用花括号把语句主体括起来。和其他语句一样，如果其主体包含多个表达式，那么整个 try 表达式的值就是最后一个表达式的值。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; 在2017年的Google开发者大会上，Kotlin正式作为Android的官方开发语言闪亮登场。而现在已经到了2018年的下半年末，身为一名Android开发者，如果不会一点Kotlin，总感觉少了什么。  &lt;/p&gt;
&lt;p&gt;于是乎，我准备动手学一学这门“年轻”的新语言了。不过新学一些东西往往会因为知识的消化需要时间而导致知识接收的效率不高，所以这时候好记性不如烂笔头的优势才得以体现嘛！  &lt;/p&gt;
&lt;p&gt;所以，初学阶段，我还是准备记一记笔记，这样也许会对我学这门语言有所帮助吧？!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于Kotlin的官方文档，地址如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.kotlincn.net/docs/reference/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kotlin学习&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Bugly热修复使用及多渠道打包</title>
    <link href="http://yoursite.com/2018/09/26/Bugly%E7%83%AD%E4%BF%AE%E5%A4%8D%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85/"/>
    <id>http://yoursite.com/2018/09/26/Bugly热修复使用及多渠道打包/</id>
    <published>2018-09-26T11:54:41.000Z</published>
    <updated>2018-10-04T15:57:53.270Z</updated>
    
    <content type="html"><![CDATA[<h2 id="头"><a href="#头" class="headerlink" title="头"></a>头</h2><p>不知道你是否遇到过这个情况，项目上线后或者开始给别人使用的时候，冷不丁的冒出个Bug，这时候首先要干嘛？</p><p><strong>先看崩溃日志啊</strong></p><p>看完崩溃日志你知道了造成崩溃的原因，然后干嘛？</p><p><strong>开始甩锅啊</strong></p><p>当查明了是谁造成的这个崩溃后，你发现不是你的问题，于是你心中一乐，长舒一口气<a id="more"></a> ，仰天大笑：码海沉浮又几载，我辈岂是蓬蒿人；笑完便准备躺床上睡觉去——秋豆麻袋，是不是忘了什么东西？</p><p>是的，即使你发现了问题，并且找到了问题的来源，这时候还差一步：解决问题的办法！如何解决？</p><p><strong>发布新版本？</strong></p><p>这样不觉得很麻烦吗？特别是如果一个项目处于初期阶段，Bug是想甩都甩不掉的，如果每发现一次崩溃，都需要靠发布一个新版本去解决的话，那未免就太麻烦了。不光是开发者麻烦，使用者也会因为频繁的升级而不耐烦（just like me），那问题又回来了，如何解决？</p><p><strong>热修复啊</strong></p><p>通过线上修复Bug，让用户在神不知鬼不觉的情况下就进行了一次应用更新，麻麻再也不用担心App崩溃啦！（不存在的）</p><p>热修复还有个隐藏的好处，那就是在测试人员不够（开发兼测试），测试机型不够的情况下可以显著改善App的崩溃率。好吧，准备开始使用吧。</p><h2 id="身"><a href="#身" class="headerlink" title="身"></a>身</h2><h3 id="一、为什么要用Bugly"><a href="#一、为什么要用Bugly" class="headerlink" title="一、为什么要用Bugly"></a>一、为什么要用Bugly</h3><p>市面上关于热修复和崩溃日志监测的相关技术和SDK种类各不相同，为什么偏偏要用Bugly呢？</p><ul><li>可以获取到App崩溃日志</li><li>可以集成Think热修复</li><li>界面好看，方便管理版本</li><li>免费</li><li>（凑巧就用了这一款，其他的都没有用过）</li></ul><p>基于以上原因，最后就使用了Bugly去解决上面提到过的问题；</p><h3 id="二、Bugly热更新接入流程"><a href="#二、Bugly热更新接入流程" class="headerlink" title="二、Bugly热更新接入流程"></a>二、Bugly热更新接入流程</h3><p>其实关于Bugly热更新的接入流程，官方的文档介绍的非常详细，对新手比较友好，我第一次使用也是直接参照的文档，下面是官方文档的地址：</p><p><a href="https://bugly.qq.com/docs/user-guide/instruction-manual-android-hotfix/?v=20180709165613" target="_blank" rel="noopener">【Bugly Android热更新使用指南】</a></p><p>虽然官方有例子，这里还是写了一个简化版，也方便以后哪天自己忘记了依旧能快速使用：</p><h4 id="第一步：添加依赖插件"><a href="#第一步：添加依赖插件" class="headerlink" title="第一步：添加依赖插件"></a>第一步：添加依赖插件</h4><p>在你的项目更目录下的“build.gradle”中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        // tinkersupport插件, 其中lastest.release指拉取最新版本，也可以指定明确版本号，例如1.0.4</span><br><span class="line">        classpath &quot;com.tencent.bugly:tinker-support:1.1.2&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在写这篇文章的时候，最新的版本就是1.1.2</p><h4 id="第二步：配置依赖插件"><a href="#第二步：配置依赖插件" class="headerlink" title="第二步：配置依赖插件"></a>第二步：配置依赖插件</h4><h5 id="gradle配置"><a href="#gradle配置" class="headerlink" title="gradle配置"></a>gradle配置</h5><p>在app module的“build.gradle”文件中添加（示例配置）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">// 依赖插件脚本</span><br><span class="line">apply from: &apos;tinker-support.gradle&apos;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">        defaultConfig &#123;</span><br><span class="line">          ndk &#123;</span><br><span class="line">            //设置支持的SO库架构</span><br><span class="line">            abiFilters &apos;armeabi&apos; //, &apos;x86&apos;, &apos;armeabi-v7a&apos;, &apos;x86_64&apos;, &apos;arm64-v8a&apos;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      dependencies &#123;</span><br><span class="line">         implementation &apos;com.android.support:multidex:1.0.1&apos;</span><br><span class="line">        // 多dex配置</span><br><span class="line">        //注释掉原有bugly的仓库</span><br><span class="line">        //compile &apos;com.tencent.bugly:crashreport:latest.release&apos;//其中latest.release指代最新版本号，也可以指定明确的版本号，例如1.3.4</span><br><span class="line">        implementation &apos;com.tencent.bugly:crashreport_upgrade:1.3.5&apos;</span><br><span class="line">        // 指定tinker依赖版本（注：应用升级1.3.5版本起，不再内置tinker）</span><br><span class="line">        implementation &apos;com.tencent.tinker:tinker-android-lib:1.9.6&apos;</span><br><span class="line">        implementation &apos;com.tencent.bugly:nativecrashreport:latest.release&apos;</span><br><span class="line">        //其中latest.release指代最新版本号，也可以指定明确的版本号，例如2.2.0</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>在这个版本的SDK里面，已经集成了崩溃日志上传的功能哦！</p><h5 id="tinker-support-gradle的配置"><a href="#tinker-support-gradle的配置" class="headerlink" title="tinker-support.gradle的配置"></a>tinker-support.gradle的配置</h5><p>接下来，你要在app module目录下创建另外一个gradle文件，命名为“tinker-support.gradle”，然后对它进行配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;com.tencent.bugly.tinker-support&apos;</span><br><span class="line"></span><br><span class="line">def bakPath = file(&quot;$&#123;buildDir&#125;/bakApk/&quot;)</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 此处填写每次构建生成的基准包目录</span><br><span class="line"> */</span><br><span class="line">def baseApkDir = &quot;app-0921-14-52-06&quot;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 对于插件各参数的详细解析请参考</span><br><span class="line"> */</span><br><span class="line">tinkerSupport &#123;</span><br><span class="line"></span><br><span class="line">    // 开启tinker-support插件，默认值true</span><br><span class="line">    enable = true</span><br><span class="line"></span><br><span class="line">    // 指定归档目录，默认值当前module的子目录tinker</span><br><span class="line">    autoBackupApkDir = &quot;$&#123;bakPath&#125;&quot;</span><br><span class="line"></span><br><span class="line">    // 是否启用覆盖tinkerPatch配置功能，默认值false</span><br><span class="line">    // 开启后tinkerPatch配置不生效，即无需添加tinkerPatch</span><br><span class="line">    overrideTinkerPatchConfiguration = true</span><br><span class="line"></span><br><span class="line">    // 编译补丁包时，必需指定基线版本的apk，默认值为空</span><br><span class="line">    // 如果为空，则表示不是进行补丁包的编译</span><br><span class="line">    // @&#123;link tinkerPatch.oldApk &#125;</span><br><span class="line">    baseApk = &quot;$&#123;bakPath&#125;/$&#123;baseApkDir&#125;/app-release.apk&quot;</span><br><span class="line"></span><br><span class="line">    // 对应tinker插件applyMapping</span><br><span class="line">    baseApkProguardMapping = &quot;$&#123;bakPath&#125;/$&#123;baseApkDir&#125;/app-release-mapping.txt&quot;</span><br><span class="line"></span><br><span class="line">    // 对应tinker插件applyResourceMapping</span><br><span class="line">    baseApkResourceMapping = &quot;$&#123;bakPath&#125;/$&#123;baseApkDir&#125;/app-release-R.txt&quot;</span><br><span class="line"></span><br><span class="line">    // 构建基准包和补丁包都要指定不同的tinkerId，并且必须保证唯一性</span><br><span class="line">    tinkerId = &quot;1.0.1-patch&quot;                //tinkerId = &quot;1.0.1-patch&quot;            tinkerId = &quot;1.0.1-base&quot;</span><br><span class="line"></span><br><span class="line">    // 构建多渠道补丁时使用</span><br><span class="line">    // buildAllFlavorsDir = &quot;$&#123;bakPath&#125;/$&#123;baseApkDir&#125;&quot;</span><br><span class="line"></span><br><span class="line">    // 是否启用加固模式，默认为false.(tinker-spport 1.0.7起支持）</span><br><span class="line">    // isProtectedApp = true</span><br><span class="line"></span><br><span class="line">    // 是否开启反射Application模式</span><br><span class="line">    enableProxyApplication = false</span><br><span class="line"></span><br><span class="line">    // 是否支持新增非export的Activity（注意：设置为true才能修改AndroidManifest文件）</span><br><span class="line">    supportHotplugComponent = true</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 一般来说,我们无需对下面的参数做任何的修改</span><br><span class="line"> * 对于各参数的详细介绍请参考:</span><br><span class="line"> * https://github.com/Tencent/tinker/wiki/Tinker-%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97</span><br><span class="line"> */</span><br><span class="line">tinkerPatch &#123;</span><br><span class="line">    //oldApk =&quot;$&#123;bakPath&#125;/$&#123;appName&#125;/app-release.apk&quot;</span><br><span class="line">    ignoreWarning = false</span><br><span class="line">    useSign = true</span><br><span class="line">    dex &#123;</span><br><span class="line">        dexMode = &quot;jar&quot;</span><br><span class="line">        pattern = [&quot;classes*.dex&quot;]</span><br><span class="line">        loader = []</span><br><span class="line">    &#125;</span><br><span class="line">    lib &#123;</span><br><span class="line">        pattern = [&quot;lib/*/*.so&quot;]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res &#123;</span><br><span class="line">        pattern = [&quot;res/*&quot;, &quot;r/*&quot;, &quot;assets/*&quot;, &quot;resources.arsc&quot;, &quot;AndroidManifest.xml&quot;]</span><br><span class="line">        ignoreChange = []</span><br><span class="line">        largeModSize = 100</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    packageConfig &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    sevenZip &#123;</span><br><span class="line">        zipArtifact = &quot;com.tencent.mm:SevenZip:1.1.10&quot;</span><br><span class="line">//        path = &quot;/usr/local/bin/7za&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    buildConfig &#123;</span><br><span class="line">        keepDexApply = false</span><br><span class="line">        //tinkerId = &quot;1.0.1-base&quot;</span><br><span class="line">        //applyMapping = &quot;$&#123;bakPath&#125;/$&#123;appName&#125;/app-release-mapping.txt&quot; //  可选，设置mapping文件，建议保持旧apk的proguard混淆方式</span><br><span class="line">        //applyResourceMapping = &quot;$&#123;bakPath&#125;/$&#123;appName&#125;/app-release-R.txt&quot; // 可选，设置R.txt文件，通过旧apk文件保持ResId的分配</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面的配置比较多，一开始看还是有点儿眼花缭乱的，所以得慢慢来；</p><p>这里对其中的几点进行说明：</p><ul><li><em>baseApkDir</em> ： 这里填写每次构建生成的基准包目录，每次打包的时候，都会有新的目录和新的基准包生成，但是只有你打算发布的那一个的目录才是有效的。</li><li><em>tinkerId</em> ： 构建基准包和补丁包都要指定不同的tinkerId，并且必须保证唯一性。比如你的第一个基准包打包的时候可以把这个id设置为“1.0.0-base”，当你想打包热修复补丁包的时候，需要把这个id换成1.0.0-patch。</li></ul><p>更详细的配置项参考：<a href="https://bugly.qq.com/docs/utility-tools/plugin-gradle-hotfix/" target="_blank" rel="noopener">tinker-support配置说明</a></p><h4 id="第三步：初始化SDK"><a href="#第三步：初始化SDK" class="headerlink" title="第三步：初始化SDK"></a>第三步：初始化SDK</h4><p>上面的“tinker-support.gradle”中的enableProxyApplication属性设置的是false，是Tinker推荐的接入方式。</p><h5 id="自定义Application，当enableProxyApplication为false的情况"><a href="#自定义Application，当enableProxyApplication为false的情况" class="headerlink" title="自定义Application，当enableProxyApplication为false的情况"></a>自定义Application，当enableProxyApplication为false的情况</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class SampleApplication extends TinkerApplication &#123;</span><br><span class="line">    public SampleApplication() &#123;</span><br><span class="line">        super(ShareConstants.TINKER_ENABLE_ALL, &quot;xxx.xxx.SampleApplicationLike&quot;,</span><br><span class="line">                &quot;com.tencent.tinker.loader.TinkerLoader&quot;, false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SampleApplicationLike</strong>需要是自定义的继承<strong>DefaultApplicationLike</strong>的类，不要忘了在<strong>AndroidManifest.xml</strong>中声名上面的这个Application哦。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class SampleApplicationLike extends DefaultApplicationLike &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static final String TAG = &quot;Tinker.SampleApplicationLike&quot;;</span><br><span class="line"></span><br><span class="line">    public SampleApplicationLike(Application application, int tinkerFlags,</span><br><span class="line">                                 boolean tinkerLoadVerifyFlag, long applicationStartElapsedTime,</span><br><span class="line">                                 long applicationStartMillisTime, Intent tinkerResultIntent) &#123;</span><br><span class="line">        super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        // 这里实现SDK初始化，appId替换成你的在Bugly平台申请的appId</span><br><span class="line">        // 调试时，将第三个参数改为true</span><br><span class="line">        Bugly.init(getApplication(), &quot;900029763&quot;, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)</span><br><span class="line">    @Override</span><br><span class="line">    public void onBaseContextAttached(Context base) &#123;</span><br><span class="line">        super.onBaseContextAttached(base);</span><br><span class="line">        // you must install multiDex whatever tinker is installed!</span><br><span class="line">        MultiDex.install(base);</span><br><span class="line"></span><br><span class="line">        // 安装tinker</span><br><span class="line">        // TinkerManager.installTinker(this); 替换成下面Bugly提供的方法</span><br><span class="line">        Beta.installTinker(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)</span><br><span class="line">    public void registerActivityLifecycleCallback(Application.ActivityLifecycleCallbacks callbacks) &#123;</span><br><span class="line">        getApplication().registerActivityLifecycleCallbacks(callbacks);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面需要注意的是在“onCreate()”方法中进行初始化的时候，填入的appId是你在Bugly创建的项目的Appid，其他地方基本上不用改了</p><h5 id="自定义Application，当enableProxyApplication为true的情况"><a href="#自定义Application，当enableProxyApplication为true的情况" class="headerlink" title="自定义Application，当enableProxyApplication为true的情况"></a>自定义Application，当enableProxyApplication为true的情况</h5><p>这种的接入方式要简单许多，无须你改造Application</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class MyApplication extends Application &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        // 这里实现SDK初始化，appId替换成你的在Bugly平台申请的appId</span><br><span class="line">        // 调试时，将第三个参数改为true</span><br><span class="line">        Bugly.init(this, &quot;900029763&quot;, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void attachBaseContext(Context base) &#123;</span><br><span class="line">        super.attachBaseContext(base);</span><br><span class="line">        // you must install multiDex whatever tinker is installed!</span><br><span class="line">        MultiDex.install(base);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // 安装tinker</span><br><span class="line">        Beta.installTinker();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第四步：AndroidManifest-xml配置"><a href="#第四步：AndroidManifest-xml配置" class="headerlink" title="第四步：AndroidManifest.xml配置"></a>第四步：AndroidManifest.xml配置</h4><h5 id="1-权限配置："><a href="#1-权限配置：" class="headerlink" title="1.权限配置："></a>1.权限配置：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.READ_LOGS&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;</span><br></pre></td></tr></table></figure><h5 id="2-Activity配置："><a href="#2-Activity配置：" class="headerlink" title="2.Activity配置："></a>2.Activity配置：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;com.tencent.bugly.beta.ui.BetaActivity&quot;</span><br><span class="line">    android:configChanges=&quot;keyboardHidden|orientation|screenSize|locale&quot;</span><br><span class="line">    android:theme=&quot;@android:style/Theme.Translucent&quot; /&gt;</span><br></pre></td></tr></table></figure><h5 id="3-配置FileProvider"><a href="#3-配置FileProvider" class="headerlink" title="3.配置FileProvider"></a>3.配置FileProvider</h5><pre><code>注意：如果您想兼容Android N或者以上的设备，必须要在AndroidManifest.xml文件中配置FileProvider来访问共享路径的文件。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--热更新需要的Provider--&gt;</span><br><span class="line">&lt;provider</span><br><span class="line">    android:name=&quot;android.support.v4.content.FileProvider&quot;</span><br><span class="line">    android:authorities=&quot;$&#123;applicationId&#125;.fileProvider&quot;</span><br><span class="line">    android:exported=&quot;false&quot;</span><br><span class="line">    android:grantUriPermissions=&quot;true&quot;&gt;</span><br><span class="line">    &lt;meta-data</span><br><span class="line">        android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;</span><br><span class="line">        android:resource=&quot;@xml/provider_paths&quot;/&gt;</span><br><span class="line">&lt;/provider&gt;</span><br></pre></td></tr></table></figure><p>在res目录新建xml文件夹，创建provider_paths.xml文件如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;paths xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;!-- /storage/emulated/0/Download/$&#123;applicationId&#125;/.beta/apk--&gt;</span><br><span class="line">    &lt;external-path name=&quot;beta_external_path&quot; path=&quot;Download/&quot;/&gt;</span><br><span class="line">    &lt;!--/storage/emulated/0/Android/data/$&#123;applicationId&#125;/files/apk/--&gt;</span><br><span class="line">    &lt;external-path name=&quot;beta_external_files_path&quot; path=&quot;Android/data/&quot;/&gt;</span><br><span class="line">&lt;/paths&gt;</span><br></pre></td></tr></table></figure></p><h4 id="第五步：混淆配置"><a href="#第五步：混淆配置" class="headerlink" title="第五步：混淆配置"></a>第五步：混淆配置</h4><p>为了避免混淆SDK，在Proguard混淆文件中增加以下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-dontwarn com.tencent.bugly.**</span><br><span class="line">-keep public class com.tencent.bugly.**&#123;*;&#125;</span><br><span class="line"># tinker混淆规则</span><br><span class="line">-dontwarn com.tencent.tinker.**</span><br><span class="line">-keep class com.tencent.tinker.** &#123; *; &#125;</span><br></pre></td></tr></table></figure></p><h3 id="三、打包"><a href="#三、打包" class="headerlink" title="三、打包"></a>三、打包</h3><p>当上面的环境配置都没有问题之后，就可以进行打包了。</p><p>打包之前，你还得配置一下编译正式版apk所需要的<strong>keystore.jks</strong>文件，这个文件怎么创建的就不介绍了，这里主要介绍一下如何配置：</p><p>在app moudle目录下的“build.gradle”中配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            keyAlias &apos;xxxxxxxx&apos;</span><br><span class="line">            keyPassword &apos;xxxxxxxx&apos;</span><br><span class="line">            storeFile file(&apos;../keystore.jks&apos;)</span><br><span class="line">            storePassword &apos;xxxxxxxx&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled true</span><br><span class="line">            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</span><br><span class="line">            signingConfig signingConfigs.release</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的各项参数就不必做说明了</p><p>然后就是打包过程<img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Bugly%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/bugly-001.png" alt="image"></p><p><strong>打包过程中需要注意之前提到过的tinkerId的配置，以及目录的配置，很重要哦！</strong></p><p>生成的基准包会在这个目录</p><p><img src="https://bugly.qq.com/docs/img/hotfix/android/Snip20170209_2.png?v=20180709165613" alt="image"></p><p>生成的补丁包会在这个目录</p><p><img src="https://bugly.qq.com/docs/img/hotfix/android/1479216059696.png?v=20180709165613" alt="image"></p><p>然后就准备开始使用吧</p><h3 id="四、使用"><a href="#四、使用" class="headerlink" title="四、使用"></a>四、使用</h3><p>找到你创建的产品，然后进入到下面的界面</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Bugly%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/bugly-002.png" alt="image"></p><p>接着，发布新补丁吧，看一看效果<br><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Bugly%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/bugly-003.png" alt="image"></p><p>具体的效果可以自行尝试一下，不过有时候你会遇到上传不成功的情况，一般下发后要过5到10分钟才会生效（可能是我的网络问题），如果太久没效果，应该是哪里出问题了</p><h2 id="尾"><a href="#尾" class="headerlink" title="尾"></a>尾</h2><p>前面的所有操作都尝试过后，接下来你可能就会面临新的需求了。比如说，多渠道打包的实现，比较旧的办法是通过productFlavors去实现分别打包，不过这样会有一个弊端，即有多少渠道打包流程就执行多少次，这样效率显然是不够的；</p><p>于是乎，新的打包方案出来了：</p><h3 id="使用Walle进行多渠道打包"><a href="#使用Walle进行多渠道打包" class="headerlink" title="使用Walle进行多渠道打包"></a>使用Walle进行多渠道打包</h3><p>下面是Walle的github地址：</p><p><a href="https://github.com/Meituan-Dianping/walle" target="_blank" rel="noopener">Walle（瓦力）：Android Signature V2 Scheme签名下的新一代渠道包打包神器</a></p><p>它的接入文档写的也十分友好，接下来实际操作一遍：</p><h4 id="Walle的Gradle接入"><a href="#Walle的Gradle接入" class="headerlink" title="Walle的Gradle接入"></a>Walle的Gradle接入</h4><p>在项目根目录的 <strong>build.gradle</strong> 中添加依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &apos;com.meituan.android.walle:plugin:1.1.6&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在app module中的 <strong>build.gradle</strong> 添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;walle&apos;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;com.meituan.android.walle:library:1.1.6&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并进行插件配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">walle &#123;</span><br><span class="line">    // 指定渠道包的输出路径</span><br><span class="line">    apkOutputFolder = new File(&quot;$&#123;project.buildDir&#125;/outputs/channels&quot;);</span><br><span class="line">    // 定制渠道包的APK的文件名称</span><br><span class="line">    apkFileNameFormat = &apos;$&#123;appName&#125;-$&#123;packageName&#125;-$&#123;channel&#125;-$&#123;buildType&#125;-v$&#123;versionName&#125;-$&#123;versionCode&#125;-$&#123;buildTime&#125;.apk&apos;;</span><br><span class="line">    // 渠道配置文件</span><br><span class="line">    channelFile = new File(&quot;$&#123;project.getProjectDir()&#125;/channel&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着在app module目录下创建一个文件，和上面配置中要保持一致，就叫 <strong>channel</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">360</span><br><span class="line">yingyongbao</span><br><span class="line">baidu</span><br><span class="line">wandoujia</span><br><span class="line">xiaomi</span><br><span class="line">oppo</span><br><span class="line">lenovo</span><br><span class="line">huawei</span><br><span class="line">default_channel</span><br><span class="line"># 打包命令 gradlew clean assembleReleaseChannels  或者 gradlew assembleReleaseChannels</span><br></pre></td></tr></table></figure></p><p>最后，在你的Application中的<strong>onCreate</strong>方法里添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String channel = WalleChannelReader.getChannel(getApplication());</span><br><span class="line">Bugly.setAppChannel(getApplication(), channel);</span><br></pre></td></tr></table></figure><p>如果你实现的是<strong>SampleApplicationLike</strong>，也是在它的<strong>onCreate</strong>方法里添加即可。</p><p>接下来通过运行上面的打包命令或者通过图中的手动操作，都是可以打包的</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Bugly%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/bugly-004.png" alt="image"></p><h2 id="末"><a href="#末" class="headerlink" title="末"></a>末</h2><p>至此，基本上整个配置流程就到此结束!!!</p><p>不过有一个问题我一直不知道如何解决，就是打包基准包的命名，在 <strong>tinker-support.gradle</strong> 进行配置是不起效果的，试了好久都没效果，看来还得交给其他小伙伴们解决了</p><p><em>那么</em></p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Bugly%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/zaihui.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;头&quot;&gt;&lt;a href=&quot;#头&quot; class=&quot;headerlink&quot; title=&quot;头&quot;&gt;&lt;/a&gt;头&lt;/h2&gt;&lt;p&gt;不知道你是否遇到过这个情况，项目上线后或者开始给别人使用的时候，冷不丁的冒出个Bug，这时候首先要干嘛？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;先看崩溃日志啊&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;看完崩溃日志你知道了造成崩溃的原因，然后干嘛？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;开始甩锅啊&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当查明了是谁造成的这个崩溃后，你发现不是你的问题，于是你心中一乐，长舒一口气
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android开发者编写自己的API接口（下）</title>
    <link href="http://yoursite.com/2018/08/14/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://yoursite.com/2018/08/14/Android开发者编写自己的API接口（下）/</id>
    <published>2018-08-14T11:59:17.000Z</published>
    <updated>2018-08-14T12:05:14.085Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上一篇<a href="https://oldchen.top/2018/08/05/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="noopener">Android开发者编写自己的API接口（上）</a>中，已经介绍了如何搭建一个基本的开发环境，以及接口的编写，最后是能够成功运行的。</p><p>这一篇将更进一步，主要解决下面两个问题：</p><ul><li>①：如何让后台项目运行在TomCat上</li><li>②：如何在云服务器上部署自己的项目</li></ul><a id="more"></a><h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><h4 id="一、本地Tomcat的使用"><a href="#一、本地Tomcat的使用" class="headerlink" title="一、本地Tomcat的使用"></a>一、本地Tomcat的使用</h4><h5 id="1-1、安装Tomcat"><a href="#1-1、安装Tomcat" class="headerlink" title="1.1、安装Tomcat"></a>1.1、安装Tomcat</h5><p>使用TomCat，自然是要TomCat的安装包咯</p><p><a href="https://tomcat.apache.org/download-90.cgi" target="_blank" rel="noopener">安装包下载地址</a></p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/001.png" alt="image"></p><p>由于我们本地应该都是已经安装配置过JDK了的，所以安装Tomcat的时候一路Next就行了</p><h5 id="1-2、配置Gradle"><a href="#1-2、配置Gradle" class="headerlink" title="1.2、配置Gradle"></a>1.2、配置Gradle</h5><p>首先，在项目的gradle所在的目录下创建gradle.properties，然后在里面添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># true就去打包War，否则不打包</span><br><span class="line">BUILD_WAR=true</span><br></pre></td></tr></table></figure></p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/002.png" alt="image"></p><p>接着在build.gradle中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (BUILD_WAR.toBoolean()) &#123;</span><br><span class="line">    apply plugin: &apos;war&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (BUILD_WAR.toBoolean()) &#123;</span><br><span class="line">        providedRuntime(&apos;org.springframework.boot:spring-boot-starter-tomcat&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/003.png" alt="image"></p><p>同时，不要忘了创建一个ServletInitializer类，用于SpringBoot的初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ServletInitializer extends SpringBootServletInitializer &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123;</span><br><span class="line">return application.sources(TestForDemoApplication.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/008.png" alt="image"></p><p>这些都完成后，在Terminal控制台输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradlew assemble</span><br></pre></td></tr></table></figure><p>等待结果，然后就可以看到一个war包了</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/004.png" alt="image"></p><h5 id="1-3、配置Tomcat"><a href="#1-3、配置Tomcat" class="headerlink" title="1.3、配置Tomcat"></a>1.3、配置Tomcat</h5><p>找到demo-0.0.1-SNAPSHOT.war所在目录，然后将其更名为oldchen.war</p><pre><code>注意，这里修改后的名字将会与部署到Tomcat上的网络请求地址有关哦</code></pre><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/005.png" alt="image"></p><p>然后找到Tomcat的安装目录下的webapps目录，将里面的其他文件和文件夹删除，把oldchen.war复制到该目录</p><p>接下来，在Tomcat目录下的bin目录中运行Tomcat9w.exe</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/006.png" alt="image"></p><p>然后你会发现，webapps目录下多了一个文件</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/007.png" alt="image"></p><h5 id="1-4、测试本地Tomcat"><a href="#1-4、测试本地Tomcat" class="headerlink" title="1.4、测试本地Tomcat"></a>1.4、测试本地Tomcat</h5><p>接下来，访问地址：</p><p><a href="http://localhost:8080/oldchen/user/user?account=oldchen" target="_blank" rel="noopener">http://localhost:8080/oldchen/user/user?account=oldchen</a></p><p>结果：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/009.png" alt="image"></p><p>可以看到，本地的Tomcat已经部署成功，接下来就是云服务器上部署Tomcat了。</p><h4 id="二、云服务器上Tomcat的部署"><a href="#二、云服务器上Tomcat的部署" class="headerlink" title="二、云服务器上Tomcat的部署"></a>二、云服务器上Tomcat的部署</h4><h5 id="2-1、购买云服务器"><a href="#2-1、购买云服务器" class="headerlink" title="2.1、购买云服务器"></a>2.1、购买云服务器</h5><p>想在云服务器上部署Tomcat，首先需要购买一个服务器，我买的是腾讯云的服务器，初次接触的同学建议去使用试用的云服务器，等操作成功后再买也不迟</p><p>出于对初学者的人文关怀（没错，Is me），这里我使用的是Windows版的服务器：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/010.png" alt="image"></p><p>为了能够正常访问服务器的地址，需要给服务器配置一下安全组，安全组中需要添加这样一项规则：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/011.png" alt="image"></p><p>然后，使用远程连接，连接到云服务器，具体操作是：</p><pre><code>一、win+R二、输入mstsc三、输入云服务器的Ip地址，用户名以及密码，连接</code></pre><p>如果你使用的是windows2016版的服务器，同时遇到了”身份验证错误，要求的函数不支持”，而且你恰好是win10家庭版，那么下面有解决办法：<br><a href="https://jingyan.baidu.com/album/67508eb47ae5499ccb1ce410.html?picindex=3" target="_blank" rel="noopener">windows10家庭版 远程桌面报错</a></p><p>成功登录后，整个界面只有一个孤伶伶的回收站，到了这步，就准备开始配置吧。</p><h5 id="2-2、配置云服务器"><a href="#2-2、配置云服务器" class="headerlink" title="2.2、配置云服务器"></a>2.2、配置云服务器</h5><p>云服务器上面运行项目只需要Tomcat+Mysql+Navicat+JDK，配置方法和之前在本地配置是一样的，不过这里不建议使用上传的方法，因为上传实际上和下载是一样的，有时候还会受限于你自己宽带的上行速度。</p><p>重新下载安装JDK是很头疼的，下面是详细教程：</p><p><a href="https://blog.csdn.net/qq_32519693/article/details/71330930" target="_blank" rel="noopener">非常详细图文JDK和Tomcat安装和配置的图文教程</a></p><p>全部需要准备的文件如下：<br><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/012.png" alt="image"></p><p>其中，<strong>PatchNavicat</strong> 用于Navicat的破解，在上一篇的链接中已经说明。</p><p>而<strong>oldchen.sql</strong>则是通过本地Navicat生成Mysql文件，具体操作是：右键你选中的数据库，选择【转储SQL文件】→【结构和数据】，然后就可以生成了。使用方法就是在云服务器上创建一个数据库后选择【运行SQL文件】即可。</p><p>这样，本地数据库的迁移就完成了。剩下的操作与之前介绍的基本一致，不过有一点需要注意，为了开启外网连接，需要在Tomcat安装目录下找到conf目录，修改其中的server.xml文件：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/013.png" alt="image"></p><p>将port由8080修改为80</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/014.png" alt="image"></p><p>当你完成全部的操作后，就可以测试接口了。</p><h5 id="2-3、测试云服务器接口"><a href="#2-3、测试云服务器接口" class="headerlink" title="2.3、测试云服务器接口"></a>2.3、测试云服务器接口</h5><p>只要你的步骤是ok的，那么云服务器不会有什么问题。</p><p>由于在写这篇文章期间，我又多写了个登录接口，所以这里的测试例子用的是新的接口，仅供参考：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/015.png" alt="image"></p><p>请求地址是：<a href="http://111.230.251.115/oldchen/user/login" target="_blank" rel="noopener">http://111.230.251.115/oldchen/user/login</a></p><h2 id="后语"><a href="#后语" class="headerlink" title="后语"></a>后语</h2><p>那么，编写接口的学习就到此为止了。</p><p>虽然有待完善的地方还不少，比如通过数据库指令对数据库进行增删改查、数据库之间相互关联等等，许多知识都需要慢慢学的。</p><p>此文章权当入门之径，剩下的还得靠大家自己多多钻研啦，毕竟作者本人需要学的地方也太多了，如有错误之处，还望指出，互相学习，岂不乐哉。</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/%E8%A1%A8%E6%83%85%E5%8C%85/%E5%91%8A%E8%BE%9E2.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在上一篇&lt;a href=&quot;https://oldchen.top/2018/08/05/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android开发者编写自己的API接口（上）&lt;/a&gt;中，已经介绍了如何搭建一个基本的开发环境，以及接口的编写，最后是能够成功运行的。&lt;/p&gt;
&lt;p&gt;这一篇将更进一步，主要解决下面两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;①：如何让后台项目运行在TomCat上&lt;/li&gt;
&lt;li&gt;②：如何在云服务器上部署自己的项目&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android开发者编写自己的API接口（上）</title>
    <link href="http://yoursite.com/2018/08/05/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://yoursite.com/2018/08/05/Android开发者编写自己的API接口（上）/</id>
    <published>2018-08-05T13:31:04.000Z</published>
    <updated>2018-08-14T11:58:19.026Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>作为一名Android开发人员，想要实现对一些数据的操作和展示，可以通过一些提供Api接口的网站去获取，虽然Api市场上种类繁多，不过别人提供的接口未必就是自己想要的，到最后，还是得自己去实现Api接口。</p><p>毕竟，最了解自己需求的人，还得是自己。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>很多小伙伴应该都会有着类似的需求，不过想去做的时候，常常无从下手。</p><p>所以这里做了一个整合，关于如何搭建开发环境，以及所需工具的下载等。</p><a id="more"></a> <p>参考文章：</p><ul><li><a href="https://www.jianshu.com/p/4a0d40806ea2" target="_blank" rel="noopener">Android程序员搭建一个属于自己的服务器，不再求各种公共API</a></li><li><a href="https://www.jianshu.com/p/f91ca5814bcf" target="_blank" rel="noopener">JAVA后台搭建(springboot+mybatis+mysql)项目搭建</a></li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>一套开发环境下来，需要下面这些步骤：</p><ul><li>1：搭建开发环境，IntelliJ + spring-boot + mybatis</li><li>2：搭建数据库，mysql + navicat</li><li>3：搭建运行环境，tomcat + 腾讯云（或者阿里云）</li></ul><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="一、搭建开发环境"><a href="#一、搭建开发环境" class="headerlink" title="一、搭建开发环境"></a>一、搭建开发环境</h3><h4 id="1-1-IntelliJ-IDEA的安装"><a href="#1-1-IntelliJ-IDEA的安装" class="headerlink" title="1.1 IntelliJ IDEA的安装"></a>1.1 IntelliJ IDEA的安装</h4><p>Android开发者所使用的Android studio是基于这个IDEA开发的，所以两者的界面非常非常相似。</p><p>而且现在比较流行的Android开发语言Kotlin也是由IntelliJ IDEA的开发公司JetBrains所开发的。</p><h5 id="下载-IntelliJ-IDEA"><a href="#下载-IntelliJ-IDEA" class="headerlink" title="下载 IntelliJ IDEA"></a>下载 IntelliJ IDEA</h5><p>首先，下载安装包——<a href="https://www.jetbrains.com/idea/download/#section=windows" target="_blank" rel="noopener">【IntelliJ下载地址】</a></p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001.png" alt="image"></p><h5 id="安装-IntelliJ-IDEA"><a href="#安装-IntelliJ-IDEA" class="headerlink" title="安装 IntelliJ IDEA"></a>安装 IntelliJ IDEA</h5><p>下载完成后，就开始安装了</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-001.png" alt="image"></p><p>Next到下面的界面，可以自行选择</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-002.png" alt="image"></p><p>然后一直下一步，到可以运行IDEA，然后你应该会遇到需要购买的提示，破解的教程请看：</p><p><a href="https://blog.csdn.net/yangying496875002/article/details/73603303" target="_blank" rel="noopener">Windows7下安装与破解IntelliJ IDEA2017</a></p><p>win10也是适用的。</p><h4 id="1-2-MySQL的安装"><a href="#1-2-MySQL的安装" class="headerlink" title="1.2 MySQL的安装"></a>1.2 MySQL的安装</h4><h5 id="下载MySQL"><a href="#下载MySQL" class="headerlink" title="下载MySQL"></a>下载MySQL</h5><p>这里使用的是mysql-5.7.17.msi，下载地址是：</p><p><a href="https://downloads.mysql.com/archives/installer/" target="_blank" rel="noopener">MYSQL下载地址</a></p><h5 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h5><p>下载完成后进行安装：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-006.png" alt="image"></p><p>这里只选择了Server</p><p>然后一直下一步</p><p>到了设置密码这里，我设置的密码是【oldchen】,后面项目配置的密码也是这个，这里你可以随便设置自己的密码，不过后面配置的时候要保证密码输入一致就是：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-007.png" alt="image"></p><p>然后一直下一步，直到安装成功，接下来就是如何去操作数据库。</p><h4 id="1-3-Navicat的安装"><a href="#1-3-Navicat的安装" class="headerlink" title="1.3 Navicat的安装"></a>1.3 Navicat的安装</h4><p>Navicat用来对数据库进行操作，也是需要付费购买的，破解地址：<br><a href="https://blog.csdn.net/wypersist/article/details/79834490" target="_blank" rel="noopener">Navicat for MySQL 安装和破解（完美）</a></p><p>可以使用之后，来到如下界面：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-008.png" alt="image"></p><p>然后创建MYSQL连接：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-009.png" alt="image"></p><p>输入相关信息：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-010.png" alt="image"></p><p>然后就可以看到创建的连接了，右键→新建数据库：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-011.png" alt="image"></p><p>新建的数据库名字设置为oldchen,接下来双击这个数据库，新建一个user表,表中包含account,password,username以及自增主键id，具体操作如图所示：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/gif/001.gif" alt="image"></p><p>创建这个表后，我们可以添加一条数据：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-012.png" alt="image"></p><p>然后，开始配置IntelliJ IDEA</p><h4 id="1-4-IntelliJ-IDEA的配置"><a href="#1-4-IntelliJ-IDEA的配置" class="headerlink" title="1.4 IntelliJ IDEA的配置"></a>1.4 IntelliJ IDEA的配置</h4><h5 id="搭建SpringBoot项目"><a href="#搭建SpringBoot项目" class="headerlink" title="搭建SpringBoot项目"></a>搭建SpringBoot项目</h5><p>打开IntelliJ，左上角 File → New → Project，创建新项目：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-013.png" alt="image"></p><p>然后</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-004.png" alt="image"></p><p>接下来是选择依赖的界面，选中图中的全部依赖</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-005.png" alt="image"></p><p>下一步<br><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-019.png" alt="image"></p><p>开始项目构建，需要等待一定的时间，构建完成后的项目结构是这样的：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-015.png" alt="image"></p><p>结合之前新建的数据库，在resources目录下的application.properties中进行配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#oldchen为创建的数据库名字</span><br><span class="line">spring.datasource.url =jdbc:mysql://localhost:3306/oldchen</span><br><span class="line">mybatis.type-aliases-package = com.example.demo</span><br><span class="line"># 数据库用户名</span><br><span class="line">spring.datasource.username = root</span><br><span class="line"># 数据库密码</span><br><span class="line">spring.datasource.password = oldchen</span><br><span class="line"></span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line">#端口号</span><br><span class="line">spring.session.store-type=none</span><br><span class="line">spring.http.encoding.charset=UTF-8</span><br></pre></td></tr></table></figure><p>接下来就开始写接口啦</p><h4 id="1-5-接口的编写"><a href="#1-5-接口的编写" class="headerlink" title="1.5 接口的编写"></a>1.5 接口的编写</h4><p>由于我们之前在操作名为【oldchen】的数据库时，还新建了一个【user】表，所以这里先创建一个User类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String account;</span><br><span class="line">    private String password;</span><br><span class="line">    private String userName;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAccount() &#123;</span><br><span class="line">        return account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAccount(String account) &#123;</span><br><span class="line">        this.account = account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPassword(String password) &#123;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getUserName() &#123;</span><br><span class="line">        return userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUserName(String userName) &#123;</span><br><span class="line">        this.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建UserMapper，用于查询（根据字段account查询）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface UserMapper &#123;</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select * from user where account = #&#123;account&#125;&quot;)</span><br><span class="line">    User findByAccount(String account);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着创建UserController，用于对数据的处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&#123;&quot;/user&quot;&#125;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value=&quot;/user&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String getUserInfoByName(String account) &#123;</span><br><span class="line">        User user = userMapper.findByAccount(account);</span><br><span class="line">        if (user == null)&#123;</span><br><span class="line">            return &quot;用户名保不存在&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &quot;用户名存在——&quot; + user.getUserName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后项目结构如下：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-016.png" alt="image"></p><h3 id="二、测试接口"><a href="#二、测试接口" class="headerlink" title="二、测试接口"></a>二、测试接口</h3><p>首先，运行项目</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-017.png" alt="image"></p><p>当项目正常运行后，测试下面的地址：</p><p><a href="http://localhost:8080/user/user?account=oldchen" target="_blank" rel="noopener">http://localhost:8080/user/user?account=oldchen</a></p><p>结果：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-018.png" alt="image"></p><p>测试成功啦！</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>关于Api接口的学习，先到这里。</p><p>后面还会写关于如何将项目放在TomCat上，最后放在云服务器上，通过外网地址访问接口</p><p>那么，未完待续…</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/%E8%A1%A8%E6%83%85%E5%8C%85/%E5%91%8A%E8%BE%9E.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;作为一名Android开发人员，想要实现对一些数据的操作和展示，可以通过一些提供Api接口的网站去获取，虽然Api市场上种类繁多，不过别人提供的接口未必就是自己想要的，到最后，还是得自己去实现Api接口。&lt;/p&gt;
&lt;p&gt;毕竟，最了解自己需求的人，还得是自己。&lt;/p&gt;
&lt;h2 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h2&gt;&lt;p&gt;很多小伙伴应该都会有着类似的需求，不过想去做的时候，常常无从下手。&lt;/p&gt;
&lt;p&gt;所以这里做了一个整合，关于如何搭建开发环境，以及所需工具的下载等。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Old Chen&#39;s Wish List</title>
    <link href="http://yoursite.com/2018/07/29/Old%20Chen&#39;s%20Wish%20List/"/>
    <id>http://yoursite.com/2018/07/29/Old Chen&#39;s Wish List/</id>
    <published>2018-07-29T14:51:44.000Z</published>
    <updated>2018-08-14T12:03:05.890Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Old-Chen的愿望"><a href="#一、Old-Chen的愿望" class="headerlink" title="一、Old Chen的愿望"></a>一、Old Chen的愿望</h2><h4 id="1-、have-a-good-feel"><a href="#1-、have-a-good-feel" class="headerlink" title="(1)、have a good feel"></a>(1)、have a good feel</h4><h4 id="2-、看完所有买的文学书"><a href="#2-、看完所有买的文学书" class="headerlink" title="(2)、看完所有买的文学书"></a>(2)、看完所有买的文学书</h4><ul><li style="list-style: none"><input type="checkbox"> 1：东野硅谷系列</li><li style="list-style: none"><input type="checkbox"> 2：三体系列             （✔××）<a id="more"></a> </li><li style="list-style: none"><input type="checkbox"> 3：《时间简史》</li><li style="list-style: none"><input type="checkbox"> 4：《边城》</li><li style="list-style: none"><input type="checkbox"> 5：《百年孤独》</li><li style="list-style: none"><input type="checkbox"> 6：《茶馆》</li></ul><h4 id="3-、买一些想买的东西"><a href="#3-、买一些想买的东西" class="headerlink" title="(3)、买一些想买的东西"></a>(3)、买一些想买的东西</h4><ul><li style="list-style: none"><input type="checkbox"> 1：《矮大紧指北》</li><li style="list-style: none"><input type="checkbox" checked> 2：《老梁的四大名著情商课》     </li><li style="list-style: none"><input type="checkbox" checked> 3：一个新的手机                </li><li style="list-style: none"><input type="checkbox"> 4：预购游戏</li><li style="list-style: none"><input type="checkbox" checked> 5：好吃的零食</li><li style="list-style: none"><input type="checkbox"> 6：一个天文望远镜</li><li style="list-style: none"><input type="checkbox" checked> 7：一个游戏机(switch)</li></ul><h4 id="4-、玩完已经买了的游戏"><a href="#4-、玩完已经买了的游戏" class="headerlink" title="(4)、玩完已经买了的游戏"></a>(4)、玩完已经买了的游戏</h4><ul><li style="list-style: none"><input type="checkbox"> 1：《巫师3》</li><li style="list-style: none"><input type="checkbox" checked> 2：《黑魂3》                 （全成就）</li><li style="list-style: none"><input type="checkbox"> 3：刺客信条系列</li><li style="list-style: none"><input type="checkbox"> 4：《古墓丽影：崛起》</li><li style="list-style: none"><input type="checkbox" checked> 5:《杀戮尖塔》 （全成就）</li><li style="list-style: none"><input type="checkbox" checked> 5:《塞尔达传说：旷野之息》 （救出公主）</li></ul><h4 id="5-、写APP"><a href="#5-、写APP" class="headerlink" title="(5)、写APP"></a>(5)、写APP</h4><ul><li style="list-style: none"><input type="checkbox"> 写一个日记本APP    (Wringting)</li><li style="list-style: none"><input type="checkbox"> 写一个单词生词本APP</li></ul><h4 id="6-、养宠物-Hard"><a href="#6-、养宠物-Hard" class="headerlink" title="(6)、养宠物(Hard)"></a>(6)、养宠物(Hard)</h4><ul><li style="list-style: none"><input type="checkbox"> 养一只猫  </li></ul><h2 id="二、Old-Chen的长期愿望-Hard"><a href="#二、Old-Chen的长期愿望-Hard" class="headerlink" title="二、Old Chen的长期愿望(Hard)"></a>二、Old Chen的长期愿望(Hard)</h2><h4 id="1-、学习啦"><a href="#1-、学习啦" class="headerlink" title="(1)、学习啦"></a>(1)、学习啦</h4><h4 id="2-、充实自己"><a href="#2-、充实自己" class="headerlink" title="(2)、充实自己"></a>(2)、充实自己</h4><h4 id="3-、自得其乐"><a href="#3-、自得其乐" class="headerlink" title="(3)、自得其乐"></a>(3)、自得其乐</h4><h2 id="三、老晨子的终极愿望"><a href="#三、老晨子的终极愿望" class="headerlink" title="三、老晨子的终极愿望"></a>三、老晨子的终极愿望</h2><p><strong>莫春者，春服既成，冠者五六人，童子六七人，浴乎沂，风乎舞雩，咏而归</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、Old-Chen的愿望&quot;&gt;&lt;a href=&quot;#一、Old-Chen的愿望&quot; class=&quot;headerlink&quot; title=&quot;一、Old Chen的愿望&quot;&gt;&lt;/a&gt;一、Old Chen的愿望&lt;/h2&gt;&lt;h4 id=&quot;1-、have-a-good-feel&quot;&gt;&lt;a href=&quot;#1-、have-a-good-feel&quot; class=&quot;headerlink&quot; title=&quot;(1)、have a good feel&quot;&gt;&lt;/a&gt;(1)、have a good feel&lt;/h4&gt;&lt;h4 id=&quot;2-、看完所有买的文学书&quot;&gt;&lt;a href=&quot;#2-、看完所有买的文学书&quot; class=&quot;headerlink&quot; title=&quot;(2)、看完所有买的文学书&quot;&gt;&lt;/a&gt;(2)、看完所有买的文学书&lt;/h4&gt;&lt;ul&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; 1：东野硅谷系列&lt;/li&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; 2：三体系列             （✔××）
    
    </summary>
    
    
  </entry>
  
</feed>
