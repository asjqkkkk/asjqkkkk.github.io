<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>老晨子の博客</title>
  
  <subtitle>想写的时候写一些</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-05T05:05:57.744Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Old Chen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kotlin笔记(五):基础篇latest</title>
    <link href="http://yoursite.com/2018/10/05/Kotlin%E7%AC%94%E8%AE%B0-%E4%BA%94-%E5%9F%BA%E7%A1%80%E7%AF%87latest/"/>
    <id>http://yoursite.com/2018/10/05/Kotlin笔记-五-基础篇latest/</id>
    <published>2018-10-05T05:04:28.000Z</published>
    <updated>2018-10-05T05:05:57.744Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-可空类型"><a href="#1-可空类型" class="headerlink" title="1.可空类型"></a>1.可空类型</h3><p>问号可以加在任何类型的后面来表示这个类型的变量可以存储 null 引用 ： String?、 Int?、 MyCustomType? ，等等</p><p>一旦你有一个可空类型的值，能对它进行的操作也会受到限制。例如，不能再调用它的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; fun strLenSafe(s: String?) = s.length() </span><br><span class="line">ERROR: only safe (?.) or non null asserted (!!.) calls are allowed on a nullable receiver of type kotlin.String?</span><br></pre></td></tr></table></figure></p><p>也不能把它赋值给非空类型的变量 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; val x: String? = null </span><br><span class="line">&gt;&gt; var y: String = x </span><br><span class="line">ERROR: Type mismatch: inferred type is String? but String was expected</span><br></pre></td></tr></table></figure></p><a id="more"></a> <p>也不能把可空类型的值传给拥有非空类型参数的函数 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; strLen(x) </span><br><span class="line">ERROR: Type mismatch: inferred type is String? but String was expected</span><br></pre></td></tr></table></figure></p><p>那么你可以对它做什么呢？最重要的操作就是和 null 进行比较。 而且一旦你 进行了比较操作，编译器就会记住，并且在这次比较发生的作用域内把这个值当作非空来对待</p><h3 id="2-安全调用运算符：”-”"><a href="#2-安全调用运算符：”-”" class="headerlink" title="2.安全调用运算符：”?.”"></a>2.安全调用运算符：”?.”</h3><blockquote><p>Kotlin的弹药库中最有效的一种工具就是安全调用运算符：?.，它允许你把一 次null检查和一次方法调用合并成一个操作。</p></blockquote><p>例如，表达式 s?.toUpperCase() 等同于下面这种烦琐的写法：if(s!=null) s.toUpperCase() else null。 </p><h3 id="3-Elvis运算符：”-”"><a href="#3-Elvis运算符：”-”" class="headerlink" title="3.Elvis运算符：”?:”"></a>3.Elvis运算符：”?:”</h3><p>Kotlin 有方便的运算符来提供代替null的默认值。它被称作<strong>Elvis运算符</strong>（或者 null合并运算符，如果你喜欢听起来更严肃的名称）。下面展示了它是如何使用的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun foo(s: String?) &#123;</span><br><span class="line">    val t: String= s?:&quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>Elvis 运算符接收两个运算数，如果第一个运算数不为null，运算结果就是第 一个运算数；如果第一个运算数为null，运算结果就是第二个运算数。</em></p><h3 id="4-安全转换：”as-”"><a href="#4-安全转换：”as-”" class="headerlink" title="4.安全转换：”as?”"></a>4.安全转换：”as?”</h3><blockquote><p>as? 运算符尝试把值转换成指定的类型，如果值不是合适的类型就返回 null</p></blockquote><p>一种常见的模式是把安全转换和 Elvis 运算符结合使用。例如，实现 equals 方法的时候这样的用法非常方便。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Person(val firstNarne: String, val lastNarne: String)&#123;</span><br><span class="line">    override fun equals(o: Any?): Boolean &#123;</span><br><span class="line">        val otherPerson = o as? Person?: return false</span><br><span class="line">        return otherPerson.firstNarne == firstNarne &amp;&amp; otherPerson.lastNarne == lastNarne </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override fun hashCode(): Int = firstNarne.hashCode() * 37 + lastNarne.hashCode() </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt; val pl = Person ( &quot;Drnitry&quot;,&quot;Jernerov&quot;) </span><br><span class="line">&gt;&gt; val p2 = Person ( &quot;Drnitry&quot;,&quot;Jernerov&quot;) </span><br><span class="line">&gt;&gt; println (pl == p2) </span><br><span class="line">true</span><br><span class="line">&gt;&gt; println(pl.equals(42)) </span><br><span class="line">false</span><br></pre></td></tr></table></figure><h3 id="5-非空断言：”-”"><a href="#5-非空断言：”-”" class="headerlink" title="5.非空断言：”!!”"></a>5.非空断言：”!!”</h3><blockquote><p>非空断言是 Kotlin 提供给你的最简单直率的处理可空类型值的工具。它使用双感叹号表示，可以把任何值转换成非空类型。如果对 null 值做非空断言，则会抛出异常。</p></blockquote><p>某些问题适合用非空断言来解决。当你在一个函数中检查一个值是否为null，而在另一个函数中使用这个值时，这种情况下编译器无法识别这种用法是否安全。如果你确信这样的检查一定在其他某个函数中存在，你可能不想在使用这个值之前重复检查，这时你就可以使用非空断言。</p><p> 当你使用 !! 并且它的结果是异常时， 异常调用械的跟踪信息只表明异常发生在哪一行代码，而不会表明异常发生在哪一个表达 式。 为了让跟踪信息更清晰精确地表示哪个值为 null，最好避免在同一行中使用多个!!断言</p><h3 id="6-”let”函数"><a href="#6-”let”函数" class="headerlink" title="6.”let”函数"></a>6.”let”函数</h3><blockquote><p>let 函数让处理可空表达式变得更容易。 和安全调用运算符一起，它允许你对表达式求值，检查求值结果是否为 null，并把结果保存为一个变量。 所有这些动作都在同一个简洁的表达式中。 </p></blockquote><p>下面举个栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun sendEmailTo(email: String) &#123; /* ... */ &#125;</span><br></pre></td></tr></table></figure><p>不能把可空类型的值传上面给这个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; val email: String? = ...</span><br><span class="line">&gt;&gt; sendEmailTo(email) </span><br><span class="line">ERROR: Type mismatch: inferred type is String? but String was expected</span><br></pre></td></tr></table></figure><p>必须显式地检查这个值不为 null:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (email != null) sendEmailTo(email)</span><br></pre></td></tr></table></figure><p>如果使用了let函数，会是下面这样子的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">email?.let &#123; email -&gt; sendEmailTo(email) &#125;</span><br></pre></td></tr></table></figure><p><strong>let</strong> 函数只在 email 的值非空时才被调用，所以你就能在 lambda 中把 email 当作非空的实参使用。<br>使用自动生成的名字 it 这种简明语法之后，上面的代码就更短了 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">email?.let&#123; sendEmailTo(it) ｝</span><br></pre></td></tr></table></figure></p><h3 id="7-延迟初始化的属性"><a href="#7-延迟初始化的属性" class="headerlink" title="7.延迟初始化的属性"></a>7.延迟初始化的属性</h3><p>Kotlin 通常要求你在构造方法中初始化所有属性，如果某个属性是 非空类型，你就必须提供非空的初始化值。否则，你就必须使用可空类型。否则， 你就必须使用可空类型。如果你这样做，该属性的每一次访问都需要 null 检查或者 !! 运算符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class MyService &#123;</span><br><span class="line">    fun performAction() : String = &quot;foo&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyTest&#123;</span><br><span class="line">    private var myService: MyService? = null </span><br><span class="line">    </span><br><span class="line">    @Before fun setUp()&#123;</span><br><span class="line">        myService = MyService() </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    @Test fun testAction()&#123;</span><br><span class="line">        //必须注意可空性：要么 用!!， 要么用?.</span><br><span class="line">        Assert.assertEquals( &quot;foo&quot; ， myService!!.performAction() ) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码很难看，尤其是你要反复使用这个属性的时候。<br>为了解决这个问题， 使用 <strong>lateinit</strong> 修饰符来完成这样的声明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class MyService &#123;</span><br><span class="line">    fun performAction() : String = &quot;foo&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyTest&#123;</span><br><span class="line">    //声明一个不需要初始化 器的非空类型的属性</span><br><span class="line">    private lateinit var myService: MyService</span><br><span class="line">    </span><br><span class="line">    @Before fun setUp()&#123;</span><br><span class="line">        myService = MyService() </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Test fun testAction()&#123;</span><br><span class="line">        //不需要 null 检查直接访问属性</span><br><span class="line">        Assert.assertEquals( &quot;foo&quot; ， myService!!.performAction() ) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>注意， 延迟初始化的属性都是 var，因为需要在构造方法外修改它的值</em></p><h3 id="8-”Any”和”Any-”：根类型"><a href="#8-”Any”和”Any-”：根类型" class="headerlink" title="8.”Any”和”Any?”：根类型"></a>8.”Any”和”Any?”：根类型</h3><blockquote><p>和 Object 作为 Java 类层级结构的根差不多， <strong>Any</strong> 类型是 Kotlin 所有非空类型的超类型（非空类型的根）。</p><p>但是在 Java 中， Object 只是所有引用类型的超类 型（引用类型的根），而基本数据类型并不是类层级结构的一部分。</p><p>这意味着当你 需要 Object 的时候，不得不使用像 java.lang.Integer 这样的包装类型来表示基本数据类型的值。 <strong>而在 Kotlin 中， Any 是所有类型的超类型（所有类型的根）</strong>， 包括像 Int 这样的基本数据类型。 </p></blockquote><p>和 Java 一样，把基本数据类型的值赋给 <strong>Any</strong> 类型的变量时会自动装箱：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val answer: Any = 42</span><br></pre></td></tr></table></figure><p><em>注意 <strong>Any</strong> 是非空类型，所以 <strong>Any</strong> 类型的变量不可以持有 null 值</em></p><h3 id="9-Unit-类型-：-Kotlin-的”void”"><a href="#9-Unit-类型-：-Kotlin-的”void”" class="headerlink" title="9.Unit 类型 ： Kotlin 的”void”"></a>9.Unit 类型 ： Kotlin 的”void”</h3><p>Kotlin 中的 <strong>Unit</strong> 类型完成了 Java 中的 void 一样的功能。当函数没什么有意思的结果要返回时，它可以用作函数的返回类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun f () : Unit &#123; . . . &#125;</span><br></pre></td></tr></table></figure></p><p>语法上，这和写一个带有代码块体但不带类型声明的函数没有什么不同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun f () &#123; .. &#125;         //缩写版</span><br></pre></td></tr></table></figure><blockquote><p>Unit 是一个完备的类型，可以作为类型参数，而 void 却不行。</p></blockquote><p>在函数式编程语言中， Unit 这个名字习惯上被用来表示“只有一个实例”，这正是 Kotlin 的 Unit 和 Java 的 void 的区别。</p><h3 id="10-Nothing类型：“这个函数永不返回”"><a href="#10-Nothing类型：“这个函数永不返回”" class="headerlink" title="10.Nothing类型：“这个函数永不返回”"></a>10.Nothing类型：“这个函数永不返回”</h3><p>对某些 Kotlin 函数来说，”返回类型”的概念没有任何意义，因为它们从来不会成功地结束<br>,Kotlin 使用一种特殊的返回类型 Nothing 来表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun fail(message: String): Nothing &#123; </span><br><span class="line">    throw IllegalStateException (message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt; fail (&quot;Error occurred&quot;)</span><br><span class="line">java.lang.IllegalStateException: Error occurred</span><br></pre></td></tr></table></figure><p>Nothing 类型没有任何值， 只有被当作函数返回值使用，或者被当作泛型函数 返回值的类型参数使用才会有意义。在其他所有情况下，声明一个不能存储任何值 的变量没有任何意义。 </p><h3 id="11-可空性和集合"><a href="#11-可空性和集合" class="headerlink" title="11.可空性和集合"></a>11.可空性和集合</h3><p>遍历一个包含可空值的集合并过滤掉 null 是一个非常常见的操作，因此 Kotlin 提供了一个标准库函数 <strong>filterNotNull</strong> 来完成它。 </p><h3 id="12-只读集合与可变集合"><a href="#12-只读集合与可变集合" class="headerlink" title="12.只读集合与可变集合"></a>12.只读集合与可变集合</h3><p>Kotlin 的集合设计和 Java 不同的另一项重要特质是，它把访问集合数据的接口和修改集合数据的接口分开了。这种区别存在于最基础的使用集合的接口之中:kotlin.collections.Collection。</p><p>使用 kotlin.collections.MutableCollection 接口可以修改集合中的数据。它继承了普通的 kotlin.collections.Collection 接口,还提供了方法来添加和移除元素、清空集合等。 </p><p>一般的规则是在代码的任何地方都应该使用只读接口，只在代码需要修改集合的地方使用可变接口的变体</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-可空类型&quot;&gt;&lt;a href=&quot;#1-可空类型&quot; class=&quot;headerlink&quot; title=&quot;1.可空类型&quot;&gt;&lt;/a&gt;1.可空类型&lt;/h3&gt;&lt;p&gt;问号可以加在任何类型的后面来表示这个类型的变量可以存储 null 引用 ： String?、 Int?、 MyCustomType? ，等等&lt;/p&gt;
&lt;p&gt;一旦你有一个可空类型的值，能对它进行的操作也会受到限制。例如，不能再调用它的方法&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt; fun strLenSafe(s: String?) = s.length() &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ERROR: only safe (?.) or non null asserted (!!.) calls are allowed on a nullable receiver of type kotlin.String?&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;也不能把它赋值给非空类型的变量 ：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt; val x: String? = null &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt; var y: String = x &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ERROR: Type mismatch: inferred type is String? but String was expected&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kotlin笔记(四):基础篇most plus</title>
    <link href="http://yoursite.com/2018/10/03/Kotlin%E7%AC%94%E8%AE%B0-%E5%9B%9B-%E5%9F%BA%E7%A1%80%E7%AF%87most-plus/"/>
    <id>http://yoursite.com/2018/10/03/Kotlin笔记-四-基础篇most-plus/</id>
    <published>2018-10-03T01:48:16.000Z</published>
    <updated>2018-10-03T01:48:58.682Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-成员引用"><a href="#1-成员引用" class="headerlink" title="1.成员引用"></a>1.成员引用</h3><p>Kotlin和Java8一样，如果把函数转换成一个值，你就可以传递它。  </p><blockquote><p>使用:: 运算符来转换 ：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val getAge = Person::age</span><br></pre></td></tr></table></figure><p>这种表达式称为成员引用，它提供了简明语法，来创建一个调用单个方法或者 访问单个属性的函数值。双冒号把类名称与你要引用的成员（一个方法或者一个属性）名称隔开<br><a id="more"></a> </p><h3 id="2-集合的函数式API"><a href="#2-集合的函数式API" class="headerlink" title="2.集合的函数式API"></a>2.集合的函数式API</h3><p><strong>filter</strong> 函数遍历集合并选出应用给定 <strong>lambda</strong> 后会返回 <strong>true</strong> 的那些元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; val list= listOf(l, 2, 3, 4) </span><br><span class="line">&gt;&gt; println(list.filter&#123;it % 2 == 0&#125;)</span><br></pre></td></tr></table></figure><p><strong>filter</strong> 函数可以从集合中移除你不想要的元素，但是它并不会改变这些元素。 元素的变换是 <strong>map</strong> 的用武之地。 </p><p><strong>map</strong> 函数对集合中的每一个元素应用给定的函数并把结果收集到一个新集合。可以把数字列表变换成它们平方的列表，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; val list= listOf(l, 2, 3, 4) </span><br><span class="line">&gt;&gt; println(list.map &#123; it * it &#125;</span><br><span class="line">&#123;1, 4, 9, 16&#125;</span><br></pre></td></tr></table></figure><h3 id="3-”all””any””count”和”find”：对集合应用判断式"><a href="#3-”all””any””count”和”find”：对集合应用判断式" class="headerlink" title="3.”all””any””count”和”find”：对集合应用判断式"></a>3.”all””any””count”和”find”：对集合应用判断式</h3><p>检查集合中的所有元素是否都符合某个条件（或者它的变种，是否存在符合的元素）。Kotlin中，它们是通过 <strong>all</strong> 和 <strong>any</strong> 函数表达的。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val canBeinClub27 = &#123; p: Person - &gt; p.age &lt;= 27 &#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果你对是否所有元素都满足判断式感兴趣，应该使用 <strong>all</strong> 函数：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; val people= listOf(Person (&quot;Alice&quot;, 27), Person(&quot;Bob&quot;, 31))</span><br><span class="line">&gt;&gt; println( people.all(canBeinClub27) ) </span><br><span class="line">false</span><br></pre></td></tr></table></figure><blockquote><p>如果你需要检查集合中是否至少存在一个匹配的元素，那就用 <strong>any</strong> :</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; println(people any(canBeinClub27)) </span><br><span class="line">true</span><br></pre></td></tr></table></figure><blockquote><p>如果你想知道有多少个元素满足了判断式，使用 <strong>count</strong> : </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; val people= listOf(Person(&quot;Alice&quot;, 27) , Person (&quot;Bob&quot;, 31)) </span><br><span class="line">&gt;&gt; println(people.count(canBeinClub27))</span><br><span class="line">1</span><br></pre></td></tr></table></figure><blockquote><p>要找到一个满足判断式的元素，使用 <strong>find</strong> 函数 ：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; val people= listOf(Person(&quot;Alice&quot;， 27) , Person(&quot;Bob&quot;, 31)) </span><br><span class="line">&gt;&gt; println(people.find(canBeinClub27)) </span><br><span class="line">Person(name=Alice, age=27)</span><br></pre></td></tr></table></figure><h3 id="4-groupBy-：把列表转换成分组的-map"><a href="#4-groupBy-：把列表转换成分组的-map" class="headerlink" title="4.groupBy ：把列表转换成分组的 map"></a>4.groupBy ：把列表转换成分组的 map</h3><p>假设你需要把所有元素按照不同的特征划分成不同的分组。例如，你想把人按年龄分组，相同年龄的人放在一组。把这个特征直接当作参数传递十分方便。<strong>groupBy</strong> 函数可以帮你做到这一点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; val people= listOf(Person(&quot;Alice&quot;, 31), Person(&quot;Bob&quot;, 29), Person (&quot;Carol&quot;, 31))</span><br><span class="line">&gt;&gt; println(people.groupBy &#123;it.age&#125;)</span><br></pre></td></tr></table></figure><p>这次操作的结果是一个 <strong>map</strong>，是元素分组依据的键（这个例子中是age）和元素分组（persons）之间的映射</p><h3 id="5-flatMap-和-flatten-：处理嵌套集合中的元素"><a href="#5-flatMap-和-flatten-：处理嵌套集合中的元素" class="headerlink" title="5.flatMap 和 flatten ：处理嵌套集合中的元素"></a>5.flatMap 和 flatten ：处理嵌套集合中的元素</h3><p>假设你有一堆藏书，使用 Book 类表示 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Book (val title: String, val authors: List&lt;String&gt;)</span><br></pre></td></tr></table></figure><p>每本书都可能有一个或者多个作者，可以统计出图书馆中的所有作者的 set : </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">books.flatMap &#123; it.authors &#125; toSet()</span><br></pre></td></tr></table></figure><p><strong>flatMap</strong> 函数做了两件事情：首先根据作为实参给定的函数对集合中的每个元素做变换（或者说映射），然后把多个列表合并（或者说平铺）成一个列表。 </p><blockquote><p><strong>注意，如果你不需要做任何变换，只是需要平铺一个集合，可以使用flatten函数：listOfLists.flatten() 。</strong></p></blockquote><p>Kotlin 标准库参考文档有说明，<strong>filter</strong> 和 <strong>map</strong> 都会返回一个列表。这意味着元素过多的时候，（链式）调用就会变得十分低效。为了提高效率，可以把操作变成使用序列，而不是直接使用集合，下面是对比的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">people.map(Person: :name) .filter &#123; it.startsWith(&quot;A&quot;)｝</span><br></pre></td></tr></table></figure><p>转化为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">people.asSequence()</span><br><span class="line">    .map (Person: : name)</span><br><span class="line">    .filter&#123;it.startsWith(&quot;A&quot;)&#125;</span><br><span class="line">    .tolist</span><br></pre></td></tr></table></figure></p><p>Kotlin惰性集合操作的入口就是 <strong>Sequence</strong> 接口。这个接口表示的就是一个可以逐个列举元素的元素序列。 </p><p>可以调用扩展函数 <strong>asSequence</strong> 把任意集合转换成序列，调用  <strong>toList</strong> 来做反向的转换。 </p><h3 id="6-使用Java函数式接口"><a href="#6-使用Java函数式接口" class="headerlink" title="6.使用Java函数式接口"></a>6.使用Java函数式接口</h3><p> <strong>OnClickListener</strong> 接口只有一个抽象方法。这种接口被称为 <strong>函数式接口</strong>，或者 <strong>SAM接口</strong>，<strong>SAM</strong> 代表抽象方法。JavaAPI中随处可见像<strong>Runnable</strong>和<strong>Callable</strong>这样的函数式接口，以及支持它们<br> 的方法。 Kotlin 允许你在调用接收函数式接口作为参数的方法时使用 <strong>lambda</strong>，来保证你的 Kotlin代码既整洁又符合习惯。</p><p>可以把 <strong>lambda</strong> 传给任何期望函数式接口的方法。例如，下面这个方法，它有一个 <strong>Runnable</strong> 类型的参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Java */ </span><br><span class="line">void postponeComputation(int delay, Runnable computation);</span><br></pre></td></tr></table></figure><p>下面是显式地创建一个实现了 <strong>Runnable</strong> 的匿名对象的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">post postponeComputation(1OOO, object : Runnable &#123; </span><br><span class="line">    override fun run() &#123;</span><br><span class="line">    println(42) </span><br><span class="line">    &#125;</span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure><p>在 Kotlin 中，可以调用它并把一个 <strong>lambda</strong> 作为实参传给它。编译器会自动把它转换成一个 <strong>Runnable</strong> 的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">postponeComputation(lOOO) &#123; println(42) &#125;</span><br></pre></td></tr></table></figure><p>完全等价的实现应该是下面这段代码中的显式<strong>object</strong>声明，它把<strong>Runnable</strong>实例存储在一个变量中，并且每次调用的时候都使用这个变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val runnable = Runnable &#123; println(42) &#125; </span><br><span class="line">fun handleComputation()&#123; postponeComputation(1OOO, runnable)&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-成员引用&quot;&gt;&lt;a href=&quot;#1-成员引用&quot; class=&quot;headerlink&quot; title=&quot;1.成员引用&quot;&gt;&lt;/a&gt;1.成员引用&lt;/h3&gt;&lt;p&gt;Kotlin和Java8一样，如果把函数转换成一个值，你就可以传递它。  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用:: 运算符来转换 ：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;val getAge = Person::age&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种表达式称为成员引用，它提供了简明语法，来创建一个调用单个方法或者 访问单个属性的函数值。双冒号把类名称与你要引用的成员（一个方法或者一个属性）名称隔开&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kotlin笔记(三):基础篇more plus</title>
    <link href="http://yoursite.com/2018/10/02/Kotlin%E7%AC%94%E8%AE%B0-%E4%B8%89-%E5%9F%BA%E7%A1%80%E7%AF%87more-plus/"/>
    <id>http://yoursite.com/2018/10/02/Kotlin笔记-三-基础篇more-plus/</id>
    <published>2018-10-02T02:21:45.000Z</published>
    <updated>2018-10-02T05:09:45.019Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-接口的默认实现"><a href="#1-接口的默认实现" class="headerlink" title="1.接口的默认实现"></a>1.接口的默认实现</h3><p>接口的方法可以有一个默认实现。与Java8不同的是，Java8中需要你在这样的实现上标注default关键字，对于这样的方法，Kotlin没有特殊的注解 ：只需要提供一个方法体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Clickable&#123;</span><br><span class="line">    fun click()</span><br><span class="line">    fun showOff = println(&quot;I&apos;m clickable&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实现接口的地方如果要显式地实现方法，在Kotlin中需要把 基类的名字放在尖括号中 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">super&lt;Clickable&gt;.showOff()</span><br></pre></td></tr></table></figure></p><a id="more"></a> <h3 id="2-定义类的继承结构"><a href="#2-定义类的继承结构" class="headerlink" title="2.定义类的继承结构"></a>2.定义类的继承结构</h3><pre><code>Java的类和方法默认是open的，而Kotlin中默认都是final的。 </code></pre><p>如果你想允许创建一个类的子类，需要使用 <strong>open</strong> 修饰符来标示这个类。此外，需要给每一个可以被重写的属性或方法添加open修饰符。</p><blockquote><p><em>注意，如果你重写了一个基类或者接口的成员，重写了的成员同样默认是 open的。如果你想改变这一行为，阻止你的类的子类重写你的实现，可以显式地将重写的成员标注为 <strong>final</strong> 。</em></p></blockquote><h3 id="3-嵌套类与内部类"><a href="#3-嵌套类与内部类" class="headerlink" title="3.嵌套类与内部类"></a>3.嵌套类与内部类</h3><p>Kotlin中没有显式修饰符的嵌套类与Java中的static嵌套类是一样的。要把它变成一个内部类来持有一个外部类的引用的话需要使用 <strong>inner</strong> 修饰符。</p><p>在Kotlin中引用外部类实例的语法也与Java不同。需要使用 <strong>this@Outer</strong> 从 <strong>Inner</strong> 类去访问 <strong>Outer</strong> 类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Outer&#123;</span><br><span class="line">    inner class Inner&#123;</span><br><span class="line">        fun getOuterReference() : Outer = this@Outer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-密封类：定义受限的类继承结构"><a href="#4-密封类：定义受限的类继承结构" class="headerlink" title="4.密封类：定义受限的类继承结构"></a>4.密封类：定义受限的类继承结构</h3><p>为父类添加一个 <strong>sealed</strong> 修饰符，对可能创建的子类做出严格的限制。</p><p>如果你在 when 表达式中处理所有 <strong>sealed</strong> 类的子类，你就不再需要提供默认分支。注意， <strong>sealed</strong> 修饰符隐含的这个类是一个 <strong>open</strong> 类， 你不再需要显式地添加 <strong>open</strong> 修饰符。</p><h3 id="5-声明一个带非默认构造方法或属性的类"><a href="#5-声明一个带非默认构造方法或属性的类" class="headerlink" title="5.声明一个带非默认构造方法或属性的类"></a>5.声明一个带非默认构造方法或属性的类</h3><p>举个栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class User constructor(_nickname: String) &#123;</span><br><span class="line">    val nickname : String</span><br><span class="line">    </span><br><span class="line">    init&#123;</span><br><span class="line">        nickname = _nickname</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，可以看到两个新的Kotlin关键宇：<strong>constructor</strong> 和 <strong>init</strong> 。 <strong>constructor</strong> 关键字用来开始一个主构造方法或从构造方法的声明。 <strong>init</strong> 关键字用来引入一个初始化语句块。这种语句块包含了在类被创建时执行的代码， 并会与主构造方法一起使用。</p><blockquote><p>如果你想要确保你的类不被其他代码实例化，必须把构造方法标记为 private：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Secretive private constructor() &#123;&#125;</span><br><span class="line">//一般这么做表示这个类是一个静态实用工具成员的容器或者是单例的</span><br></pre></td></tr></table></figure><h3 id="6-通过-getter-或-setter-访问支持字段"><a href="#6-通过-getter-或-setter-访问支持字段" class="headerlink" title="6.通过 getter 或 setter 访问支持字段"></a>6.通过 getter 或 setter 访问支持字段</h3><p>假设你想在任何对存储在属性中的数据进行修改时输出日志，你声明了一个可变属性并且在每次 setter 访问时执行额外的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class ·user (val name: String) &#123; </span><br><span class="line">    var address: String =&quot;unspecified&quot; </span><br><span class="line">        set(value: String) &#123; </span><br><span class="line">            println (””“ A Address was changed for $name:</span><br><span class="line">            &quot;$field&quot; -&gt; &quot;value&quot;.&quot;&quot;&quot;&quot;.trimIndent())</span><br><span class="line">            field = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以像平常一样通过使用 user.address ＝ “new value”， 来修改一个属性的值，这其实在底层调用了 setter。</p><p>在 setter 的函数体中，使用了特殊的标识符 <strong>field</strong> 来访问支持字段的值。</p><p>如果你想修改访问器的可见性，可以像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class LengthCounter &#123;</span><br><span class="line">    var counter: Int = 0 </span><br><span class="line">    private set     //这下就不能在类外部修改这个属性了</span><br><span class="line">    </span><br><span class="line">    fun addWord(word: String)&#123;</span><br><span class="line">        counter += word.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-数据类：自动生成通用方法的实现"><a href="#7-数据类：自动生成通用方法的实现" class="headerlink" title="7.数据类：自动生成通用方法的实现"></a>7.数据类：自动生成通用方法的实现</h3><p>如果想要你的类是一个方便的数据容器，你需要重写这些方法 ： <strong>toString</strong>、 <strong>equals</strong> 和 <strong>hashCode</strong> 。在Kotlin中你不必再去生成这些方法了 。如果为你的类添加 <strong>data</strong> 修饰符，必要的方法将会自动生成好。</p><p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data class Client(val name: String, val postalCode: Int)</span><br></pre></td></tr></table></figure></p><h3 id="8-数据类和不可变性：-copy-方法"><a href="#8-数据类和不可变性：-copy-方法" class="headerlink" title="8.数据类和不可变性： copy()方法"></a>8.数据类和不可变性： copy()方法</h3><p>为了让使用不可变对象的数据类变得更容易，Kotlin编译器为它们多生成了一个方法：一个允许 <strong>copy</strong> 类的实例的方法，并在 <strong>copy</strong> 的同时修改某些属性的值:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Client (val name: String, val postalCode: Int) &#123;</span><br><span class="line">    fun copy(name: String = this.name, postalCode: Int = </span><br><span class="line">    this.postalCode) = Client(name, postalCode)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//使用</span><br><span class="line">&gt;&gt;&gt; val bob = Client(&quot;Bob”, 973293) </span><br><span class="line">&gt;&gt;&gt; println(bob.copy(postalCode = 382555))</span><br></pre></td></tr></table></figure><h3 id="9-类委托：使用“by”关键字"><a href="#9-类委托：使用“by”关键字" class="headerlink" title="9.类委托：使用“by”关键字"></a>9.类委托：使用“by”关键字</h3><p>(装饰模式我还不是太了解，了解以后再记录)</p><h3 id="10-对象声明：创建单例易如反掌"><a href="#10-对象声明：创建单例易如反掌" class="headerlink" title="10.对象声明：创建单例易如反掌"></a>10.对象声明：创建单例易如反掌</h3><p>在面向对象系统设计中一个相当常见的情形就是只需要一个实例的类。在Java中，这通常通过单例模式来实现 </p><p>Kotlin 通过使用对象声明功能为这一切提供了最高级的语言支持。对象声明将类声明与该类的单一实例声明结合到了一起。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">object Payroll &#123; </span><br><span class="line">    val allErnployees = arrayListOf&lt;Person&gt;()</span><br><span class="line"></span><br><span class="line">    fun calculateSalary() &#123; </span><br><span class="line">        for &#123;person in allErnployees) &#123; </span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对象声明通过object关键宇引入。一个对象声明可以非常高效地以一句话来定义一个类和一个该类的变量。 </p></blockquote><h3 id="11-伴生对象：工厂方法和静态成员的地盘"><a href="#11-伴生对象：工厂方法和静态成员的地盘" class="headerlink" title="11.伴生对象：工厂方法和静态成员的地盘"></a>11.伴生对象：工厂方法和静态成员的地盘</h3><p>在类中定义的对象之一可以使用一个特殊的关键字来标记：<strong>companion</strong>。如果这样做，就获得了直接通过容器类名称来访问这个对象的方法和属性的能力，不再需要显式地指明对象的名称。最终的语法看起来非常像 Java 中的静态方法调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class A &#123; </span><br><span class="line">    companion object &#123; </span><br><span class="line">        fun bar() &#123; </span><br><span class="line">        println (&quot;Companion object called&quot;) </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt; A.bar() </span><br><span class="line">Companion object called</span><br></pre></td></tr></table></figure><p>伴生对象可以访问类中的所有private成员，包括private构造方法，它是实现工厂模式的理想选择。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class User private constructor(val nickname: String) &#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        fun newSubscribingUser(email: String) =</span><br><span class="line">        User(email.substringBefore (&apos;@&apos;)) </span><br><span class="line">        </span><br><span class="line">        fun newFacebookUser(accountld: Int) = </span><br><span class="line">        User(getFacebookName(accountld)) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt; val subscribingUser = User.newSubscribingUser (&quot;bob@gmail.com&quot;) </span><br><span class="line">&gt;&gt; val facebookUser = User.newFacebookUser(4) </span><br><span class="line">&gt;&gt; println(subscribingUser.nickname)</span><br><span class="line">bob</span><br></pre></td></tr></table></figure><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><ul><li>Kotlin 的接口与 Java 的相似，但是可以包含默认实现 (Java 从第8版才开始支持)和属性。</li><li>所有的声明默认都是 final 和 public 的。</li><li>要想使声明不是 final 的，将其标记为 open。</li><li>internal 声明在同一模块中可见。</li><li>嵌套类默认不是内部类。使用inner关键字来存储外部类的引用。</li><li>sealed 类的子类只能嵌套在自身的声明中（Kotlin 1.1 允许将子类放置在同一文件的任意地方）。</li><li>初始化语句块和从构造方法为初始化类实例提供了灵活性。 </li><li>使用 field 标识符在访问器方法体中引用属性的支持字段。</li><li>数据类提供了编译器生成的 equals、 hashCode、 toString、 copy 和其他方法。 </li><li>类委托帮助避免在代码中出现许多相似的委托方法。 </li><li>对象声明是 Kotlin 中定义单例类的方法。</li><li>伴生对象（与包级别函数和属性一起）替代了Java静态方法和字段定义。 </li><li>伴生对象与其他对象一样，可以实现接口，也可以拥有有扩展函数和属性。</li><li>对象表达式是 Kotlin中针对Java匿名内部类的替代品，并增加了诸如实现多个接口的能力和修改在创建对象的作用域中定义的变量的能力等功能。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-接口的默认实现&quot;&gt;&lt;a href=&quot;#1-接口的默认实现&quot; class=&quot;headerlink&quot; title=&quot;1.接口的默认实现&quot;&gt;&lt;/a&gt;1.接口的默认实现&lt;/h3&gt;&lt;p&gt;接口的方法可以有一个默认实现。与Java8不同的是，Java8中需要你在这样的实现上标注default关键字，对于这样的方法，Kotlin没有特殊的注解 ：只需要提供一个方法体&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;interface Clickable&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fun click()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fun showOff = println(&amp;quot;I&amp;apos;m clickable&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在实现接口的地方如果要显式地实现方法，在Kotlin中需要把 基类的名字放在尖括号中 ：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;super&amp;lt;Clickable&amp;gt;.showOff()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kotlin笔记(二):基础篇plus</title>
    <link href="http://yoursite.com/2018/10/01/Kotlin%E7%AC%94%E8%AE%B0-%E4%BA%8C-%E5%9F%BA%E7%A1%80%E7%AF%87plus/"/>
    <id>http://yoursite.com/2018/10/01/Kotlin笔记-二-基础篇plus/</id>
    <published>2018-10-01T08:15:48.000Z</published>
    <updated>2018-10-01T08:16:18.797Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-顶层函数和属性"><a href="#1-顶层函数和属性" class="headerlink" title="1.顶层函数和属性"></a>1.顶层函数和属性</h3><p>在Kotlin中，可以把那些工具类里的函数直接放到代码文件的顶层，不用从属于任何的类。这些放在文件顶层的函数依然是包内的成员，如果你需要从包外访问它，则需要import，但不再需要额外包一层</p><h3 id="2-给别人的类添加方法：扩展函数和属性"><a href="#2-给别人的类添加方法：扩展函数和属性" class="headerlink" title="2.给别人的类添加方法：扩展函数和属性"></a>2.给别人的类添加方法：扩展函数和属性</h3><p>扩展函数非常简单，它就是一个类的成员函数，不过定义在类的外面。举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">package strings </span><br><span class="line">fun String.lastChar(): Char = this.get(this.length - 1) //this可以省略</span><br></pre></td></tr></table></figure><a id="more"></a> <p>从某种意义上说，你已经为String类添加了自己的方法。即使字符串不是代码的一部分，也没有类的源代码，你仍然可以在自己的项目中根据需要去扩展方法。</p><blockquote><p>注意，扩展函数并不允许你打破它的封装性。和在类内部定义的方法不同的是，扩展函数不能访私有的或者是受保护的成员。 </p><p>对于你定义的一个扩展函数，它不会自动地在整个目范围内生效。相反，如果你要使用它，需要进行导入</p><p>扩展函数并不存在重写，因为Kotiin会把它们当作静态函数对待</p></blockquote><p>下面是声明一个扩展属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val String.lastChar: Char get() = get(length - 1)</span><br></pre></td></tr></table></figure><p>可以看到，和扩展函数一样，扩展属性也像接收者的一个普通的成员属性一样。这里，必须定义getter函数，因为没有支持字段，因此没有默认getter的实现。同理，初始化也不可以：因为没有地方存储初始值。</p><pre><code>注意，当你需要从Java中访问扩展属性的时候，应该显式地调用它的getter函数</code></pre><h3 id="3-可变参数：让函数支持任意数量的参数"><a href="#3-可变参数：让函数支持任意数量的参数" class="headerlink" title="3.可变参数：让函数支持任意数量的参数"></a>3.可变参数：让函数支持任意数量的参数</h3><p>当你在调用一个函数来创建列表的时候，可以传递任意个数的参数给它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val list= list0f(2, 3, 5, 7, 11)</span><br></pre></td></tr></table></figure><p>Kotlin的可变参数与Java类似，但语法略有不同：Kotlin在该类型之后不会再使用三个点，而是在参数上使用vararg修饰符。</p><p>Kotlin和Java 之间的另一个区别是，当需要传递的参数己经包装在数组中时，调用该函数的语法。在Java中，可以按原样传递数组，而Kotlin 则要求你显式地解包数组，以便每个数组元素在函数中能作为单独的参数来调用。从技术的角度来讲，这个功能被称为展开运算符，而使用的时候，不过是在对应的参数前面放一个*：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;）&#123;</span><br><span class="line">val list = listOf(&quot;args:”,*args) </span><br><span class="line">println(list) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-键值对的处理：中缀调用和解构声明"><a href="#4-键值对的处理：中缀调用和解构声明" class="headerlink" title="4.键值对的处理：中缀调用和解构声明"></a>4.键值对的处理：中缀调用和解构声明</h3><p>可以使用 mapOf 函数来创建 map:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val map= mapOf(l to &quot;one&quot;， 7 to &quot;seven&quot;， 53 to &quot;fifty-three&quot;)</span><br></pre></td></tr></table></figure><p>这行代码中的单词to不是内置的结构，而是一种特殊的函数调用，被称为中缀调用。 </p><p>在中缀调用中，没有添加额外的分隔符，函数名称是直接放在目标对象名称和 参数之间的。以下两种调用方式是等价的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.to(&quot;one&quot;)</span><br><span class="line">1 to &quot;one&quot;</span><br></pre></td></tr></table></figure><p>中缀调用可以与只有一个参数的函数一起使用，无论是普通的函数还是扩展函 数。要允许使用中缀符号调用函数，需要使用 infix 修饰符来标记它。下面是一个 简单的 to 函数的声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">infix fun Any.to(other: Any) = Pair(this, other)</span><br></pre></td></tr></table></figure><p>to 函数是一个扩展函数，可以创建一对任何元素，这意味着它是泛型接收者的 扩展：可以使用 1 to “one” 、”one” to 1、list to list.size()等写法。 </p><h3 id="5-让你的代码更整洁：局部函数和扩展"><a href="#5-让你的代码更整洁：局部函数和扩展" class="headerlink" title="5.让你的代码更整洁：局部函数和扩展"></a>5.让你的代码更整洁：局部函数和扩展</h3><p>Kotlin可以在函数中嵌套类中提取的函数。这样，既可以获得所需的结构，也无须额外的语法开销。</p><p>举个栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class User(val id: Int, val name: String, val address: String) </span><br><span class="line"></span><br><span class="line">fun saveUser(user : User)&#123;</span><br><span class="line">    if(user.name.isEmpty())&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    if(user.address.isEmpty())&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    //保存...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果将验证代码放到局部函数中，可以摆脱重复，并保持清晰的代码结构，可以这样做 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class User(val id: Int, val name: String, val address: String) </span><br><span class="line"></span><br><span class="line">fun saveUser(user : User)&#123;</span><br><span class="line">    fun validate(user: User, value: String, fieldName: String)&#123;</span><br><span class="line">        if(value.isEmpty())&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    validate (user, user.name, &quot;Name&quot;)</span><br><span class="line">    validate (user, user.address, &quot;Address&quot;)</span><br><span class="line">    //保存...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码看起来好多了，而且局部函数可以访问所在函数中的所有参数和变量。 我们可以利用这一点，去掉冗余的User参数，这里就不再演示了</p><p>我们可以继续改进，把验证逻辑放到 User 类的扩展函数中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class User(val id: Int, val name: String, val address: String) </span><br><span class="line"></span><br><span class="line">fun User.validateBeforeSave()&#123;</span><br><span class="line">    fun validate(value: String, fieldName: String)&#123;</span><br><span class="line">        if(value.isEmpty())&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    validate (user.name, &quot;Name&quot;)</span><br><span class="line">    validate (user.address, &quot;Address&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fun saveUser(user : User)&#123;</span><br><span class="line">    user.validateBeforeSave()</span><br><span class="line">    //保存...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小结：</strong></p><ul><li><p>Kotlin没有定义自己的集合类，而是在Java集合类的基础上提供了更丰富的API。</p></li><li><p>Kotlin可以给函数参数定义默认值，这样大大降低了重载函数的必要性，而且命名参数让多参数函数的调用更加易读。</p></li><li><p>Kotlin允许更灵活的代码结构：函数和属性都可以直接在文件中声明，而不仅仅是在类中作为成员。</p></li><li><p>Kotlin可以用扩展函数和属性来扩展任何类的API，包括在外部库中定义的类，而不需要修改其源代码，也没有运行时开销。 </p></li><li><p>中缀调用提供了处理单个参数的，类似调用运算符方法的简明语法。</p></li><li><p>Kotlin为普通字符串和正则表达式都提供了大量的方便字符串处理的函数。 </p></li><li><p>三重引号的字符串提供了一种简洁的方式，解决了原本在Java中需要进行大量啰嗦的转义和宇符串连接的问题。</p></li><li><p>局部函数帮助你保持代码整洁的同时，避免重复。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-顶层函数和属性&quot;&gt;&lt;a href=&quot;#1-顶层函数和属性&quot; class=&quot;headerlink&quot; title=&quot;1.顶层函数和属性&quot;&gt;&lt;/a&gt;1.顶层函数和属性&lt;/h3&gt;&lt;p&gt;在Kotlin中，可以把那些工具类里的函数直接放到代码文件的顶层，不用从属于任何的类。这些放在文件顶层的函数依然是包内的成员，如果你需要从包外访问它，则需要import，但不再需要额外包一层&lt;/p&gt;
&lt;h3 id=&quot;2-给别人的类添加方法：扩展函数和属性&quot;&gt;&lt;a href=&quot;#2-给别人的类添加方法：扩展函数和属性&quot; class=&quot;headerlink&quot; title=&quot;2.给别人的类添加方法：扩展函数和属性&quot;&gt;&lt;/a&gt;2.给别人的类添加方法：扩展函数和属性&lt;/h3&gt;&lt;p&gt;扩展函数非常简单，它就是一个类的成员函数，不过定义在类的外面。举个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;package strings &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fun String.lastChar(): Char = this.get(this.length - 1) //this可以省略&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>论国庆节的几种过法</title>
    <link href="http://yoursite.com/2018/10/01/%E8%AE%BA%E5%9B%BD%E5%BA%86%E8%8A%82%E7%9A%84%E5%87%A0%E7%A7%8D%E8%BF%87%E6%B3%95/"/>
    <id>http://yoursite.com/2018/10/01/论国庆节的几种过法/</id>
    <published>2018-10-01T07:49:16.000Z</published>
    <updated>2018-10-01T07:50:54.126Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 中秋刚过才一个星期，国庆就来了。这七天小长假可不能就这样寥寥草草，得好好准备准备看看怎么过才行！</p></blockquote><p><strong>下面就介绍一下国庆节的几种过法</strong></p><a id="more"></a> <h2 id="一、干粮"><a href="#一、干粮" class="headerlink" title="一、干粮"></a>一、干粮</h2><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%AE%BA%E5%9B%BD%E5%BA%86%E8%8A%82%E7%9A%84%E5%A5%BD%E5%87%A0%E7%A7%8D%E8%BF%87%E6%B3%95/%E5%B9%B2%E7%B2%AE.jpg" alt="image"></p><p>干粮是必不可少的一部分，有了这个，你就不必担心饿死了！</p><h2 id="二、游戏"><a href="#二、游戏" class="headerlink" title="二、游戏"></a>二、游戏</h2><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%AE%BA%E5%9B%BD%E5%BA%86%E8%8A%82%E7%9A%84%E5%A5%BD%E5%87%A0%E7%A7%8D%E8%BF%87%E6%B3%95/%E6%B8%B8%E6%88%8F.jpg" alt="image"></p><p>所谓饱暖思淫欲，当你不必为了食物而犯愁之后，你就可以思考自身的娱乐需求了。无论是召唤师峡谷，还是艾泽拉斯大陆，都有承载你欢乐的地方，如果这些地方你不满意，还剩下索尼微软任天堂好些游戏平台呢！</p><h2 id="三、阅读"><a href="#三、阅读" class="headerlink" title="三、阅读"></a>三、阅读</h2><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%AE%BA%E5%9B%BD%E5%BA%86%E8%8A%82%E7%9A%84%E5%A5%BD%E5%87%A0%E7%A7%8D%E8%BF%87%E6%B3%95/%E9%98%85%E8%AF%BB.jpg" alt="image"></p><p>劳逸结合一直是一种非常良好的生活方式，游戏玩过头了反而会荒废你的大脑，这时候应该静下心来看看书，文学类、科学类、教材类，各式各样，应有尽有。</p><h2 id="四、运动"><a href="#四、运动" class="headerlink" title="四、运动"></a>四、运动</h2><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%AE%BA%E5%9B%BD%E5%BA%86%E8%8A%82%E7%9A%84%E5%A5%BD%E5%87%A0%E7%A7%8D%E8%BF%87%E6%B3%95/%E8%BF%90%E5%8A%A8.jpg" alt="image"></p><p>一个人身体要是不好，那多少事情都干不了，学习、娱乐之余，可别忘了运动，毕竟90后的年轻人没几个希望中年发福吧！</p><h2 id="五、出行"><a href="#五、出行" class="headerlink" title="五、出行"></a>五、出行</h2><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%AE%BA%E5%9B%BD%E5%BA%86%E8%8A%82%E7%9A%84%E5%A5%BD%E5%87%A0%E7%A7%8D%E8%BF%87%E6%B3%95/%E9%AA%91%E8%A1%8C.jpg" alt="image"></p><p>在家待久了会生霉的，所以出去转转还能让自己保持新鲜！</p><p>而且节日出行也是蛮合理的一件事，如果你真有一颗不安分的心，外面的人山人海又怎能拦得住你？</p><hr><p><strong>那么，国庆节的过法就谈到这里！我要开始享受国庆了！</strong></p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%AE%BA%E5%9B%BD%E5%BA%86%E8%8A%82%E7%9A%84%E5%A5%BD%E5%87%A0%E7%A7%8D%E8%BF%87%E6%B3%95/001.jpeg" alt="image"></p><hr><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%AE%BA%E5%9B%BD%E5%BA%86%E8%8A%82%E7%9A%84%E5%A5%BD%E5%87%A0%E7%A7%8D%E8%BF%87%E6%B3%95/002.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; 中秋刚过才一个星期，国庆就来了。这七天小长假可不能就这样寥寥草草，得好好准备准备看看怎么过才行！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;下面就介绍一下国庆节的几种过法&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kotlin笔记(一):基础篇</title>
    <link href="http://yoursite.com/2018/09/30/Kotlin%E7%AC%94%E8%AE%B0-%E4%B8%80-%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>http://yoursite.com/2018/09/30/Kotlin笔记-一-基础篇/</id>
    <published>2018-09-30T07:45:18.000Z</published>
    <updated>2018-09-30T07:46:31.866Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 在2017年的Google开发者大会上，Kotlin正式作为Android的官方开发语言闪亮登场。而现在已经到了2018年的下半年末，身为一名Android开发者，如果不会一点Kotlin，总感觉少了什么。  </p><p>于是乎，我准备动手学一学这门“年轻”的新语言了。不过新学一些东西往往会因为知识的消化需要时间而导致知识接收的效率不高，所以这时候好记性不如烂笔头的优势才得以体现嘛！  </p><p>所以，初学阶段，我还是准备记一记笔记，这样也许会对我学这门语言有所帮助吧？!</p></blockquote><p>关于Kotlin的官方文档，地址如下：</p><p><a href="https://www.kotlincn.net/docs/reference/" target="_blank" rel="noopener">Kotlin学习</a><br><a id="more"></a> </p><h3 id="1-在-Kotlin-中，if是表达式，而不是语句。"><a href="#1-在-Kotlin-中，if是表达式，而不是语句。" class="headerlink" title="1.在 Kotlin 中，if是表达式，而不是语句。"></a>1.在 Kotlin 中，if是表达式，而不是语句。</h3><p> 语句和表达式的区别在于，表达式有值，并且能作为另一个表达式的一部分使用；而语句总是包围着它的代码块中的顶层元素，并且没有自己的值。</p><ul><li>在Java中，所有的控制结构都是语句。而在Kotlin中，除了循环（ for, do 和 do/while ）以外大多数控制结构都是 表达式。<br>这种结合控制结构和其他表达式的能力让你可以简明扼要地表示许多 常见的模式，稍后你会在本书中看到这些内容。</li><li>另一方面，Java中的赋值操作是表达式，在Kotlin中反而变成了语句。这有助于避免比较和赋值之间的混淆，而这种混淆是常见的错误来源。</li></ul><h3 id="2-声明变量的关键字有两个-："><a href="#2-声明变量的关键字有两个-：" class="headerlink" title="2.声明变量的关键字有两个 ："></a>2.声明变量的关键字有两个 ：</h3><ul><li>val （来自 value） 一一不可变引用。使用 val 声明的变量不能在初始化之 后再次赋值。它对应的是 Java 的 final 变量。  </li><li>var （来自 variable） 一一可变引用。这种变量的值可以被改变。这种声明对 应的是普通（非 final）的 Java 变量。</li></ul><h3 id="3-局部变量的引用"><a href="#3-局部变量的引用" class="headerlink" title="3.局部变量的引用"></a>3.局部变量的引用</h3><p>和许多脚本语言一样， Kotlin 让你可 以在字符串字面值中引用局部变量，只需要在变量名称前面加上字符$。</p><p>这等价于 Java 中的字符串连接（ “Hello,”+ name ＋”！”），效率一样但是更紧凑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val name = if(args.size &gt; 0) args[0] else &quot;Kotlin&quot;</span><br><span class="line">    println(&quot;Hello, $name !&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以引用更复杂的表达式，而不是仅限于简单的变量名称，只需要把表达式 用花括号括起来.</p><h3 id="4-在Java中可以用switch语句完成的，而Kotlin-对应的结构是when"><a href="#4-在Java中可以用switch语句完成的，而Kotlin-对应的结构是when" class="headerlink" title="4.在Java中可以用switch语句完成的，而Kotlin 对应的结构是when"></a>4.在Java中可以用switch语句完成的，而Kotlin 对应的结构是when</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun getMnemonic(color: Color) = </span><br><span class="line">when (color) &#123; </span><br><span class="line">Color . RED -&gt;”Richard&quot; </span><br><span class="line">Color.ORANGE -&gt;”Of” </span><br><span class="line">Color.YELLOW -&gt;”York&quot; </span><br><span class="line">Color .GREEN -&gt;”Gave” </span><br><span class="line">Color.BLUE -&gt;”Battle&quot; </span><br><span class="line">Color ．工NDIGO -&gt;”In” </span><br><span class="line">Color.VIOLET -&gt;”Vain </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在一个 when 分支上合并多个选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun getWarmth(color: Color) = when(color) &#123;</span><br><span class="line">Color.RED, Color.ORANGE, Color.YELLOW - &gt; ”warm”</span><br><span class="line">Color.GREEN -&gt; ”neutral”</span><br><span class="line">Color.BLUE, Color.INDIGO, Color.VIOLET -&gt;”cold”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，也可以导入枚举常量后不用限定词就可以访问。比如去掉花括号里的Color也是可以的。</p><blockquote><p>Kotlin中的when结构比Java中的switch强大得多。switch要求必须使用常量（枚举常量、字符串或者数字字面值）作为分支条件，和它不一样， when允许使用任何对象。</p></blockquote><h3 id="5-类型判断"><a href="#5-类型判断" class="headerlink" title="5.类型判断"></a>5.类型判断</h3><p>在Kotlin中，你要使用is检查来判断一个变量是否是某种类型。is检查和Java中的instanceOf相似，不过在instanceOf检查之后还需要显式地加上类型转换。</p><p>在Kotlin中，编译器帮你完成了这些工作。如果你检查过一个变量是某种类型，后面就不再需要转换它，可以就把它当作你检查过的类型使用。</p><p>使用as关键字来表示到特定类型的显式转换；</p><h3 id="6-循环中的”in”关键字"><a href="#6-循环中的”in”关键字" class="headerlink" title="6.循环中的”in”关键字"></a>6.循环中的”in”关键字</h3><p>Kotlin里面关键字“in”有许多作用，比如检查区间的成员；作为when的分支；在for循环中使用等。关于in如何在list中使用，下章再介绍</p><h3 id="7-关于”try”"><a href="#7-关于”try”" class="headerlink" title="7.关于”try”"></a>7.关于”try”</h3><p>Kotlin中的try关键字就像if和when一样,引入了一个表达式，可以把它的值赋给一个变量。不同于if，你总是需要用花括号把语句主体括起来。和其他语句一样，如果其主体包含多个表达式，那么整个 try 表达式的值就是最后一个表达式的值。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; 在2017年的Google开发者大会上，Kotlin正式作为Android的官方开发语言闪亮登场。而现在已经到了2018年的下半年末，身为一名Android开发者，如果不会一点Kotlin，总感觉少了什么。  &lt;/p&gt;
&lt;p&gt;于是乎，我准备动手学一学这门“年轻”的新语言了。不过新学一些东西往往会因为知识的消化需要时间而导致知识接收的效率不高，所以这时候好记性不如烂笔头的优势才得以体现嘛！  &lt;/p&gt;
&lt;p&gt;所以，初学阶段，我还是准备记一记笔记，这样也许会对我学这门语言有所帮助吧？!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于Kotlin的官方文档，地址如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.kotlincn.net/docs/reference/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kotlin学习&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Bugly热修复使用及多渠道打包</title>
    <link href="http://yoursite.com/2018/09/26/Bugly%E7%83%AD%E4%BF%AE%E5%A4%8D%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85/"/>
    <id>http://yoursite.com/2018/09/26/Bugly热修复使用及多渠道打包/</id>
    <published>2018-09-26T11:54:41.000Z</published>
    <updated>2018-10-04T15:57:53.270Z</updated>
    
    <content type="html"><![CDATA[<h2 id="头"><a href="#头" class="headerlink" title="头"></a>头</h2><p>不知道你是否遇到过这个情况，项目上线后或者开始给别人使用的时候，冷不丁的冒出个Bug，这时候首先要干嘛？</p><p><strong>先看崩溃日志啊</strong></p><p>看完崩溃日志你知道了造成崩溃的原因，然后干嘛？</p><p><strong>开始甩锅啊</strong></p><p>当查明了是谁造成的这个崩溃后，你发现不是你的问题，于是你心中一乐，长舒一口气<a id="more"></a> ，仰天大笑：码海沉浮又几载，我辈岂是蓬蒿人；笑完便准备躺床上睡觉去——秋豆麻袋，是不是忘了什么东西？</p><p>是的，即使你发现了问题，并且找到了问题的来源，这时候还差一步：解决问题的办法！如何解决？</p><p><strong>发布新版本？</strong></p><p>这样不觉得很麻烦吗？特别是如果一个项目处于初期阶段，Bug是想甩都甩不掉的，如果每发现一次崩溃，都需要靠发布一个新版本去解决的话，那未免就太麻烦了。不光是开发者麻烦，使用者也会因为频繁的升级而不耐烦（just like me），那问题又回来了，如何解决？</p><p><strong>热修复啊</strong></p><p>通过线上修复Bug，让用户在神不知鬼不觉的情况下就进行了一次应用更新，麻麻再也不用担心App崩溃啦！（不存在的）</p><p>热修复还有个隐藏的好处，那就是在测试人员不够（开发兼测试），测试机型不够的情况下可以显著改善App的崩溃率。好吧，准备开始使用吧。</p><h2 id="身"><a href="#身" class="headerlink" title="身"></a>身</h2><h3 id="一、为什么要用Bugly"><a href="#一、为什么要用Bugly" class="headerlink" title="一、为什么要用Bugly"></a>一、为什么要用Bugly</h3><p>市面上关于热修复和崩溃日志监测的相关技术和SDK种类各不相同，为什么偏偏要用Bugly呢？</p><ul><li>可以获取到App崩溃日志</li><li>可以集成Think热修复</li><li>界面好看，方便管理版本</li><li>免费</li><li>（凑巧就用了这一款，其他的都没有用过）</li></ul><p>基于以上原因，最后就使用了Bugly去解决上面提到过的问题；</p><h3 id="二、Bugly热更新接入流程"><a href="#二、Bugly热更新接入流程" class="headerlink" title="二、Bugly热更新接入流程"></a>二、Bugly热更新接入流程</h3><p>其实关于Bugly热更新的接入流程，官方的文档介绍的非常详细，对新手比较友好，我第一次使用也是直接参照的文档，下面是官方文档的地址：</p><p><a href="https://bugly.qq.com/docs/user-guide/instruction-manual-android-hotfix/?v=20180709165613" target="_blank" rel="noopener">【Bugly Android热更新使用指南】</a></p><p>虽然官方有例子，这里还是写了一个简化版，也方便以后哪天自己忘记了依旧能快速使用：</p><h4 id="第一步：添加依赖插件"><a href="#第一步：添加依赖插件" class="headerlink" title="第一步：添加依赖插件"></a>第一步：添加依赖插件</h4><p>在你的项目更目录下的“build.gradle”中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        // tinkersupport插件, 其中lastest.release指拉取最新版本，也可以指定明确版本号，例如1.0.4</span><br><span class="line">        classpath &quot;com.tencent.bugly:tinker-support:1.1.2&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在写这篇文章的时候，最新的版本就是1.1.2</p><h4 id="第二步：配置依赖插件"><a href="#第二步：配置依赖插件" class="headerlink" title="第二步：配置依赖插件"></a>第二步：配置依赖插件</h4><h5 id="gradle配置"><a href="#gradle配置" class="headerlink" title="gradle配置"></a>gradle配置</h5><p>在app module的“build.gradle”文件中添加（示例配置）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">// 依赖插件脚本</span><br><span class="line">apply from: &apos;tinker-support.gradle&apos;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">        defaultConfig &#123;</span><br><span class="line">          ndk &#123;</span><br><span class="line">            //设置支持的SO库架构</span><br><span class="line">            abiFilters &apos;armeabi&apos; //, &apos;x86&apos;, &apos;armeabi-v7a&apos;, &apos;x86_64&apos;, &apos;arm64-v8a&apos;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      dependencies &#123;</span><br><span class="line">         implementation &apos;com.android.support:multidex:1.0.1&apos;</span><br><span class="line">        // 多dex配置</span><br><span class="line">        //注释掉原有bugly的仓库</span><br><span class="line">        //compile &apos;com.tencent.bugly:crashreport:latest.release&apos;//其中latest.release指代最新版本号，也可以指定明确的版本号，例如1.3.4</span><br><span class="line">        implementation &apos;com.tencent.bugly:crashreport_upgrade:1.3.5&apos;</span><br><span class="line">        // 指定tinker依赖版本（注：应用升级1.3.5版本起，不再内置tinker）</span><br><span class="line">        implementation &apos;com.tencent.tinker:tinker-android-lib:1.9.6&apos;</span><br><span class="line">        implementation &apos;com.tencent.bugly:nativecrashreport:latest.release&apos;</span><br><span class="line">        //其中latest.release指代最新版本号，也可以指定明确的版本号，例如2.2.0</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>在这个版本的SDK里面，已经集成了崩溃日志上传的功能哦！</p><h5 id="tinker-support-gradle的配置"><a href="#tinker-support-gradle的配置" class="headerlink" title="tinker-support.gradle的配置"></a>tinker-support.gradle的配置</h5><p>接下来，你要在app module目录下创建另外一个gradle文件，命名为“tinker-support.gradle”，然后对它进行配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;com.tencent.bugly.tinker-support&apos;</span><br><span class="line"></span><br><span class="line">def bakPath = file(&quot;$&#123;buildDir&#125;/bakApk/&quot;)</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 此处填写每次构建生成的基准包目录</span><br><span class="line"> */</span><br><span class="line">def baseApkDir = &quot;app-0921-14-52-06&quot;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 对于插件各参数的详细解析请参考</span><br><span class="line"> */</span><br><span class="line">tinkerSupport &#123;</span><br><span class="line"></span><br><span class="line">    // 开启tinker-support插件，默认值true</span><br><span class="line">    enable = true</span><br><span class="line"></span><br><span class="line">    // 指定归档目录，默认值当前module的子目录tinker</span><br><span class="line">    autoBackupApkDir = &quot;$&#123;bakPath&#125;&quot;</span><br><span class="line"></span><br><span class="line">    // 是否启用覆盖tinkerPatch配置功能，默认值false</span><br><span class="line">    // 开启后tinkerPatch配置不生效，即无需添加tinkerPatch</span><br><span class="line">    overrideTinkerPatchConfiguration = true</span><br><span class="line"></span><br><span class="line">    // 编译补丁包时，必需指定基线版本的apk，默认值为空</span><br><span class="line">    // 如果为空，则表示不是进行补丁包的编译</span><br><span class="line">    // @&#123;link tinkerPatch.oldApk &#125;</span><br><span class="line">    baseApk = &quot;$&#123;bakPath&#125;/$&#123;baseApkDir&#125;/app-release.apk&quot;</span><br><span class="line"></span><br><span class="line">    // 对应tinker插件applyMapping</span><br><span class="line">    baseApkProguardMapping = &quot;$&#123;bakPath&#125;/$&#123;baseApkDir&#125;/app-release-mapping.txt&quot;</span><br><span class="line"></span><br><span class="line">    // 对应tinker插件applyResourceMapping</span><br><span class="line">    baseApkResourceMapping = &quot;$&#123;bakPath&#125;/$&#123;baseApkDir&#125;/app-release-R.txt&quot;</span><br><span class="line"></span><br><span class="line">    // 构建基准包和补丁包都要指定不同的tinkerId，并且必须保证唯一性</span><br><span class="line">    tinkerId = &quot;1.0.1-patch&quot;                //tinkerId = &quot;1.0.1-patch&quot;            tinkerId = &quot;1.0.1-base&quot;</span><br><span class="line"></span><br><span class="line">    // 构建多渠道补丁时使用</span><br><span class="line">    // buildAllFlavorsDir = &quot;$&#123;bakPath&#125;/$&#123;baseApkDir&#125;&quot;</span><br><span class="line"></span><br><span class="line">    // 是否启用加固模式，默认为false.(tinker-spport 1.0.7起支持）</span><br><span class="line">    // isProtectedApp = true</span><br><span class="line"></span><br><span class="line">    // 是否开启反射Application模式</span><br><span class="line">    enableProxyApplication = false</span><br><span class="line"></span><br><span class="line">    // 是否支持新增非export的Activity（注意：设置为true才能修改AndroidManifest文件）</span><br><span class="line">    supportHotplugComponent = true</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 一般来说,我们无需对下面的参数做任何的修改</span><br><span class="line"> * 对于各参数的详细介绍请参考:</span><br><span class="line"> * https://github.com/Tencent/tinker/wiki/Tinker-%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97</span><br><span class="line"> */</span><br><span class="line">tinkerPatch &#123;</span><br><span class="line">    //oldApk =&quot;$&#123;bakPath&#125;/$&#123;appName&#125;/app-release.apk&quot;</span><br><span class="line">    ignoreWarning = false</span><br><span class="line">    useSign = true</span><br><span class="line">    dex &#123;</span><br><span class="line">        dexMode = &quot;jar&quot;</span><br><span class="line">        pattern = [&quot;classes*.dex&quot;]</span><br><span class="line">        loader = []</span><br><span class="line">    &#125;</span><br><span class="line">    lib &#123;</span><br><span class="line">        pattern = [&quot;lib/*/*.so&quot;]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res &#123;</span><br><span class="line">        pattern = [&quot;res/*&quot;, &quot;r/*&quot;, &quot;assets/*&quot;, &quot;resources.arsc&quot;, &quot;AndroidManifest.xml&quot;]</span><br><span class="line">        ignoreChange = []</span><br><span class="line">        largeModSize = 100</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    packageConfig &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    sevenZip &#123;</span><br><span class="line">        zipArtifact = &quot;com.tencent.mm:SevenZip:1.1.10&quot;</span><br><span class="line">//        path = &quot;/usr/local/bin/7za&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    buildConfig &#123;</span><br><span class="line">        keepDexApply = false</span><br><span class="line">        //tinkerId = &quot;1.0.1-base&quot;</span><br><span class="line">        //applyMapping = &quot;$&#123;bakPath&#125;/$&#123;appName&#125;/app-release-mapping.txt&quot; //  可选，设置mapping文件，建议保持旧apk的proguard混淆方式</span><br><span class="line">        //applyResourceMapping = &quot;$&#123;bakPath&#125;/$&#123;appName&#125;/app-release-R.txt&quot; // 可选，设置R.txt文件，通过旧apk文件保持ResId的分配</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面的配置比较多，一开始看还是有点儿眼花缭乱的，所以得慢慢来；</p><p>这里对其中的几点进行说明：</p><ul><li><em>baseApkDir</em> ： 这里填写每次构建生成的基准包目录，每次打包的时候，都会有新的目录和新的基准包生成，但是只有你打算发布的那一个的目录才是有效的。</li><li><em>tinkerId</em> ： 构建基准包和补丁包都要指定不同的tinkerId，并且必须保证唯一性。比如你的第一个基准包打包的时候可以把这个id设置为“1.0.0-base”，当你想打包热修复补丁包的时候，需要把这个id换成1.0.0-patch。</li></ul><p>更详细的配置项参考：<a href="https://bugly.qq.com/docs/utility-tools/plugin-gradle-hotfix/" target="_blank" rel="noopener">tinker-support配置说明</a></p><h4 id="第三步：初始化SDK"><a href="#第三步：初始化SDK" class="headerlink" title="第三步：初始化SDK"></a>第三步：初始化SDK</h4><p>上面的“tinker-support.gradle”中的enableProxyApplication属性设置的是false，是Tinker推荐的接入方式。</p><h5 id="自定义Application，当enableProxyApplication为false的情况"><a href="#自定义Application，当enableProxyApplication为false的情况" class="headerlink" title="自定义Application，当enableProxyApplication为false的情况"></a>自定义Application，当enableProxyApplication为false的情况</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class SampleApplication extends TinkerApplication &#123;</span><br><span class="line">    public SampleApplication() &#123;</span><br><span class="line">        super(ShareConstants.TINKER_ENABLE_ALL, &quot;xxx.xxx.SampleApplicationLike&quot;,</span><br><span class="line">                &quot;com.tencent.tinker.loader.TinkerLoader&quot;, false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SampleApplicationLike</strong>需要是自定义的继承<strong>DefaultApplicationLike</strong>的类，不要忘了在<strong>AndroidManifest.xml</strong>中声名上面的这个Application哦。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class SampleApplicationLike extends DefaultApplicationLike &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static final String TAG = &quot;Tinker.SampleApplicationLike&quot;;</span><br><span class="line"></span><br><span class="line">    public SampleApplicationLike(Application application, int tinkerFlags,</span><br><span class="line">                                 boolean tinkerLoadVerifyFlag, long applicationStartElapsedTime,</span><br><span class="line">                                 long applicationStartMillisTime, Intent tinkerResultIntent) &#123;</span><br><span class="line">        super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        // 这里实现SDK初始化，appId替换成你的在Bugly平台申请的appId</span><br><span class="line">        // 调试时，将第三个参数改为true</span><br><span class="line">        Bugly.init(getApplication(), &quot;900029763&quot;, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)</span><br><span class="line">    @Override</span><br><span class="line">    public void onBaseContextAttached(Context base) &#123;</span><br><span class="line">        super.onBaseContextAttached(base);</span><br><span class="line">        // you must install multiDex whatever tinker is installed!</span><br><span class="line">        MultiDex.install(base);</span><br><span class="line"></span><br><span class="line">        // 安装tinker</span><br><span class="line">        // TinkerManager.installTinker(this); 替换成下面Bugly提供的方法</span><br><span class="line">        Beta.installTinker(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)</span><br><span class="line">    public void registerActivityLifecycleCallback(Application.ActivityLifecycleCallbacks callbacks) &#123;</span><br><span class="line">        getApplication().registerActivityLifecycleCallbacks(callbacks);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面需要注意的是在“onCreate()”方法中进行初始化的时候，填入的appId是你在Bugly创建的项目的Appid，其他地方基本上不用改了</p><h5 id="自定义Application，当enableProxyApplication为true的情况"><a href="#自定义Application，当enableProxyApplication为true的情况" class="headerlink" title="自定义Application，当enableProxyApplication为true的情况"></a>自定义Application，当enableProxyApplication为true的情况</h5><p>这种的接入方式要简单许多，无须你改造Application</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class MyApplication extends Application &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        // 这里实现SDK初始化，appId替换成你的在Bugly平台申请的appId</span><br><span class="line">        // 调试时，将第三个参数改为true</span><br><span class="line">        Bugly.init(this, &quot;900029763&quot;, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void attachBaseContext(Context base) &#123;</span><br><span class="line">        super.attachBaseContext(base);</span><br><span class="line">        // you must install multiDex whatever tinker is installed!</span><br><span class="line">        MultiDex.install(base);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // 安装tinker</span><br><span class="line">        Beta.installTinker();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第四步：AndroidManifest-xml配置"><a href="#第四步：AndroidManifest-xml配置" class="headerlink" title="第四步：AndroidManifest.xml配置"></a>第四步：AndroidManifest.xml配置</h4><h5 id="1-权限配置："><a href="#1-权限配置：" class="headerlink" title="1.权限配置："></a>1.权限配置：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.READ_LOGS&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;</span><br></pre></td></tr></table></figure><h5 id="2-Activity配置："><a href="#2-Activity配置：" class="headerlink" title="2.Activity配置："></a>2.Activity配置：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;com.tencent.bugly.beta.ui.BetaActivity&quot;</span><br><span class="line">    android:configChanges=&quot;keyboardHidden|orientation|screenSize|locale&quot;</span><br><span class="line">    android:theme=&quot;@android:style/Theme.Translucent&quot; /&gt;</span><br></pre></td></tr></table></figure><h5 id="3-配置FileProvider"><a href="#3-配置FileProvider" class="headerlink" title="3.配置FileProvider"></a>3.配置FileProvider</h5><pre><code>注意：如果您想兼容Android N或者以上的设备，必须要在AndroidManifest.xml文件中配置FileProvider来访问共享路径的文件。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--热更新需要的Provider--&gt;</span><br><span class="line">&lt;provider</span><br><span class="line">    android:name=&quot;android.support.v4.content.FileProvider&quot;</span><br><span class="line">    android:authorities=&quot;$&#123;applicationId&#125;.fileProvider&quot;</span><br><span class="line">    android:exported=&quot;false&quot;</span><br><span class="line">    android:grantUriPermissions=&quot;true&quot;&gt;</span><br><span class="line">    &lt;meta-data</span><br><span class="line">        android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;</span><br><span class="line">        android:resource=&quot;@xml/provider_paths&quot;/&gt;</span><br><span class="line">&lt;/provider&gt;</span><br></pre></td></tr></table></figure><p>在res目录新建xml文件夹，创建provider_paths.xml文件如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;paths xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;!-- /storage/emulated/0/Download/$&#123;applicationId&#125;/.beta/apk--&gt;</span><br><span class="line">    &lt;external-path name=&quot;beta_external_path&quot; path=&quot;Download/&quot;/&gt;</span><br><span class="line">    &lt;!--/storage/emulated/0/Android/data/$&#123;applicationId&#125;/files/apk/--&gt;</span><br><span class="line">    &lt;external-path name=&quot;beta_external_files_path&quot; path=&quot;Android/data/&quot;/&gt;</span><br><span class="line">&lt;/paths&gt;</span><br></pre></td></tr></table></figure></p><h4 id="第五步：混淆配置"><a href="#第五步：混淆配置" class="headerlink" title="第五步：混淆配置"></a>第五步：混淆配置</h4><p>为了避免混淆SDK，在Proguard混淆文件中增加以下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-dontwarn com.tencent.bugly.**</span><br><span class="line">-keep public class com.tencent.bugly.**&#123;*;&#125;</span><br><span class="line"># tinker混淆规则</span><br><span class="line">-dontwarn com.tencent.tinker.**</span><br><span class="line">-keep class com.tencent.tinker.** &#123; *; &#125;</span><br></pre></td></tr></table></figure></p><h3 id="三、打包"><a href="#三、打包" class="headerlink" title="三、打包"></a>三、打包</h3><p>当上面的环境配置都没有问题之后，就可以进行打包了。</p><p>打包之前，你还得配置一下编译正式版apk所需要的<strong>keystore.jks</strong>文件，这个文件怎么创建的就不介绍了，这里主要介绍一下如何配置：</p><p>在app moudle目录下的“build.gradle”中配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            keyAlias &apos;xxxxxxxx&apos;</span><br><span class="line">            keyPassword &apos;xxxxxxxx&apos;</span><br><span class="line">            storeFile file(&apos;../keystore.jks&apos;)</span><br><span class="line">            storePassword &apos;xxxxxxxx&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled true</span><br><span class="line">            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</span><br><span class="line">            signingConfig signingConfigs.release</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的各项参数就不必做说明了</p><p>然后就是打包过程<img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Bugly%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/bugly-001.png" alt="image"></p><p><strong>打包过程中需要注意之前提到过的tinkerId的配置，以及目录的配置，很重要哦！</strong></p><p>生成的基准包会在这个目录</p><p><img src="https://bugly.qq.com/docs/img/hotfix/android/Snip20170209_2.png?v=20180709165613" alt="image"></p><p>生成的补丁包会在这个目录</p><p><img src="https://bugly.qq.com/docs/img/hotfix/android/1479216059696.png?v=20180709165613" alt="image"></p><p>然后就准备开始使用吧</p><h3 id="四、使用"><a href="#四、使用" class="headerlink" title="四、使用"></a>四、使用</h3><p>找到你创建的产品，然后进入到下面的界面</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Bugly%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/bugly-002.png" alt="image"></p><p>接着，发布新补丁吧，看一看效果<br><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Bugly%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/bugly-003.png" alt="image"></p><p>具体的效果可以自行尝试一下，不过有时候你会遇到上传不成功的情况，一般下发后要过5到10分钟才会生效（可能是我的网络问题），如果太久没效果，应该是哪里出问题了</p><h2 id="尾"><a href="#尾" class="headerlink" title="尾"></a>尾</h2><p>前面的所有操作都尝试过后，接下来你可能就会面临新的需求了。比如说，多渠道打包的实现，比较旧的办法是通过productFlavors去实现分别打包，不过这样会有一个弊端，即有多少渠道打包流程就执行多少次，这样效率显然是不够的；</p><p>于是乎，新的打包方案出来了：</p><h3 id="使用Walle进行多渠道打包"><a href="#使用Walle进行多渠道打包" class="headerlink" title="使用Walle进行多渠道打包"></a>使用Walle进行多渠道打包</h3><p>下面是Walle的github地址：</p><p><a href="https://github.com/Meituan-Dianping/walle" target="_blank" rel="noopener">Walle（瓦力）：Android Signature V2 Scheme签名下的新一代渠道包打包神器</a></p><p>它的接入文档写的也十分友好，接下来实际操作一遍：</p><h4 id="Walle的Gradle接入"><a href="#Walle的Gradle接入" class="headerlink" title="Walle的Gradle接入"></a>Walle的Gradle接入</h4><p>在项目根目录的 <strong>build.gradle</strong> 中添加依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &apos;com.meituan.android.walle:plugin:1.1.6&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在app module中的 <strong>build.gradle</strong> 添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;walle&apos;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;com.meituan.android.walle:library:1.1.6&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并进行插件配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">walle &#123;</span><br><span class="line">    // 指定渠道包的输出路径</span><br><span class="line">    apkOutputFolder = new File(&quot;$&#123;project.buildDir&#125;/outputs/channels&quot;);</span><br><span class="line">    // 定制渠道包的APK的文件名称</span><br><span class="line">    apkFileNameFormat = &apos;$&#123;appName&#125;-$&#123;packageName&#125;-$&#123;channel&#125;-$&#123;buildType&#125;-v$&#123;versionName&#125;-$&#123;versionCode&#125;-$&#123;buildTime&#125;.apk&apos;;</span><br><span class="line">    // 渠道配置文件</span><br><span class="line">    channelFile = new File(&quot;$&#123;project.getProjectDir()&#125;/channel&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着在app module目录下创建一个文件，和上面配置中要保持一致，就叫 <strong>channel</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">360</span><br><span class="line">yingyongbao</span><br><span class="line">baidu</span><br><span class="line">wandoujia</span><br><span class="line">xiaomi</span><br><span class="line">oppo</span><br><span class="line">lenovo</span><br><span class="line">huawei</span><br><span class="line">default_channel</span><br><span class="line"># 打包命令 gradlew clean assembleReleaseChannels  或者 gradlew assembleReleaseChannels</span><br></pre></td></tr></table></figure></p><p>最后，在你的Application中的<strong>onCreate</strong>方法里添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String channel = WalleChannelReader.getChannel(getApplication());</span><br><span class="line">Bugly.setAppChannel(getApplication(), channel);</span><br></pre></td></tr></table></figure><p>如果你实现的是<strong>SampleApplicationLike</strong>，也是在它的<strong>onCreate</strong>方法里添加即可。</p><p>接下来通过运行上面的打包命令或者通过图中的手动操作，都是可以打包的</p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Bugly%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/bugly-004.png" alt="image"></p><h2 id="末"><a href="#末" class="headerlink" title="末"></a>末</h2><p>至此，基本上整个配置流程就到此结束!!!</p><p>不过有一个问题我一直不知道如何解决，就是打包基准包的命名，在 <strong>tinker-support.gradle</strong> 进行配置是不起效果的，试了好久都没效果，看来还得交给其他小伙伴们解决了</p><p><em>那么</em></p><p><img src="https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Bugly%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/zaihui.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;头&quot;&gt;&lt;a href=&quot;#头&quot; class=&quot;headerlink&quot; title=&quot;头&quot;&gt;&lt;/a&gt;头&lt;/h2&gt;&lt;p&gt;不知道你是否遇到过这个情况，项目上线后或者开始给别人使用的时候，冷不丁的冒出个Bug，这时候首先要干嘛？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;先看崩溃日志啊&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;看完崩溃日志你知道了造成崩溃的原因，然后干嘛？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;开始甩锅啊&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当查明了是谁造成的这个崩溃后，你发现不是你的问题，于是你心中一乐，长舒一口气
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android开发者编写自己的API接口（下）</title>
    <link href="http://yoursite.com/2018/08/14/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://yoursite.com/2018/08/14/Android开发者编写自己的API接口（下）/</id>
    <published>2018-08-14T11:59:17.000Z</published>
    <updated>2018-08-14T12:05:14.085Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上一篇<a href="https://oldchen.top/2018/08/05/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="noopener">Android开发者编写自己的API接口（上）</a>中，已经介绍了如何搭建一个基本的开发环境，以及接口的编写，最后是能够成功运行的。</p><p>这一篇将更进一步，主要解决下面两个问题：</p><ul><li>①：如何让后台项目运行在TomCat上</li><li>②：如何在云服务器上部署自己的项目</li></ul><a id="more"></a><h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><h4 id="一、本地Tomcat的使用"><a href="#一、本地Tomcat的使用" class="headerlink" title="一、本地Tomcat的使用"></a>一、本地Tomcat的使用</h4><h5 id="1-1、安装Tomcat"><a href="#1-1、安装Tomcat" class="headerlink" title="1.1、安装Tomcat"></a>1.1、安装Tomcat</h5><p>使用TomCat，自然是要TomCat的安装包咯</p><p><a href="https://tomcat.apache.org/download-90.cgi" target="_blank" rel="noopener">安装包下载地址</a></p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/001.png" alt="image"></p><p>由于我们本地应该都是已经安装配置过JDK了的，所以安装Tomcat的时候一路Next就行了</p><h5 id="1-2、配置Gradle"><a href="#1-2、配置Gradle" class="headerlink" title="1.2、配置Gradle"></a>1.2、配置Gradle</h5><p>首先，在项目的gradle所在的目录下创建gradle.properties，然后在里面添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># true就去打包War，否则不打包</span><br><span class="line">BUILD_WAR=true</span><br></pre></td></tr></table></figure></p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/002.png" alt="image"></p><p>接着在build.gradle中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (BUILD_WAR.toBoolean()) &#123;</span><br><span class="line">    apply plugin: &apos;war&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (BUILD_WAR.toBoolean()) &#123;</span><br><span class="line">        providedRuntime(&apos;org.springframework.boot:spring-boot-starter-tomcat&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/003.png" alt="image"></p><p>同时，不要忘了创建一个ServletInitializer类，用于SpringBoot的初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ServletInitializer extends SpringBootServletInitializer &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123;</span><br><span class="line">return application.sources(TestForDemoApplication.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/008.png" alt="image"></p><p>这些都完成后，在Terminal控制台输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradlew assemble</span><br></pre></td></tr></table></figure><p>等待结果，然后就可以看到一个war包了</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/004.png" alt="image"></p><h5 id="1-3、配置Tomcat"><a href="#1-3、配置Tomcat" class="headerlink" title="1.3、配置Tomcat"></a>1.3、配置Tomcat</h5><p>找到demo-0.0.1-SNAPSHOT.war所在目录，然后将其更名为oldchen.war</p><pre><code>注意，这里修改后的名字将会与部署到Tomcat上的网络请求地址有关哦</code></pre><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/005.png" alt="image"></p><p>然后找到Tomcat的安装目录下的webapps目录，将里面的其他文件和文件夹删除，把oldchen.war复制到该目录</p><p>接下来，在Tomcat目录下的bin目录中运行Tomcat9w.exe</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/006.png" alt="image"></p><p>然后你会发现，webapps目录下多了一个文件</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/007.png" alt="image"></p><h5 id="1-4、测试本地Tomcat"><a href="#1-4、测试本地Tomcat" class="headerlink" title="1.4、测试本地Tomcat"></a>1.4、测试本地Tomcat</h5><p>接下来，访问地址：</p><p><a href="http://localhost:8080/oldchen/user/user?account=oldchen" target="_blank" rel="noopener">http://localhost:8080/oldchen/user/user?account=oldchen</a></p><p>结果：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/009.png" alt="image"></p><p>可以看到，本地的Tomcat已经部署成功，接下来就是云服务器上部署Tomcat了。</p><h4 id="二、云服务器上Tomcat的部署"><a href="#二、云服务器上Tomcat的部署" class="headerlink" title="二、云服务器上Tomcat的部署"></a>二、云服务器上Tomcat的部署</h4><h5 id="2-1、购买云服务器"><a href="#2-1、购买云服务器" class="headerlink" title="2.1、购买云服务器"></a>2.1、购买云服务器</h5><p>想在云服务器上部署Tomcat，首先需要购买一个服务器，我买的是腾讯云的服务器，初次接触的同学建议去使用试用的云服务器，等操作成功后再买也不迟</p><p>出于对初学者的人文关怀（没错，Is me），这里我使用的是Windows版的服务器：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/010.png" alt="image"></p><p>为了能够正常访问服务器的地址，需要给服务器配置一下安全组，安全组中需要添加这样一项规则：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/011.png" alt="image"></p><p>然后，使用远程连接，连接到云服务器，具体操作是：</p><pre><code>一、win+R二、输入mstsc三、输入云服务器的Ip地址，用户名以及密码，连接</code></pre><p>如果你使用的是windows2016版的服务器，同时遇到了”身份验证错误，要求的函数不支持”，而且你恰好是win10家庭版，那么下面有解决办法：<br><a href="https://jingyan.baidu.com/album/67508eb47ae5499ccb1ce410.html?picindex=3" target="_blank" rel="noopener">windows10家庭版 远程桌面报错</a></p><p>成功登录后，整个界面只有一个孤伶伶的回收站，到了这步，就准备开始配置吧。</p><h5 id="2-2、配置云服务器"><a href="#2-2、配置云服务器" class="headerlink" title="2.2、配置云服务器"></a>2.2、配置云服务器</h5><p>云服务器上面运行项目只需要Tomcat+Mysql+Navicat+JDK，配置方法和之前在本地配置是一样的，不过这里不建议使用上传的方法，因为上传实际上和下载是一样的，有时候还会受限于你自己宽带的上行速度。</p><p>重新下载安装JDK是很头疼的，下面是详细教程：</p><p><a href="https://blog.csdn.net/qq_32519693/article/details/71330930" target="_blank" rel="noopener">非常详细图文JDK和Tomcat安装和配置的图文教程</a></p><p>全部需要准备的文件如下：<br><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/012.png" alt="image"></p><p>其中，<strong>PatchNavicat</strong> 用于Navicat的破解，在上一篇的链接中已经说明。</p><p>而<strong>oldchen.sql</strong>则是通过本地Navicat生成Mysql文件，具体操作是：右键你选中的数据库，选择【转储SQL文件】→【结构和数据】，然后就可以生成了。使用方法就是在云服务器上创建一个数据库后选择【运行SQL文件】即可。</p><p>这样，本地数据库的迁移就完成了。剩下的操作与之前介绍的基本一致，不过有一点需要注意，为了开启外网连接，需要在Tomcat安装目录下找到conf目录，修改其中的server.xml文件：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/013.png" alt="image"></p><p>将port由8080修改为80</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/014.png" alt="image"></p><p>当你完成全部的操作后，就可以测试接口了。</p><h5 id="2-3、测试云服务器接口"><a href="#2-3、测试云服务器接口" class="headerlink" title="2.3、测试云服务器接口"></a>2.3、测试云服务器接口</h5><p>只要你的步骤是ok的，那么云服务器不会有什么问题。</p><p>由于在写这篇文章期间，我又多写了个登录接口，所以这里的测试例子用的是新的接口，仅供参考：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/2018.8.13/015.png" alt="image"></p><p>请求地址是：<a href="http://111.230.251.115/oldchen/user/login" target="_blank" rel="noopener">http://111.230.251.115/oldchen/user/login</a></p><h2 id="后语"><a href="#后语" class="headerlink" title="后语"></a>后语</h2><p>那么，编写接口的学习就到此为止了。</p><p>虽然有待完善的地方还不少，比如通过数据库指令对数据库进行增删改查、数据库之间相互关联等等，许多知识都需要慢慢学的。</p><p>此文章权当入门之径，剩下的还得靠大家自己多多钻研啦，毕竟作者本人需要学的地方也太多了，如有错误之处，还望指出，互相学习，岂不乐哉。</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/%E8%A1%A8%E6%83%85%E5%8C%85/%E5%91%8A%E8%BE%9E2.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在上一篇&lt;a href=&quot;https://oldchen.top/2018/08/05/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android开发者编写自己的API接口（上）&lt;/a&gt;中，已经介绍了如何搭建一个基本的开发环境，以及接口的编写，最后是能够成功运行的。&lt;/p&gt;
&lt;p&gt;这一篇将更进一步，主要解决下面两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;①：如何让后台项目运行在TomCat上&lt;/li&gt;
&lt;li&gt;②：如何在云服务器上部署自己的项目&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android开发者编写自己的API接口（上）</title>
    <link href="http://yoursite.com/2018/08/05/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://yoursite.com/2018/08/05/Android开发者编写自己的API接口（上）/</id>
    <published>2018-08-05T13:31:04.000Z</published>
    <updated>2018-08-14T11:58:19.026Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>作为一名Android开发人员，想要实现对一些数据的操作和展示，可以通过一些提供Api接口的网站去获取，虽然Api市场上种类繁多，不过别人提供的接口未必就是自己想要的，到最后，还是得自己去实现Api接口。</p><p>毕竟，最了解自己需求的人，还得是自己。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>很多小伙伴应该都会有着类似的需求，不过想去做的时候，常常无从下手。</p><p>所以这里做了一个整合，关于如何搭建开发环境，以及所需工具的下载等。</p><a id="more"></a> <p>参考文章：</p><ul><li><a href="https://www.jianshu.com/p/4a0d40806ea2" target="_blank" rel="noopener">Android程序员搭建一个属于自己的服务器，不再求各种公共API</a></li><li><a href="https://www.jianshu.com/p/f91ca5814bcf" target="_blank" rel="noopener">JAVA后台搭建(springboot+mybatis+mysql)项目搭建</a></li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>一套开发环境下来，需要下面这些步骤：</p><ul><li>1：搭建开发环境，IntelliJ + spring-boot + mybatis</li><li>2：搭建数据库，mysql + navicat</li><li>3：搭建运行环境，tomcat + 腾讯云（或者阿里云）</li></ul><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="一、搭建开发环境"><a href="#一、搭建开发环境" class="headerlink" title="一、搭建开发环境"></a>一、搭建开发环境</h3><h4 id="1-1-IntelliJ-IDEA的安装"><a href="#1-1-IntelliJ-IDEA的安装" class="headerlink" title="1.1 IntelliJ IDEA的安装"></a>1.1 IntelliJ IDEA的安装</h4><p>Android开发者所使用的Android studio是基于这个IDEA开发的，所以两者的界面非常非常相似。</p><p>而且现在比较流行的Android开发语言Kotlin也是由IntelliJ IDEA的开发公司JetBrains所开发的。</p><h5 id="下载-IntelliJ-IDEA"><a href="#下载-IntelliJ-IDEA" class="headerlink" title="下载 IntelliJ IDEA"></a>下载 IntelliJ IDEA</h5><p>首先，下载安装包——<a href="https://www.jetbrains.com/idea/download/#section=windows" target="_blank" rel="noopener">【IntelliJ下载地址】</a></p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001.png" alt="image"></p><h5 id="安装-IntelliJ-IDEA"><a href="#安装-IntelliJ-IDEA" class="headerlink" title="安装 IntelliJ IDEA"></a>安装 IntelliJ IDEA</h5><p>下载完成后，就开始安装了</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-001.png" alt="image"></p><p>Next到下面的界面，可以自行选择</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-002.png" alt="image"></p><p>然后一直下一步，到可以运行IDEA，然后你应该会遇到需要购买的提示，破解的教程请看：</p><p><a href="https://blog.csdn.net/yangying496875002/article/details/73603303" target="_blank" rel="noopener">Windows7下安装与破解IntelliJ IDEA2017</a></p><p>win10也是适用的。</p><h4 id="1-2-MySQL的安装"><a href="#1-2-MySQL的安装" class="headerlink" title="1.2 MySQL的安装"></a>1.2 MySQL的安装</h4><h5 id="下载MySQL"><a href="#下载MySQL" class="headerlink" title="下载MySQL"></a>下载MySQL</h5><p>这里使用的是mysql-5.7.17.msi，下载地址是：</p><p><a href="https://downloads.mysql.com/archives/installer/" target="_blank" rel="noopener">MYSQL下载地址</a></p><h5 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h5><p>下载完成后进行安装：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-006.png" alt="image"></p><p>这里只选择了Server</p><p>然后一直下一步</p><p>到了设置密码这里，我设置的密码是【oldchen】,后面项目配置的密码也是这个，这里你可以随便设置自己的密码，不过后面配置的时候要保证密码输入一致就是：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-007.png" alt="image"></p><p>然后一直下一步，直到安装成功，接下来就是如何去操作数据库。</p><h4 id="1-3-Navicat的安装"><a href="#1-3-Navicat的安装" class="headerlink" title="1.3 Navicat的安装"></a>1.3 Navicat的安装</h4><p>Navicat用来对数据库进行操作，也是需要付费购买的，破解地址：<br><a href="https://blog.csdn.net/wypersist/article/details/79834490" target="_blank" rel="noopener">Navicat for MySQL 安装和破解（完美）</a></p><p>可以使用之后，来到如下界面：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-008.png" alt="image"></p><p>然后创建MYSQL连接：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-009.png" alt="image"></p><p>输入相关信息：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-010.png" alt="image"></p><p>然后就可以看到创建的连接了，右键→新建数据库：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-011.png" alt="image"></p><p>新建的数据库名字设置为oldchen,接下来双击这个数据库，新建一个user表,表中包含account,password,username以及自增主键id，具体操作如图所示：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/gif/001.gif" alt="image"></p><p>创建这个表后，我们可以添加一条数据：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-012.png" alt="image"></p><p>然后，开始配置IntelliJ IDEA</p><h4 id="1-4-IntelliJ-IDEA的配置"><a href="#1-4-IntelliJ-IDEA的配置" class="headerlink" title="1.4 IntelliJ IDEA的配置"></a>1.4 IntelliJ IDEA的配置</h4><h5 id="搭建SpringBoot项目"><a href="#搭建SpringBoot项目" class="headerlink" title="搭建SpringBoot项目"></a>搭建SpringBoot项目</h5><p>打开IntelliJ，左上角 File → New → Project，创建新项目：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-013.png" alt="image"></p><p>然后</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-004.png" alt="image"></p><p>接下来是选择依赖的界面，选中图中的全部依赖</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-005.png" alt="image"></p><p>下一步<br><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-019.png" alt="image"></p><p>开始项目构建，需要等待一定的时间，构建完成后的项目结构是这样的：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-015.png" alt="image"></p><p>结合之前新建的数据库，在resources目录下的application.properties中进行配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#oldchen为创建的数据库名字</span><br><span class="line">spring.datasource.url =jdbc:mysql://localhost:3306/oldchen</span><br><span class="line">mybatis.type-aliases-package = com.example.demo</span><br><span class="line"># 数据库用户名</span><br><span class="line">spring.datasource.username = root</span><br><span class="line"># 数据库密码</span><br><span class="line">spring.datasource.password = oldchen</span><br><span class="line"></span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line">#端口号</span><br><span class="line">spring.session.store-type=none</span><br><span class="line">spring.http.encoding.charset=UTF-8</span><br></pre></td></tr></table></figure><p>接下来就开始写接口啦</p><h4 id="1-5-接口的编写"><a href="#1-5-接口的编写" class="headerlink" title="1.5 接口的编写"></a>1.5 接口的编写</h4><p>由于我们之前在操作名为【oldchen】的数据库时，还新建了一个【user】表，所以这里先创建一个User类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String account;</span><br><span class="line">    private String password;</span><br><span class="line">    private String userName;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAccount() &#123;</span><br><span class="line">        return account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAccount(String account) &#123;</span><br><span class="line">        this.account = account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPassword(String password) &#123;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getUserName() &#123;</span><br><span class="line">        return userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUserName(String userName) &#123;</span><br><span class="line">        this.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建UserMapper，用于查询（根据字段account查询）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface UserMapper &#123;</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select * from user where account = #&#123;account&#125;&quot;)</span><br><span class="line">    User findByAccount(String account);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着创建UserController，用于对数据的处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&#123;&quot;/user&quot;&#125;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value=&quot;/user&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String getUserInfoByName(String account) &#123;</span><br><span class="line">        User user = userMapper.findByAccount(account);</span><br><span class="line">        if (user == null)&#123;</span><br><span class="line">            return &quot;用户名保不存在&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &quot;用户名存在——&quot; + user.getUserName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后项目结构如下：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-016.png" alt="image"></p><h3 id="二、测试接口"><a href="#二、测试接口" class="headerlink" title="二、测试接口"></a>二、测试接口</h3><p>首先，运行项目</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-017.png" alt="image"></p><p>当项目正常运行后，测试下面的地址：</p><p><a href="http://localhost:8080/user/user?account=oldchen" target="_blank" rel="noopener">http://localhost:8080/user/user?account=oldchen</a></p><p>结果：</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/001-018.png" alt="image"></p><p>测试成功啦！</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>关于Api接口的学习，先到这里。</p><p>后面还会写关于如何将项目放在TomCat上，最后放在云服务器上，通过外网地址访问接口</p><p>那么，未完待续…</p><p><img src="https://my-blog-picture.oss-cn-beijing.aliyuncs.com/%E8%A1%A8%E6%83%85%E5%8C%85/%E5%91%8A%E8%BE%9E.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;作为一名Android开发人员，想要实现对一些数据的操作和展示，可以通过一些提供Api接口的网站去获取，虽然Api市场上种类繁多，不过别人提供的接口未必就是自己想要的，到最后，还是得自己去实现Api接口。&lt;/p&gt;
&lt;p&gt;毕竟，最了解自己需求的人，还得是自己。&lt;/p&gt;
&lt;h2 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h2&gt;&lt;p&gt;很多小伙伴应该都会有着类似的需求，不过想去做的时候，常常无从下手。&lt;/p&gt;
&lt;p&gt;所以这里做了一个整合，关于如何搭建开发环境，以及所需工具的下载等。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Old Chen&#39;s Wish List</title>
    <link href="http://yoursite.com/2018/07/29/Old%20Chen&#39;s%20Wish%20List/"/>
    <id>http://yoursite.com/2018/07/29/Old Chen&#39;s Wish List/</id>
    <published>2018-07-29T14:51:44.000Z</published>
    <updated>2018-08-14T12:03:05.890Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Old-Chen的愿望"><a href="#一、Old-Chen的愿望" class="headerlink" title="一、Old Chen的愿望"></a>一、Old Chen的愿望</h2><h4 id="1-、have-a-good-feel"><a href="#1-、have-a-good-feel" class="headerlink" title="(1)、have a good feel"></a>(1)、have a good feel</h4><h4 id="2-、看完所有买的文学书"><a href="#2-、看完所有买的文学书" class="headerlink" title="(2)、看完所有买的文学书"></a>(2)、看完所有买的文学书</h4><ul><li style="list-style: none"><input type="checkbox"> 1：东野硅谷系列</li><li style="list-style: none"><input type="checkbox"> 2：三体系列             （✔××）<a id="more"></a> </li><li style="list-style: none"><input type="checkbox"> 3：《时间简史》</li><li style="list-style: none"><input type="checkbox"> 4：《边城》</li><li style="list-style: none"><input type="checkbox"> 5：《百年孤独》</li><li style="list-style: none"><input type="checkbox"> 6：《茶馆》</li></ul><h4 id="3-、买一些想买的东西"><a href="#3-、买一些想买的东西" class="headerlink" title="(3)、买一些想买的东西"></a>(3)、买一些想买的东西</h4><ul><li style="list-style: none"><input type="checkbox"> 1：《矮大紧指北》</li><li style="list-style: none"><input type="checkbox" checked> 2：《老梁的四大名著情商课》     </li><li style="list-style: none"><input type="checkbox" checked> 3：一个新的手机                </li><li style="list-style: none"><input type="checkbox"> 4：预购游戏</li><li style="list-style: none"><input type="checkbox" checked> 5：好吃的零食</li><li style="list-style: none"><input type="checkbox"> 6：一个天文望远镜</li><li style="list-style: none"><input type="checkbox" checked> 7：一个游戏机(switch)</li></ul><h4 id="4-、玩完已经买了的游戏"><a href="#4-、玩完已经买了的游戏" class="headerlink" title="(4)、玩完已经买了的游戏"></a>(4)、玩完已经买了的游戏</h4><ul><li style="list-style: none"><input type="checkbox"> 1：《巫师3》</li><li style="list-style: none"><input type="checkbox" checked> 2：《黑魂3》                 （全成就）</li><li style="list-style: none"><input type="checkbox"> 3：刺客信条系列</li><li style="list-style: none"><input type="checkbox"> 4：《古墓丽影：崛起》</li><li style="list-style: none"><input type="checkbox" checked> 5:《杀戮尖塔》 （全成就）</li><li style="list-style: none"><input type="checkbox" checked> 5:《塞尔达传说：旷野之息》 （救出公主）</li></ul><h4 id="5-、写APP"><a href="#5-、写APP" class="headerlink" title="(5)、写APP"></a>(5)、写APP</h4><ul><li style="list-style: none"><input type="checkbox"> 写一个日记本APP    (Wringting)</li><li style="list-style: none"><input type="checkbox"> 写一个单词生词本APP</li></ul><h4 id="6-、养宠物-Hard"><a href="#6-、养宠物-Hard" class="headerlink" title="(6)、养宠物(Hard)"></a>(6)、养宠物(Hard)</h4><ul><li style="list-style: none"><input type="checkbox"> 养一只猫  </li></ul><h2 id="二、Old-Chen的长期愿望-Hard"><a href="#二、Old-Chen的长期愿望-Hard" class="headerlink" title="二、Old Chen的长期愿望(Hard)"></a>二、Old Chen的长期愿望(Hard)</h2><h4 id="1-、学习啦"><a href="#1-、学习啦" class="headerlink" title="(1)、学习啦"></a>(1)、学习啦</h4><h4 id="2-、充实自己"><a href="#2-、充实自己" class="headerlink" title="(2)、充实自己"></a>(2)、充实自己</h4><h4 id="3-、自得其乐"><a href="#3-、自得其乐" class="headerlink" title="(3)、自得其乐"></a>(3)、自得其乐</h4><h2 id="三、老晨子的终极愿望"><a href="#三、老晨子的终极愿望" class="headerlink" title="三、老晨子的终极愿望"></a>三、老晨子的终极愿望</h2><p><strong>莫春者，春服既成，冠者五六人，童子六七人，浴乎沂，风乎舞雩，咏而归</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、Old-Chen的愿望&quot;&gt;&lt;a href=&quot;#一、Old-Chen的愿望&quot; class=&quot;headerlink&quot; title=&quot;一、Old Chen的愿望&quot;&gt;&lt;/a&gt;一、Old Chen的愿望&lt;/h2&gt;&lt;h4 id=&quot;1-、have-a-good-feel&quot;&gt;&lt;a href=&quot;#1-、have-a-good-feel&quot; class=&quot;headerlink&quot; title=&quot;(1)、have a good feel&quot;&gt;&lt;/a&gt;(1)、have a good feel&lt;/h4&gt;&lt;h4 id=&quot;2-、看完所有买的文学书&quot;&gt;&lt;a href=&quot;#2-、看完所有买的文学书&quot; class=&quot;headerlink&quot; title=&quot;(2)、看完所有买的文学书&quot;&gt;&lt;/a&gt;(2)、看完所有买的文学书&lt;/h4&gt;&lt;ul&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; 1：东野硅谷系列&lt;/li&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; 2：三体系列             （✔××）
    
    </summary>
    
    
  </entry>
  
</feed>
